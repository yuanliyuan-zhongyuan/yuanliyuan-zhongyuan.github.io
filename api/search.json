[{"id":"3073fd51d1122ba9499218ad4f0dfd19","title":"符号","content":"汇编\n\n\n\n\n\n\n\n\n我们上面说了数据宽度，比如，如果数据宽度为一个字节，那么存储的数据范围就是0~0xFF\n那么这里的数据代表什么意思\n\n\n\n0\n1\n0\n1\n0\n1\n0\n1\n\n\n\n比如\n文本文件中这个数表示逗号\nexe程序中也可能是一条指令\n也有可能是一个数字55\n不同的文件有不同的编码规则，对应不同的含义，比如视频，图片，文本等等\n二级标题二级标题三级标题四级标题五级标题六级标题","slug":"逆向魔王/汇编/6.虫壳汇编 符号","date":"2022-12-15T10:49:36.000Z","categories_index":"汇编","tags_index":"汇编,逆向","author_index":"虫子"},{"id":"ad7e7ff4bc7c85c8fdf0eb9a9b7b9676","title":"进制","content":"汇编进制现实生活中有哪些进制\n\n\n\n\n\n\n\n\n\n\n\n1进制\n7进制\n2进制\n16进制\n10进制\n60进制\n\n\n\n结绳记事\n星期\n阴阳\n0-F\n半斤八两\n时分秒\n\n\n我们为什么要学习进制\n电路开关，电子管，晶体管，半导体\n\n二进制可执行文件exe\n\n计算机为什么最终选择采用二进制？\n电子计算机：高低电平只能表示1和0的逻辑电路\n&#x3D;&#x3D;汇编语言中不区分大小写，这属于语法的层次&#x3D;&#x3D;\n学习进制的障碍\n很多人学不好进制原因是总以十进制为依托去考虑其他进制，需要运算的时候也总是先转换成十进制，这种学习方法是错误的\n我们为什么一定要转化成十进制呢?仅仅是因为我们对十进制最熟悉，所以才转换\n正确的学习方法\n每一种进制都是完美的，想学好进制需要记住不仅仅只是十进制，还要有二进制，十六进制等其他进制的存在\n进制的书写:进位\n\n\n\n\n\n\n\n\n就是数数，不够就进位。我就不举例子了，这个课件是养老的\n推导进制的定义\n\n\n\n\n\n\n\n\n进制的定义\n十进制的定义：由十个符号组成，分别是0123456789逢十进一。二进制的定义：由二个符号组成，分别是01逢二进一八进制的定义：由八个符号组成，分别是01234567逢八进一。十六进制的定义：由十六个符号组成，分别是0123456789ABCDEF逢十六进一。\n&#x3D;&#x3D;N进制的定义:由0,1,2….N-1，N个符号组成，逢N进一&#x3D;&#x3D;\n你理解进制了吗?1+1&#x3D;3对吗？\n\n\n\n\n\n\n\n\n阿拉伯数字:0 1 2 3 4 5 6 7 8 9 古印度人发明的\n罗马数字:I II III IV V VI VII VIII IX 没有0\n中国:零 壹 贰 叁 肆 伍 陆 柒 捌 玖 拾\n0的故事：中世纪欧洲没有数字0，有人因为0被教会处死\n自定义\n\n\n\n\n\n\n\n\n十进制的定义：由十个符号组成，分别是0132876945逢十进一。十进制的定义：由十个符号组成，分别是ASBLK76V95逢十进一。\n进制运算最简单的十进制\n\n\n\n\n\n\n\n\n已经在人类认知中根深蒂固的东西\n八进制\n\n\n\n\n\n\n\n\n我们背那些二四得八，三七二十一是因为我们早就把99乘法表印在脑子里面了，所以用其他进制的时候就需要把以前的表给破掉，自己造个表，一切都是打破重来，别看这不起眼的东西，如今现在社会没有人敢打破计算机二进制的格局，之前俄罗斯好像造三进制的计算机，现在也好像也起色了，蛮佩服国外破而后立的决心\n八进制加法表(查数)\n\n\n\n\n\n\n\n\n0 1 2 3 4 5 6 7 10 11 12 13 14 15 16 17 20\n\n\n\n\n\n\n\n\n\n\n\n\n1+1&#x3D;2\n\n\n\n\n\n\n\n\n\n1+2&#x3D;3\n2+2&#x3D;4\n\n\n\n\n\n\n\n1+3&#x3D;4\n2+3&#x3D;5\n3+3&#x3D;6\n\n\n\n\n\n\n1+4&#x3D;5\n2+4&#x3D;6\n3+4&#x3D;7\n4+4&#x3D;10\n\n\n\n\n\n1+5&#x3D;6\n2+5&#x3D;7\n3+5&#x3D;10\n4+5&#x3D;11\n5+5&#x3D;12\n\n\n\n\n1+6&#x3D;7\n2+6&#x3D;10\n3+6&#x3D;11\n4+6&#x3D;12\n5+6&#x3D;13\n6+6&#x3D;14\n\n\n\n1+7&#x3D;10\n2+7&#x3D;11\n3+7&#x3D;12\n4+7&#x3D;13\n5+7&#x3D;14\n6+7&#x3D;15\n7+7&#x3D;16\n\n\n八进制乘法表(查数，乘法&#x3D;&gt;加法2*3&#x3D;2+2+2&#x3D;6)\n\n\n\n\n\n\n\n\n0 1 2 3 4 5 6 7 10 11 12 13 14 15 16 17 20\n\n\n\n\n\n\n\n\n\n\n\n\n1*1&#x3D;1\n\n\n\n\n\n\n\n\n\n1*2&#x3D;2\n2*2&#x3D;4\n\n\n\n\n\n\n\n1*3&#x3D;3\n2*3&#x3D;6\n3*3&#x3D;11\n\n\n\n\n\n\n1*4&#x3D;4\n2*4&#x3D;10\n3*4&#x3D;14\n4*4&#x3D;20\n\n\n\n\n\n1*5&#x3D;5\n2*5&#x3D;12\n3*5&#x3D;17\n4*5&#x3D;24\n5*5&#x3D;31\n\n\n\n\n1*6&#x3D;6\n2*6&#x3D;14\n3*6&#x3D;22\n4*6&#x3D;30\n5*6&#x3D;36\n6*6&#x3D;44\n\n\n\n1*7&#x3D;7\n2*7&#x3D;16\n3*7&#x3D;25\n4*7&#x3D;34\n5*7&#x3D;43\n6*7&#x3D;52\n7*7&#x3D;61\n\n\n八进制四则运算\n\n\n\n\n\n\n\n\n\n思考题\n111-111&#x3D;？\n00+000&#x3D;？\n000-00&#x3D;？\n000-000&#x3D;？\n你看到的不一定是真的1不是1,0不是0，玩意上面那个是自己重新定义过的符号呢\n进制总结\n\n\n\n\n\n\n\n\n每种进制都是完美的，他自身就是一个完美的体系，可以直接做各种运算，运算的方法:查数，查表和十进制没区别\n进制的简写和转换计算机为什么使用二进制:复杂度，效率和材料\n\n\n\n\n\n\n\n\n\n二进制很简单\n最早的计算机，算盘就是以二进制的形式，任何其他进制的运算都是可以用二进制替代的\n计算机是需要用电的，电路特点只有两种状态:1 真(通电) 0 假(断电)，计算机中存储的任何文件，接收的任何指令都是由0和1组成的。有了理论，再加上实际应用的需求，只需要找到合适的材料，电子计算机也就发明出来了\n\n&#x3D;&#x3D;量子计算机肯定不是二进制，因为量子特性可以同时具备很多种状态，计算的效率比只有0和1的二进制高的多&#x3D;&#x3D;\n二进制的简写形式\n\n\n\n\n\n\n\n\n二进制:从0写到1111\n0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111\n这种二进制使用起来太麻烦了，改成简单一点的符号\n0 1 2 3 4 5 6 7 8 9 A B C D E F\n换算成10进制—从0-15一共16个数，最小值为0，最大数15，这是想比较其他进制更容易被人类所接受\n这就是16进制了，中国古代的时候就已经使用十六进制了\n比如:半斤八两，算盘，上面两个珠子，下面五个珠子，最小值0，最大值15，可以进行十进制运算，也可以进行二进制和十六进制运算\n熟练掌握二进制和十六进制之间的转换\n\n\n\n\n\n\n\n\n\n\n\n0000\n0001\n0010\n0011\n0100\n0101\n0110\n0111\n1000\n1001\n1010\n1011\n1100\n1101\n1110\n1111\n\n\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\nA\nB\nC\nD\nE\nF\n\n\n熟练掌握二进制和十进制之间的转换\n\n\n\n\n\n\n\n\n\n\n\n0000\n0001\n0010\n0011\n0100\n0101\n0110\n0111\n1000\n1001\n\n\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n&#x3D;&#x3D;十进制数0-9对应的4位二进制数，称为8421 BCD码&#x3D;&#x3D;\n二进制转十进制\n\n\n\n\n\n\n\n\n查表\n二进制的位权值\n\n\n\n2^n^\n十进制值\n2^n^\n十进制值\n\n\n\n2^0^\n1\n2^8^\n256\n\n\n2^1^\n2\n2^9^\n512\n\n\n2^2^\n4\n2^10^\n1024\n\n\n2^3^\n8\n2^11^\n2048\n\n\n2^4^\n16\n2^12^\n4096\n\n\n2^5^\n32\n2^13^\n8192\n\n\n2^6^\n64\n2^14^\n16384\n\n\n2^7^\n128\n2^15^\n32768\n\n\n十进制转二进制\n\n\n\n\n\n\n\n\n无符号十进制数转二进制算法\n十进制数重复除以2，每次的余数记录下来作为当做二进制数位的值，直到商为0为止，举例:十进制数57转为二进制数\n把余数列数字反向排列就得到了二进制数111001，由于intel存储的二进制数位数总是8或者8的倍数，因此前面空位补0,57的二进制数为00111001\n十六进制转十进制\n\n\n\n\n\n\n\n\n算法:位权表示法把n位无符号数十六进制整数转化为十进制数\n十六进制的位权值\n\n\n\n16^n^\n十进制值\n16^n^\n十进制值\n\n\n\n16^0^\n1\n16^4^\n65536\n\n\n16^1^\n16\n16^5^\n1048576\n\n\n16^2^\n256\n16^6^\n16777216\n\n\n16^3^\n4096\n16^7^\n268435456\n\n\n十进制转十六进制\n\n\n\n\n\n\n\n\n无符号十进制数转十六进制算法:\n十进制数重复除以16，每次的余数记录下来作为当前十六进制数位的值，直到商为0为止\n把余数列数字反向排列就得到了十六进制数，由于Intel存储的二进制数位数总是8或者8的倍数，前面空位补0\n数据的表示方法及宽度数据宽度\n\n\n\n\n\n\n\n\n计算机计数和数学计数的区别\n&#x3D;&#x3D;数字差异:&#x3D;&#x3D; 数学上的数字，是没有大小限制的，可以无限的大。但在计算机中，由于受硬件的制约，数据都是有长度限制的（我们称为数据宽度），超过最多宽度的数据会被丢弃。\n例如：给定的一个数0x123456789ABC,如果规定它的宽度为32位（这里指的32通常是二进制的32位)，那么该数值的有效值为0x56789ABC.如果运算结果超过其宽度将被略去，只保留有效位。\n&#x3D;&#x3D;思维上的差异:&#x3D;&#x3D;数学计算记录在纸上，脑袋里或者其他地方，计算机是存储在存储器中的，比如寄存器，内存，硬盘等。\n我们之前说过16位，32位计算机的定义，制造内存的时候肯定需要一个规格，这个规格就是一次最多可以存取多少位0或1，也可以称为内存的宽度，相应的地址编号的位数，通用寄存器的位数，数据线，控制线和地址线也要与之相匹配\n16位计算机，也就是说他的内存宽度是16个数据位的，32，,64位也是如此\n数据宽度就是内存存储单元的宽度，代表存储单元能存储多少位二进制数\n假设存储单元的数据宽度是4位，他能存储的二进制数范围如下\n0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111\n十六进制表示: 0-F\n十进制表示: 0-2^4^-1\n计算机中常见的数据宽度\n\n存储范围\n\n字节(Byte):00xFF\t8位\t(02^8^-1)\n字(Word):00xFFFF\t16位\t(02^16^-1)\n双字(Doubleword):00xFFFFFFFF\t32位\t(02^32^-1)\n四字: 00xFFFFFFFFFFFFFFFF         64位     (02^64^-1)\n\n&#x3D;&#x3D;如果要存储的数据超过最大宽度，那么多余的数据将被丢弃！称为数据溢出&#x3D;&#x3D;\n数据类型\n\n不同的编程语言有不同的数据类型定义\n不同的编译器定义的数据类型的宽度也不相同\n\n存储范围\n\n\n\n\n\n\n\n\n\n以圆的形式表现数据的存储范围\n\n\n\n\n\n\n\n\n\n如果要存储的数据超过最大宽度，那么多余的数据将被丢弃称为数据溢出\n\n二级标题三级标题四级标题五级标题六级标题","slug":"逆向魔王/汇编/5.虫壳汇编 进制","date":"2022-12-15T10:49:36.000Z","categories_index":"汇编","tags_index":"汇编,逆向","author_index":"虫子"},{"id":"ba8d04c0da1ddacefbc9a4f4c8ab67af","title":"计算机发展史","content":"组原\n\n\n\n\n\n\n\n\n第一节吹牛逼，大概讲解一下计算机行业啥的，告诫后来人该如何走，用b站来督促自己相当于给自己套一个绳子\n先跟校长走开始，后面跟火哥，一天一节也就是1.30h把笔记也写出来\n\n\n\n\n\n\n\n\n\n计算机能干什么？\n计算机是一台机器，可以移动数据，逻辑运算，控制硬件运行\n进制和运算符的本质？\n就是计数，数数，查数\n计算机发展的历史机械计算机之路\n\n\n\n\n\n\n\n\n\n中国刚开始的时候是用16进制的算盘，举几个例子即可\n机械计算机\n\n\n\n\n\n\n\n\n\n1642年，帕斯卡19岁时发明了人类有史以来第一台机械计算机一一帕斯卡加法器。Pascal编程语言的命名就是为了纪念这位杰出的数学家。\n1674年德国的大数学家莱布尼茨在帕斯卡基础上，发明了可以连续重复的计算加减法的步进计算器，就是是现代计算机做乘除法采用的办法，加减乘除四则运算一应俱全。传说是参考了中国的阴阳八卦二进制原理\n1822年英国数学家、发明家Charles Babbage(查尔斯·巴贝奇)发明第一台差分机，它可以处理3个不同的5位数，计算精度达到6位小数。后来巴贝奇又设计了更复杂的分析机，采用的一些计算机思想输入输出、数据存储等延用至今。这种概念机太超前了，它也没有建造成\n\n\n电子计算机\n\n\n\n\n\n\n\n\n\n1906年，美国的德福雷斯特发明了电子管，为计算机的发展莫定了基础。其控制速度要比艾肯的继电器快成千上万倍。\n1924年，IBI一个有划时代意义的公司成立了\n1936年，美国青年霍德华·艾肯发明马克1号计算机在哈佛大学正式运行。继电器接通电路表示“1”，继电器断开则表示“0”。马克1号被称为最后一台“史前”计算机一一机械&#x2F;电动方式。\n1946年2月14日，世界上第二台电子计算机，世界上第一台通用计算机(多个行业都可以使用)埃利阿克(ENIAC，译成中文是”电子数字积分和计算机”)诞生于美国宾夕法尼亚大学，但是在1973年，美国联邦地方法院注销了ENIAC的专利，并得出结论，ENIAC的发明者是贝利·威尔逊（John Presper Eck ert）和约翰·霍夫金斯（John Mauchly）\n1939年，英国数学家图灵图灵机。图灵被称为计算机科学之父，人工智能之父。\n\n\n\n\n\n发展阶段\n逻辑元件\n主存储器\n运算速度(每秒)\n软件\n应用\n\n\n\n第一代(1946-1958)\n电子管\n电子射线管\n几千次到几万次\n机器语言，汇编语言\n军事研究，科学计算\n\n\n第二代(1958-1964)\n晶体管\n磁芯\n几十万次\n监控程序，高级语言\n数据处理，事务处理\n\n\n第三代(1964-1971)\n中小规模集成电路\n半导体\n几十万次到几百万次\n操作系统，汇编系统，应用程序\n有较大发展开始广泛应用\n\n\n第四代(1971-至今)\n大规模超大规模集成电路\n集成度更高的半导体\n上千万次到上亿次\n操作系统完善，数据库系统，高级语言发展，应用程序发展\n渗入社会各级领域\n\n\n\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;人工智能:图灵测试&#x3D;&#x3D;\n如果第三者无法分辨是机器给出的答案还是人给出的答案，就可以认为机器具有智能\n国际象棋:人机对抗 1942年\n1997年5月11日，IBM的国际象棋电脑深蓝在一次正式比赛中打败了世界冠军加里 卡斯帕罗夫，深蓝可以实现每秒两亿步的运算\n思考:计算机为什么采用二进制\n因为电线只有开和关(通和断)\n二级标题三级标题四级标题五级标题六级标题","slug":"逆向魔王/组原/1.虫壳组原 计算机发展史","date":"2022-12-15T10:49:36.000Z","categories_index":"组原","tags_index":"逆向,组原","author_index":"虫子"},{"id":"8b2fb86844f7ace5c779b63ed3f22891","title":"计算机的组成","content":"组原计算机的组成硬件部分\n\n\n\n\n\n\n\n\n\n控制寄存器\t\t控制指令\n数据寄存器\t\t存储数据\n状态寄存器\t\t状态标志\n冯诺依曼结构\n\n\n\n\n\n\n\n\n\n缺点就是中间哪一步出错了就没有办法了\n以存储为中心的计算机结构\n\n\n\n\n\n\n\n\n\n多了一根反馈线，这个反馈线的意思是在我控制器控制外部设备的时候，你要给我一个反馈，假如我要控制输入设备，你这个输入设备也告诉我你是否可以正常工作了\n现代计算机结构\n\n\n\n\n\n\n\n\n\n到32位的时候里面还要加上频率时钟\n\n\n\n\n\n\n\n\n\n数据的查询访问方式\nBIOS中断查询方式\nDOS系统中断 – 中断向量法\nWindows系统调用\n接口卡\n\n\n\n\n\n\n\n\n计算机系统中，所有可用程序控制的设备都必须受到cpu控制，cpu对外设备都不能直接控制，如显示器，音箱，打印机等，直接控制设备工作的是插在扩展槽上的接口卡，扩展插槽通过总线同cpu相连，cpu可以直接控制这些插口卡，从而控制外设。\ncpu通过控制总线向接口卡发送控制命令，接口卡根据cpu的命令控制外设进行工作\n各类存储芯片\n\n\n\n\n\n\n\n\nPC机中装有多个独立的存储芯片，属于不同的部件。从属性可以划分：\n\n随机存储器(RAM):用于存放供CPU使用的绝大部分程序和数据，主随机存储器一般由两个位置上的RAM组成，装在主板上的RAM和插在扩展插槽上的RAM(内存条)。\nOI存储器：存放BIOS基本输入输出程序，是由主板和各类接口卡（如显卡、网卡等）厂商提供的软件系统，可以通过它利用该硬件设备进行最基本的输入输出。例如主板上的ROM中存储系统BIOS,显卡的ROI中存储显卡的IOS,网卡上装有OI存储网卡的BIOS。\n接口卡上的RAM：某些接口卡需要对大批量输入和输出数据进行暂时存储，装有RAM。最典型的是显卡上的RAM,称为显存。我们将要显示的内容写入显存，显卡将显存中的数据向显示器输出，就会出现在屏幕上。\nBI0S:基本输入输出程序、开机自检系统和自启动程序。\nCMOS内存微机主板上的BIOS芯片中一块可读写的RAM芯片，主要用来保存当前系统的硬件配置和操作人员对某些参数的设定。CMOSRAM芯片由系统通过一块后备电池供电，因此在关机状态后信息也不会丢失。\n\n接各类存储芯片\n\n\n\n\n\n\n\n\n\n内存地址空间\n\n\n\n\n\n\n\n\n\n各类存储器都和CPU相连\nCPU对它们进行读或写的时候都通过控制线发出内存读写命令\n\ncpu将各类存储器全部当做内存来对待，把他们总的看作一个由若干存储单元组成的逻辑存储器，这个逻辑存储器称为内存地址空间\n16位8086:20根地址线，2^20^&#x3D;1MB内存空间 \n32位x86:32根地址线，2^32^&#x3D;4GB内存空间\n64位x64:64根地址线，2^64^,但是实际上只用了48位，256TB内存空间\n假如只有两根地址线，我们用二进制0和1表示内存地址编号，00,01,10,11\n&#x3D;&#x3D;每一个地址编号就是一个字节&#x3D;&#x3D;  每个地址编号这根线是地址线\n一个字节8位\n&#x3D;&#x3D;每一个位就是一根线&#x3D;&#x3D;   这根线是数据线\n内存宽度就是一次可以读写多少位\n64位计算机就是一次可以读写64位\n\nCPU将系统中各类存储器看作一个逻辑存储器。\n所有的物理存储器被看作一个由若干存储单元组成的逻辑存储器，每个物理存储器占用一个地址段，即一段地址空间。CPU在这段地址空间读写数据，就是在相对应的物理存储器中读写数据。\n\n假设内存地址空间的地址段分配如下：地址0~7FFFH的32KB空间为主存储空间地址8000H~9FFFH的8KB空间为显存地址A000H~FFFFH的24KB空间为其他ROM存储器地址空间\nCPU向地址1000H内存单元写入数据，数据就被写入主随机存储器中；CPU向地址8000H内存单元写入数据，数据被写入显存，出现在显示器上,CPU向C000H内存单元写入数据，这样的操作无效，因为C000H是ROM只读存储器单元\n在计算机系统里面有两种地址系统\n\n主板上面的插槽，就是定义好的编号，就是端口\t\t指令就是in out\n主存内存地址    指令就是x86其他指令\n\n\n\n内存地址空间的大小受地址总线宽度的限制。8086CPU地址总线为20根，即可以定位2^20^个内存单元，范围02^20^-1，地址空间大小1MB.80386CPU的地址总线宽度为32，则内存地址空间为4GB.基于一个计算机硬件系统编程的时候，必须知道这个计算机系统的内存地址空间的分配情况。向某类存储器读写数据时，需要知道它的第一个单元地址和最后一个单元地址。8086CPU的地址分配如图：&#96;09FFFF的内存单元为主随机存储器 A0000BFFFF的内存单元为显存 C0000FFFFF内存单元为只读存储器&#96;\n\n二级标题三级标题四级标题五级标题六级标题","slug":"逆向魔王/组原/2.虫壳组原 计算机的组成","date":"2022-12-15T10:49:36.000Z","categories_index":"组原","tags_index":"逆向,组原","author_index":"虫子"},{"id":"286b062a4c68912f896e860814387b01","title":"计算机基本概念","content":"组原计算机的基本概念CPU：大脑\n\n\n\n\n\n\n\n\nCPU是计算机的核心部件，它控制整个计算机的运作并进行运算。要想让一个CPU工作，必须向它提供指令和数据。而指令和数据在存储器中，也就是内存。PC机中，内存的作用仅次于CPU。没有内存，CPU就无法工作。磁盘不等于内存，只有当磁盘存储的数据或程序只有被读取到内存中，才可以被CPU执行。\n指令和数据\n\n\n\n\n\n\n\n\n指令和数据是应用上的概念，计算机并不知道哪些是指令，哪些是数据。在内存或者磁盘中，指令和数据没有任何区别。CPU在工作的时候，把有些信息看成是指令，有些信息当作数据，为同样的信息赋予不同的意义。\n举例说明：例如内存中的二进制信息1000100111011000，计算机可以把它看作为89D8H的数据来处理，也可以看作指令mov ax,bx来执行。至于这种二进制编码是数据还是指令代码，具体识别的过程涉及到很多后面的知识，可以提前查阅一下资料。\n&#x3D;&#x3D;计算机是如何判断指令和数据的&#x3D;&#x3D;\n可以从多个角度来理解：编码规则，执行过程，寄存器和指针，其实计算机仅仅只是一台机器，是我们程序员给计算机输入指令，按照指令执行，也就是计算机只认识0和1，至于哪些是数据，哪些是指令，完全由程序员来控制的。\n&#x3D;&#x3D;可以根据不同的编码规则来识别，当做文字，数据，指令，视频，图片等不同的信息来处理&#x3D;&#x3D;\n指令编码:硬编码\n复杂指令编码CSIC:x86指令集\n简单指令编码RSIC:ARM指令集\n数值编码:整形类型，浮点类型，有符号数，无符号数，BCD码\n字符编码:ASCII码，Unicode编码，扫描码\n图片，视频，文本等多种编码格式和规则 \n存储单元\n\n\n\n\n\n\n\n\n存储器被划分成若干个存储单元，每个存储单元从0开始顺序编号，例如一个存储器有128个单元，编号从0-127可以看成很多个有门牌号的房间。\n\n\n&#x3D;&#x3D;存储容量&#x3D;&#x3D;\n一个存储单元可以存储多少信息？电子计算机的最小信息单位是bit,也就是一个二进制位，即一个存储元素可以存放一个0或者是1，8个bit组成一个字节byte,即8个二进制位，一个存储器有128个存储单元，表示可以存储128个字节(byte)。容量为128个字节。\n微机(P机)存储器的容量以字节为单位来计算的。一个字节(byte&#x3D;8位，8个bit)\n一个字(word)&#x3D;2个字节(byte),16位\n一个双字(dword&#x3D;2个字，4个字节，32位)\n一个四字(dd&#x3D;2个双字，4个字，8个字节，64位)对于大容量的存储器一般用一下单位计量容量：1KB&#x3D;1024B(byte字节)\n1MB&#x3D;1024KB\n1GB&#x3D;1024MB\n1TB&#x3D;1024GB数学题：1024B&#x3D;2^16^B,1MB&#x3D;2^20^B,1GB&#x3D;2^30^B,1TB&#x3D;2^40^B盘的容量表示方法一样。\n&#x3D;&#x3D;一个存储单元包含16个存储元素称为16位机器，32个存储元素称为32位机器，64个存储元素称为64位机器&#x3D;&#x3D;\nCPU对存储器的读写\n\n\n\n\n\n\n\n\n需要三个条件\n\n存储单元地址(地址信息)\n器件的选择，读或写的命令(控制信息)\n读或写的数据(数据信息)\n\nCPU要从内存中读数据，首先要知道存储单元的地址，就是要确定从哪个存储单元中读取数据，存储器被划分成很多个存储单元，从零开始顺序编号，这些编号被看作是门牌号，方便查找，进房间找人，存储单元中要有数据，如果家里没人，就会找不到。\n其次，在一台微机中有很多个部件，CU读写数据时，要知道对哪个器件进行操作，进行哪种操作，是从中读数据，还是写入数据。\nCPU是通过什么将地址、数据和控制信息传送到存储芯片的呢？\n信息的传输：总线计算机中专门有连接CPU和其他芯片的导线，通常称为总线，总线是这些导线的集合，用来传送的信息皆为电信号，高低电平。\n&#x3D;&#x3D;cpu内的控制时钟发出脉冲信号:高低电平&#x3D;&#x3D;\n\nCPU对存储器的读写的过程\n\n\n\n\n\n\n\n\n总线逻辑上分为:地址总线，数据总线，控制总线3类\n\n\n 进制0和1\n二进制的简写形式:16进制\n汇编指令:机器码的助记符，INTEL的开发手册为标准\n汇编指令的编码规则就是硬编码\nC语言有个项目就是做一个计算机的模拟器，编写机器指令，完成指定功能，算术运算，浮点数运算，然后我们还要自己发明一个新的高级语言，然后编写一个对应的编译器和解释器\n编译器将高级语言翻译成虚拟机的机器语言\n解释器直接用c语言执行高级语言指令，不需要翻译\n地址总线\n\n\n\n\n\n\n\n\nCPU是通过地址总线来指定存储单元的。因此，地址总线上可以传递多少个不同的信息，CPU就可以对多少个存储单元进行寻址。假设：用0和1来编写门牌号，有2根地址总线，每次寻址2位，相应的门牌号也需要用2位数来编写，可以查找的门牌号是分别为00、01、10、11，一共4个&#x3D;2^2^。电子计算机中，一根导线可以传递的稳定状态只有2种，高电平表示1，低电平表示0。10根导线一次可以传递10位二进制数据。假设有10根地址总线，那么可以查找的门牌号为2^10^&#x3D;1024，地址范围是0~1023N根地址总线，表示总线宽度为N,最多查找2^N^个内存单元。\n具有10根地址线的CPU向内存发出地址信息11(BH)时传送的二进制信息思考：如果传送的是12,13,14，地址总线传送的内容是？答案：CH 0000001100, DH 0000001101.EH 0000001110\n&#x3D;&#x3D;内存地址空间&#x3D;&#x3D;\n假如CPU的地址总线宽度为10，那么2^10^个内存单元，即1024个可以与寻到的内存单元称为该CPU的内存地址空间。\n\n数据总线\n\n\n\n\n\n\n\n\nCPU与内存或其他器件之间的数据传送是通过数据总线来进行的。数据总线的宽度决定了CPU和外界的数据传送速度。8根数据总线一次可以传递8位二进制数数据&#x3D;1个字节。16根数据总线可以一次传递两个字节。N根数据总线，一次可以传递N&#x2F;8个字节。8088CPU的数据总线宽度为8,8086CPU的数据总线宽度为16.举例：将数据89D8H写入内存\n控制总线\n\n\n\n\n\n\n\n\nCPU对外部器件的控制是通过控制总线进行的。有多少根控制总线就意味CPU提供了对外部器件的多少种控制。所以控制总线的宽度决定了CPU对外部器件的控制能力。读命令：由“读信号输出”控制线负责由CPU向外传送读信号，CPU向该控制线输出低电平(0)表示将要读取数据：写命令：由一根称为“写信号输出”的控制线负责传送写信号。\n总结\n\n\n\n\n\n\n\n\n\nCPU离不开内存，内存存储数据提供给CPU使用\n在存储器中的数据和指令没有任何区别，都是二进制信息\n存储单元从0开始编号\n一个存储单元可以存放8bit，即8位二进制数，为一个字节\n1byte&#x3D;8bit 1KB&#x3D;1024B 1MB&#x3D;1024KB 1GB&#x3D;1024MB\nCPU和总线连接，CPU引出3种总线的宽度标志CPU不同方面的性能：地址总线的宽度决定CPU的寻址能力。数据总线的宽度决定CPU与其他器件进行数据传送时的一次传送量。控制总线的宽度决定CPU对系统其他器件的控制能力。\n\n&#x3D;&#x3D;数据在寄存器和内存之间的移动&#x3D;&#x3D;\n计算机对内存的操作有两种\n\n以字节为单位的数据逻辑算术运算\n以数据位为单位的算术逻辑运算\n\n二级标题三级标题四级标题五级标题六级标题","slug":"逆向魔王/组原/3.虫壳组原 计算机的基本概念","date":"2022-12-15T10:49:36.000Z","categories_index":"组原","tags_index":"逆向,组原","author_index":"虫子"},{"id":"ea5c65088673feada9e353a789756fec","title":"计算机软件","content":"组原多层次计算机系统\n\n\n\n\n\n\n\n\n第0层不允许普通用户编写微指令，属于商业秘密。第1层机器语言指令集：是固化在处理器内部，执行移动、加法和乘法等操作，每条机器语言分成几条微指令执行。第2层操作系统：能够理解用户发出的诸如并执行程序、显示目录之类的交互命令。操作系统被翻译为机器码在第1层执行。第3层汇编语言：在操作系统之上，能够实际开发大型软件的翻译层。汇编指令被翻译成机器语言，由操作系统执行。第4层高级语言：诸如C++、C#、JAVA之类的高级语言先翻译成汇编语言，然后再转为机器语言，由操作系统执行。\n其他应用脚本类的应用语言翻译为高级语言然后执行。\n\n汇编语言—c语言(高级汇编)—c++—java\t\t都是c语言家族\t\t编译器执行的\nphp，Python，lua，js等等脚本语言都是通过解释器来执行的\n操作系统，预处理器，编译器，解释器，虚拟机，调试器，浏览器，数据库这些都是计算机的基础软件都是c语言开发的\n处理执行方式和语法规则不同之外，本质都是一样的\nARM芯片或者其他芯片的运行机制比x86更简单，原理相同\n\n\n\n\n\n\n\n\n\n从软件的角度来看：计算机工作的原理就是查表，查数计算机系统会建立各种各样的表格，通过指针，数据，地址，查表，查数的方式实现逻辑地址，线性地址，物理地址寄存器：存放基址，寻址，数据内存：物理地址、数据消息队列指令队列数据结构：数据定义，类型，宽度，数组，结构，记录，队列，链表，模型等，数据之间的关系算法：解决问题的方法\n软件发展历史\n\n\n\n\n\n\n\n\n1800年约瑟夫·玛丽·雅卡尔(Joseph Marie Jacquard),设计出人类历史上首台可设计织布机一一雅卡尔织布机，对将来发展出其他可编程机器起了重要作用。1842年阿达·洛夫莱斯(Ada Lovelace)为计算程序拟定“算法”，写作的第一份“程序设计流程图”，被珍视为“第一位给计算机写程序的人”。1936年图灵给“可计算性”下了一个严格的数学定义，并提出著名的“图灵机”(Turing Machine)的设想。图灵被称为“计算机科学之父”。阿隆佐·邱奇(Alonzo Church)发表可计算函数的第一份精确定义，对算法理论的系统发展做出巨大贡献。\n1957年约翰·巴科斯(John Backus)创建了是全世界第一套高阶语言：FORTRAN。\n\n1959年\n葛丽丝·霍普(Grace Hopper)创造了现代第一个编译器A-0系统，以及商用电脑编程语言“COB0L”,被誉为C0BOL之母。美国海军准将及计算机科学家，世界最早一批的程式设计师之一。她创造了现代第一个编译器A-0系统参与马克2号机开发，“bug”虫子的由来。\n\n1972年\n丹尼斯.里奇(Dennis MacAlistair Ritchie)在贝尔实验室的工作时间感到无聊，所以他决定制作带有花括号的c，并最终取得的巨大的成功，之后，他添加了分段错误和其他开发人员友好功能，以提高生产力。在星期天还有几个小时的时间，他和他在贝尔实验室的朋友肯·汤普森（Ken Thompson）\nC语言之父—-丹尼斯.里奇\n\n1983年\n比雅尼·斯特劳斯特鲁普(Bjarne Stroustrup)发明了C++,写下了它的早期定义并做出了首个实现。\n\n1996年\n詹姆斯·高斯林(James Gosling）发明了Java,这是第一个真正的面向对象的编程语言。\n\n2001年\n安德斯·海尔斯伯格(Anders Hejlsberg)重新发明了ava,并将其称为C#,因为C编程感觉比Java更酷。\n\n2014年\n2010年7月开始，克里斯·拉特纳(Chris Lattner)开始设计Swift。完成基础架构后，带领开发小组陆续完成语法设计、编译器、运行时、框架、IDE和文档等相关工作。这个语言在2014年WWDC大会上公开\n\n二级标题三级标题四级标题五级标题六级标题","slug":"逆向魔王/组原/4.虫壳组原 计算机软件","date":"2022-12-15T10:49:36.000Z","categories_index":"组原","tags_index":"逆向,组原","author_index":"虫子"},{"id":"1d7728b7cef53fff89d869e00a76e04b","title":"Clion","content":"Cliongdb编译生成可执行文件\n\n\n\n\n\n\n\n\n\n反汇编main函数\n\n\n\n\n\n\n\n\n\n带源码的反汇编函数\n\n\n\n\n\n\n\n\n\n带机器码的反汇编函数\n\n\n\n\n\n\n\n\n\n切换成intel指令格式\n\n\n\n\n\n\n\n\nGDB默认汇编格式是AT&amp;T格式，windows用户会感觉很蛋疼，GDB很给力的支持切换成intel指令集。\n切换intel格式的命令:\nset disassembly-flavor intel\n切换成att格式的命令:\nset disassembly-flavor att\n\n32位编译\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;这个地方卡我100年，原先我以为我mingw64下是可以编译32位的，但是没成功，那么就去cmake那边给一个-m32不就可以了吗，结果还是不可以，毕竟认知性错误是致命的，然后疯狂找资料终于看到知乎的一个提问也是类似的问题，垃圾堆CSDN全是夯货聚集，然后我就去下载了mingw32解决了问题&#x3D;&#x3D;\n\n参考文献\n\n\n\n\n\n\n\n\ngdb手册\n\nCMakeLists.txt 语法介绍\n\n\n\n\n\n\n\n\nCMake 是一个跨平台、开源的构建系统。它是一个集软件构建、测试、打包于一身的软件。它使用与平台和编译器独立的配置文件来对软件编译过程进行控制\n指定 cmake 的最小版本\n\n\n\n\n\n\n\n\n\ncmake_minimum_required(VERSION 3.23)\n这行命令是可选的，我们可以不写这句话，但在有些情况下，如果 CMakeLists.txt 文件中使用了一些高版本 cmake 特有的一些命令的时候，就需要加上这样一行，提醒用户升级到该版本之后再执行 cmake\n设置项目名称\n\n\n\n\n\n\n\n\n\nproject(untitled C)\n这个命令不是强制性的，但最好都加上。它会引入两个变量 demo_BINARY_DIR 和 demo_SOURCE_DIR，同时，cmake 自动定义了两个等价的变量 PROJECT_BINARY_DIR 和 PROJECT_SOURCE_DIR。\n生成可执行文件\n\n\n\n\n\n\n\n\n\n在 Linux 下是：\n\ndemo\n\n在 Windows 下是：\n\ndemo.exe\n\n生成动静态库\n\n\n\n\n\n\n\n\n\nadd_library(hh_static STATIC main.c)\n\nadd_library(hh_shared SHARED  main.c)\n二级标题三级标题四级标题五级标题六级标题","slug":"汇编/Clion 一些操作","date":"2020-08-15T10:49:36.000Z","categories_index":"工具","tags_index":"工具,Clion","author_index":"虫子"},{"id":"4215676474cefe23ec3296fceac2ef7f","title":"汇编","content":"汇编DosBox使用\n\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;但是我们每次都要挂载就有点麻烦，所以我们永久的&#x3D;&#x3D;\n\nvim配置\n\n\n\n\n\n\n\n\n\n二进制和汇编语言的关系\n\n\n\n\n\n\n\n\n\n汇编指令存放在什么地方\n\n\n\n\n\n\n\n\n\n内存编号为什么是从0开始的\n\n\n\n\n\n\n\n\ncpu中存放了一部分指令和数据，然后的是放在内存中，绝大多数是放在内存条中，这话你也可以发现内存条是内存的一部分\n指令和数据在内存中是没有任何区别的，只有被读到cpu中，CPU才会去区分这个事情(后面说) \n\n数据线  控制线\n\n\n\n\n\n\n\n\n\n小测 \n\n\n\n\n\n\n\n\n\n加深对内存的认识\n\n\n\n\n\n\n\n\n\n什么是端口\n\n\n\n\n\n\n\n\n\n端口\ninput   out     和端口有关  读取  写入    控制线  读写信息\n \nAX，BX，CX，DX寄存器\n\n\n\n\n\n\n\n\nax,bx,cx,dx寄存器有他们特殊的地方，是其他寄存器没有的\n他们被称为通用寄存器，是用来存放数据的，也叫做数据寄存器\n\n数据与寄存器之间要保证一致性  8位寄存器给8位寄存器   16位寄存器给16位寄存器\n\n地址寄存器\n\n\n\n\n\n\n\n\n\n\n\ncpu区分指令和数据\n\n\n\n\n\n\n\n\n\nIP寄存器和指令的关系\n\n\n\n\n\n\n\n\n\n修改cs，ip寄存器的指令\n\n\n\n\n\n\n\n\n\n\nSS、SP、BP寄存器\n\n\n\n\n\n\n\n\nSS:存放栈的段地址；SP:堆栈寄存器SP(stack pointer)存放栈的偏移地址;\nBP: 基数指针寄存器BP(base pointer)是一个寄存器，它的用途有点特殊，是和堆栈指针SP联合使用的，作为SP校准使用的，只有在寻找堆栈里的数据和使用个别的寻址方式时候才能用到\n比如说，堆栈中压入了很多数据或者地址，你肯定想通过SP来访问这些数据或者地址，但SP是要指向栈顶的，是不能随便乱改的，这时候你就需要使用BP，把SP的值传递给BP，通过BP来寻找堆栈里数据或者地址．一般除了保存数据外,可以作为指针寄存器用于存储器寻址,此时它默认搭配的段寄存器是SS-堆栈段寄存器.BP是16位的,再扩充16位就是EBP,用于32位编程环境的.一般高级语言的参数传递等等,转换为汇编后经常由BP&#x2F;EBP来负责寻址处理.\nSP,BP一般与段寄存器SS 联用，以确定堆栈寄存器中某一单元的地址，SP用以指示栈顶的偏移地址，而BP可 作为堆栈区中的一个基地址，用以确定在堆栈中的操作数地址。\n(下面这个像Win32汇编中的)bp为基址寄存器，一般在函数中用来保存进入函数时的sp的栈顶基址每次子函数调用时，系统在开始时都会保存这个两个指针并在函数结束时恢复sp和bp的值。像下面这样：在函数进入时：push bp   &#x2F;&#x2F; 保存bp指针mov bp,sp &#x2F;&#x2F; 将sp指针传给bp，此时bp指向sp的基地址。         &#x2F;&#x2F; 这个时候，如果该函数有参数，则[bp + 24]则是该子函数的第一个参数，[bp+34]则是该子函数的 第二个参数，以此类推，有多少个参数则[bp+(n-1)*4]。…..…..函数结束时：mov sp,bp  &#x2F;&#x2F; 将原sp指针传回给sppop bp    &#x2F;&#x2F; 恢复原bp的值。ret        &#x2F;&#x2F; 退出子函数\ndebug调试工具\n\n\n\n\n\n\n\n\n\n\n字节型数据\n\n\n\n\n\n\n\n\n\n\n\n栈\n\n\n\n\n\n\n\n\n栈是一段连续的内存单元，也就是一段连续的内存地址\n\n\n\n编译和链接\n\n\n\n\n\n\n\n\n编译  masm  asm –&gt;  obj\n链接  link  obj  –&gt; exe\n  程序跟踪\ndebug + 程序名\n\n内存的访问方式\n\n\n\n\n\n\n\n\n\n用偏移地址寄存器\n\n\nLOOP\n\n\n\n\n\n\n\n\n\n这里的cx  loop就相当于c里面的do  while\ncx&#x3D;1就执行一次  cx&#x3D;0，然后就会越界了 0-1&#x3D;FFFF再次执行65535次\n123*236结果放在AX中\n\n\n\n\n\n\n\n\n\nFFFF:0到FFFF:F字节型数据的和结果放在dx中\n\n\n\n\n\n\n\n\n\n将内存FFFF:0到FFFF:F内存单元中的数据复制到0:200到0:20F中\n\n\n\n\n\n\n\n\n我们都是知道物理地址是段地址*10+偏移地址\n所以0H*10+200H&#x3D;20H*10+0H&#x3D;200H，这样可以保证ip都是从0~F，不需要来回变化\n\n &#x3D;&#x3D;优化&#x3D;&#x3D;\n\n向内存0:200~0:23F依次传送数据0~63(3FH)\n\n\n\n\n\n\n\n\n之能用9条指令\n包括程序返回\nmov ax,4C00H\nint 21H\n\n计算下面8个字型数据的和存在ax寄存器中\n\n\n\n\n\n\n\n\n  1 2 3 4 5 6 7 8   \n\n利用栈将程序中定义的数据逆序存放\n\n\n\n\n\n\n\n\n\n将数据，代码，栈放入不同的段\n\n\n\n\n\n\n\n\n\n更灵活的定位内存地址的方法\n\n\n\n\n\n\n\n\n段(segment)的编译(翻译)规则  内存的分布\n\n字母的大小写转换\n\n\n\n\n\n\n\n\n\n[bx+数字]\n\n\n\n\n\n\n\n\n将a段和b段中的数据依次相加，将结果存到c段中\n\nsi，di实现字符串‘welcome to masm!’拷贝\n\n\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;用栈做&#x3D;&#x3D;\n \n将data段中的每个单词的头一个字母改为大写\n\n\n\n\n\n\n\n\n\n将data段中的每个单词都改为大写\n\n\n\n\n\n\n\n\n\n但是我们寄存器是有限的，万一里面又用到dx寄存器就难受了，我们可以多种方式把他保存起来，上面是保存在寄存器里面，下面可以保存在数据段或栈里面\n保存到数据段里面\n\n\n\n\n\n\n\n\n\n保存到栈段里面\n\n\n\n\n\n\n\n\n\n不通过寄存器确定数据的长度\n\n\n\n\n\n\n\n\n\ndiv除法指令\n\n\n\n\n\n\n\n\n\n除数8位\n\n\n\n\n\n\n\n\n 除数存在寄存器中\n\n除数存在内存中\n\n除数16位\n\n\n\n\n\n\n\n\n除数存在寄存器中\n\n除数存在内存中\n\ndd,dup伪指令\n\n\n\n\n\n\n\n\n\n添加两条指令，使该内存在运行中将s处的一条指令复制到s0处\n\n\n\n\n\n\n\n\n\njmp指令原理\n\n\n\n\n\n\n\n\n\njmp指令跳转范围\n \njcxz条件转移指令     转移目的地址在内存中\n\n\n\n\n\n\n\n\njcxz指令是有条件转移指令，所有的有条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址，对ip修改范围-128~127\n指令格式:jcxz 标号  （如果cx&#x3D;0，转移到标号出执行）\ncx&#x3D;0时   ip&#x3D;ip+8位位移\n8位位移&#x3D;标号出的地址-jcxz指令后的第一个字节的地址\n8位位移的范围-128~127，用补码表示\n8位位移由编译程序在编译时算出\n当cx !&#x3D; 0时，什么也不做(程序向下执行)\n我们从jcxz的功能中可以看出   jcxz标号相当于\nif(cx &#x3D;&#x3D; 0)  jmp short 标号;\n\n&#x3D;&#x3D;这边很秀&#x3D;&#x3D;\n\n在屏幕中间分别显示绿色，绿底红色，白底蓝色的字符串‘welcome to masm’\n\n\n\n\n\n\n\n\n 80*25彩色字符模式显示缓冲区(以下简称为显示缓冲区)的结构\n内存地址空间中，B8000H~BFFFFH共32KB的空间，为80*25彩色字符模式的显示缓冲区，向这个地址空间写入数据，写入的内容将立即出现在显示器上面\n80*25彩色模式下，显示器可以显示25行，每行80个字符，每个字符可以有256种属性\n这样，一个字符在显示缓冲区中就要占用两个字节，分别存放字符的ascii码和属性\n80*25模式下，一屏幕的内容在现实缓冲区中共占4000个字节\n显示缓冲区分为8页，每页4KB(约等于4000B)，显示器可以显示任一页的内容，一般情况下，显示第0页内容\n\n0000 0000  字符属性占用一个字节\n7654 3210  每个位的编号\n第7位闪烁的效果  只有全屏dos下才能看到效果\n第3位高亮效果  \n前景&#x3D;字体颜色\n背景&#x3D;底色\n654和210都是rgb效果\n\n\n\nret和retf指令，call指令\n\n\n\n\n\n\n\n\n\n\n优化显示代码，使其更加规范\n\n\n\n\n\n\n\n\n\n设计一个程序，程序处理的字符串以0结尾，并且显示在屏幕上,显示4行\n\n\n\n\n\n\n\n\n\n优化，将标号的偏移地址存到一段连续的内存中，结构化的存放\n\nmul 乘法指令\n\n\n\n\n\n\n\n\n\n\n编写一个计算数字的3次方的call程序，结果保存到data段中\n\n\n\n\n\n\n\n\n \n&#x3D;&#x3D;强化编程习惯&#x3D;&#x3D;\n\n计算data段中第一组数据的三次方，结果保存在后面一组dd数据中\n\n\n\n\n\n\n\n\n\n显示字符串\n\n\n\n\n\n\n\n\n名称:show_str\n功能:在指定的位置，用指定的颜色，显示一个用0结束的字符串\n参数:dh&#x3D;行号 (取值范围024)，dl&#x3D;列号  (取值范围079)\n​\t\t cl&#x3D;颜色 ， ds:si指向字符串首地址\n返回:无\n**应用举例:**在屏幕的8行3列，用绿色显示data段中的字符串\n\n数值显示问题(数据变成字符串然后显示)\n\n\n\n\n\n\n\n\neg：1234输入 – 计算 – 输出‘1234’\n然后‘1234’再作为输入 – 再计算show_string – 输出到屏幕上\n 名称:dtoc\n功能:将word型数据转变为表示十进制数的字符串，字符串以0结尾\n参数:ax&#x3D;word型数据\n​\t\t ds:si指向字符串首地址\n返回:无\n\n&#x3D;&#x3D;这段代码bug找半天&#x3D;&#x3D;\n解决除法溢出的问题\n\n\n\n\n\n\n\n\n名称:long_div\n功能:进行不会产生溢出的除法运算，被除数为dword型，除数为word型，结果为dword型\n参数:ax &#x3D; dword型数据的低16位\n​\t\t dx &#x3D; dword 型数据的高16位\n​         cx &#x3D; 除数\n返回:dx &#x3D; 结果的高16位，ax &#x3D; 结果的低16位\n​\t\t cx &#x3D; 余数\n应用举例： 计算1000000&#x2F;10(F4240&#x2F;0AH) &#x3D; 186A0H\n这个186A0H显然放在ax里面是放不进去的，这就是除法溢出，那么怎么解决，这里解决公式是\nX&#x2F;N &#x3D; int(H&#x2F;N)*65536+[rem(H&#x2F;N)*65536+L]&#x2F;N\n\n标志位寄存器\n\n\n\n\n\n\n\n\n\nCF标志位\n\n\n\n\n\n\n\n\n\nZF标志位\n\n\n\n\n\n\n\n\n\nPF标志位\n\n\n\n\n\n\n\n\n\nSF标志位\n\n\n\n\n\n\n\n\n\nOF标志位\n\n\n\n\n\n\n\n\n \n和CF标志位比较是CF是无符号运算\nDF标志位\n\n\n\n\n\n\n\n\n\nrep movsb  rep movsw是串传送指令\nADC指令\n\n\n\n\n\n\n\n\n\n一个很好玩的东西，“无限位相加”\n\nsbb指令\n\n\n\n\n\n\n\n\n\ncmp指令\n\n\n\n\n\n\n\n\n\n编写一个程序将字符串小写变大写\n\n\n\n\n\n\n\n\n\npushf 和 popf\n\n\n\n\n\n\n\n\n就是将标记位寄存器里面的内容放到栈中\n中断向量表\n\n\n\n\n\n\n\n\n \n中断过程\n\n\n\n\n\n\n\n\n\n编写0号中断处理程序，使得在除法溢出的发生时，在屏幕中间显示字符串“divide error”\n\n\n\n\n\n\n\n\n  \nint指令\n\n\n\n\n\n\n\n\n\n写一个中断例程0号,整个屏幕显示!\n\n\n\n\n\n\n\n\n\n编写和安装7CH中断程序    中断类型码7CH\n\n\n\n\n\n\n\n\n实现一个数字的平方\n参数 ax&#x3D;3456\n返回值 dx&#x3D;高16位  ax&#x3D;低16位\n\n编写和安装7CH中断程序    中断类型码7CH\n\n\n\n\n\n\n\n\n看这里ss，sp，bp区别\n\n用7CH中断完成jmp near ptr s指令的功能，完成显示一行以0结尾的字符串\n\n\n\n\n\n\n\n\n\nBIOS和DOS所提供的中断例程\n\n\n\n\n\n\n\n\n\n屏幕第 2 3 4 5行显示4句英文\n\n\n\n\n\n\n\n\n思想很不错      表思想   \n\nshl  shr  逻辑移动指令\n\n\n\n\n\n\n\n\nshl 往左移动一位(比特位)\nshr 往右移动一位\n\n移动多次不可以这样shl al,2,你可以把这个二先放到cl，然后再shl al,cl\n端口\n\n\n\n\n\n\n\n\n\n\nCMOS  RAM芯片\n\n\n\n\n\n\n\n\n\n从CMOS中读取时间信息\n\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;这次真的秒不是妙哈哈&#x3D;&#x3D;\n\n\n以年&#x2F;月&#x2F;日  时:分:秒的形式显示当前的日期\n\n\n\n\n\n\n\n\n\n\n外中断\n\n\n\n\n\n\n\n\ncpu内部需要处理的事情发生的时候，将产生中断信息，引发中断过程，这种中断信息来自cpu内部\n还有一种中断信息来自cpu外部，当cpu外部有需要的事情发生的时候，比如说，外设的输入到达，相关芯片将向cpu发出相应的中断信息，cpu在执行完当前指令后，可以检测到发送过来的中断信息，引发中断过程，处理外设的输入\n在pc系统中，外中断源一共有可屏蔽中断，不可屏蔽中断两类\n可屏蔽中断\n\n\n\n\n\n\n\n\n可屏蔽中断是cpu可以不响应的外中断，cpu是否响应可屏蔽中断，要看标志寄存器的IF位的设置，当cpu检测到可屏蔽中断信息时，如果IF&#x3D;1，则cpu在执行完当前指令后响应中断，引发中断过程，如果IF&#x3D;0，则不响应可屏蔽中断\n回忆一下内中断所引发的中断过程\n1.取中断类型码n\n2.标志寄存器入栈，IF&#x3D;0，TF&#x3D;0\n3.cs，ip入栈\n4.ip&#x3D;n*4  cs&#x3D;N*4+2\n可屏蔽中断所引发的中断过程，除在第一步的实现上有所不同，基本上和内中断的中断过程相同，因为可屏蔽中断信息来自cpu外部，中断类型码是通过数据总线送入cpu的，而内中断的中断类型码是在cpu内部产生的\n现在我们可以解释中断过程中将IF设置0的原因了，将IF设置0的原因就是，在进入中断处理程序后，禁止其他的屏蔽中断\n当然，如果在中断处理程序中需要处理可屏蔽中断，可以用指令将IF置1。8086CPU提供的设置IF指令如下\nsti\t\t设置IF&#x3D;1\ncli\t\t设置IF&#x3D;0\n不可屏蔽中断\n\n\n\n\n\n\n\n\n不可屏蔽中断是cpu必须响应的外中断，当cpu检测到不可屏蔽中断信息时，则在执行完当前指令后，立即响应，引发中断过程\n对于8086cpu，不可屏蔽中断的中断类型码固定为2，所以中断过程中，不需要取中断类型码，则不可屏蔽中断过程为\n1.标志寄存器入栈  IF&#x3D;0，TF&#x3D;0\n2.cs,ip入栈\n3.ip&#x3D;8\tcs&#x3D;0AH\n几乎所有由外设引发的外中断，都是可屏蔽中断，当外设有需要处理的事件（比如说键盘输入）发生时，相关芯片向cpu发出可屏蔽中断信息，不可屏蔽中断是在系统中必须处理的紧急情况发生时用来通知cpu的中断信息，比如电源中断就是不可屏蔽中断\n机器键盘的处理过程键盘输入\n\n\n\n\n\n\n\n\n键盘上的每一个键都相当于一个开关，键盘中有一个芯片对键盘上的每一个键的开关状态进行扫描\n按下一个键时，开关接通，该芯片就产生一个扫描码，扫描码说明了按下的键在键盘上的位置，扫描码被送入主板上的相关接口芯片的寄存器中，该寄存器的端口地址为60h\n松开按下的键时，也产生一个扫描码，扫描码说明了松开的键在键盘上的位置，松开按键时产生的扫描码也送入60h端口中\n一般将按下一个键时产生的扫描码称为通码，松开一个键产生的扫描码称为断码。扫描码长度为一个字节，通码的第7位为0，断码的第7位为1，也就是\n断码&#x3D;通码+80h\n比如，g键的通码是22h，断码为a2h\n键盘上部分键扫描码，只列出通码。\n\n\n\n\n\n\n\n\n断码&#x3D;通码+80H\n\n引发9号中断\n\n\n\n\n\n\n\n\n键盘的输入到达60h端口时，相关的芯片就会向cpu发出中断类型码为9的可屏蔽中断信息，cpu检测到该中断信息后，如果IF&#x3D;0，则响应中断，引发中断过程，转去执行int 9中断例程\n执行int 9中断例程\n\n\n\n\n\n\n\n\nBIOS提供了int 9中断例程，用来进行基本的键盘输入处理，主要工作如下\n1.读出60H端口中的扫描码\n2.如果是字符关键字的扫描码，将该扫描码和他所对应的字符码(即ASCII码)，送入内存中的BIOS键盘缓冲区，如果是控制键(比如 Ctrl)和切换键(比如 CapLock)的扫描码，则将其转变为状态字节(用二进制记录控制键和切换键装态的字节)写入内存中存储状态字节的单元\n3.对键盘系统进行相关的控制，比如说向相关芯片发出应答信息\nBIOS键盘缓冲区是系统重启后，BIOS用于存放int 9中断例程所接收的键盘输入的内存区。该内存区可以存储15个键盘输入，因为int 9中断例程除了接收扫描码外，还要产生和扫描码对应的字符码，所以在BIOS键盘缓冲区中，一个键盘输入用一个字单元存放，高位字节存放扫描码，低位字节存放字符码\n0040:17单元存储键盘状态字节，该字节记录了控制键和切换键的状态，键盘状态字节各位记录信息的信息如下\n\n\n\n0\n右shift状态，置1表示按下右shift键\n\n\n\n1\n左shift状态，置1表示按下左shift键\n\n\n2\nCtrl状态，置1表示按下Ctrl键\n\n\n3\nAlt状态，置1表示按下Alt键\n\n\n4\nScrollLock状态，置1表示Scroll指示灯亮\n\n\n5\nNumLock状态，置1表示小键盘输入的是数字\n\n\n6\nCapsLock状态，置1表示输入大写字母\n\n\n7\nInsert状态，置1表示处于删除状态\n\n\n\n\n直接定址表\n\n\n\n\n\n\n\n\n\n二级标题三级标题四级标题五级标题六级标题","slug":"汇编/正逆转则  一念神魔","date":"2020-08-15T10:49:36.000Z","categories_index":"汇编","tags_index":"计组,汇编","author_index":"虫子"},{"id":"54f6e693c269b1946b1efa99b47db6a5","title":"杂","content":"汇编乌班图修改用户名\n\n\n\n\n\n\n\n\n先改用户名再改密码\n\n1.切换到root用户下\n使用 &#x3D;&#x3D;su -&#x3D;&#x3D;命令（有空格，用”su”命令只是切换到root，而没有把root的环境变量传过去，实际是当前用户的环境变量，用”su -“命令会将环境变量传过去，和root登录效果一样），然后修改sudoers文件即可（visudo）\n2.先添加sudoers文件的写权限\n\n\n\n\n\n\n\n\n2.&#x2F;etc&#x2F;sudoers文件默认是只读的，对root来说也是，因此需先添加sudoers文件的写权限,命令是:chmod u+w &#x2F;etc&#x2F;sudoers\n3.编辑sudoers文件\n\n\n\n\n\n\n\n\nvi &#x2F;etc&#x2F;sudoers          添加信任关系找到这行 &#x3D;&#x3D;root ALL&#x3D;(ALL) ALL&#x3D;&#x3D;,在他下面添加xxx ALL&#x3D;(ALL) ALL (这里的xxx是你的用户名)\nps:这里说下你可以sudoers添加下面四行中任意一条youuser      ALL&#x3D;(ALL)        ALL%youuser     ALL&#x3D;(ALL)        ALLyouuser      ALL&#x3D;(ALL)        NOPASSWD: ALL%youuser     ALL&#x3D;(ALL)        NOPASSWD: ALL\n第一行:允许用户youuser执行sudo命令(需要输入密码).第二行:允许用户组youuser里面的用户执行sudo命令(需要输入密码).第三行:允许用户youuser执行sudo命令,并且在执行的时候不输入密码.第四行:允许用户组youuser里面的用户执行sudo命令,并且在执行的时候不输入密码.\n&#x3D;&#x3D;我添加的就是第一条&#x3D;&#x3D;\n\n4.撤销sudoers文件写权限\n\n\n\n\n\n\n\n\nchmod u-w &#x2F;etc&#x2F;sudoers\n\n\n\n\n\n\n\n\n\n\n\n\n启动NetBeans：make netbeans\n启动hsdb：make hsdb\n启动idea：make idea\n启动clion：make clion\n乌班图永久修改主机名先看主机名hostname\n\n\n\n\n\n\n\n\n\n修改 &#x2F;etc&#x2F;hostname\n\n\n\n\n\n\n\n\nUbuntu 主机名存放在 /etc/hostname 文件中，修改主机名时，只需要编辑 hostname文件，在文件中输入新的主机名并保存该文件\n\n修改 &#x2F;etc&#x2F;hosts\n\n\n\n\n\n\n\n\n/etc/hosts 存放的是域名与 ip 的对应关系，虽然这一步不是必须选项，但建议在修改主机名之后同步修改该文件。\n\n 重启系统\n\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;重启后&#x3D;&#x3D;\n\n真机和虚拟机中的Ubuntu来回复制\n\n\n\n\n\n\n\n\n\nsudo apt-get install open-vm-tools-desktop -y\nubuntu18.04窗口关闭按钮设置左右位置的方法 安装gnome桌面环境配置工具\n\n\n\n\n\n\n\n\nsudo apt-get install gnome-tweaks\n\n 安装完成后alt+f2在运行窗口输入 gnome-tweaks 回车执行\n\n\n\n\n\n\n\n\n\n 接着会弹出一个优化窗口界面\n\n\n\n\n\n\n\n\n\n\n汇编风格\n\n\n\n\n\n\n\n\n\n汇编能做什么\n\n\n\n\n\n\n\n\n正向：\n\n有利于理解c语言本质\n研究内核\n\n逆向:\n\n病毒反病毒\n外挂与反外挂\n破解与反破解\n\n&#x3D;&#x3D;wps就是逆向领域的一个大作：刚开始国内的时候是没有什么office的什么，有也是收费的。然后wps创始人求伯君就逆向分析word和execl然后把他还原成c代码。也就是他先研究他的汇编代码，搞清楚他的运作逻辑，然后基于自己的理解把他用c语言写出来了。wps最早期的版本就是这样出来的&#x3D;&#x3D;\nBochs下载安装  （参考操作系统真相还原这本书）\n\n\n\n\n\n\n\n\n官方地址是http://sourceforge.net/projects/bochs/files/bochs\n\n然后我们进入bochs2.7里面进行配置\n配置信息\n./configure --prefix=/your_path/bochs --enable-debugger --enable-disasm --enable-iodebug --enable-x86-debugger --with-x --with-x11\n--prefix=/your_path/bochs  #是用来指定bochs的安装目录，根据个人的实际情况将your_path替换为自己待安装的路径\n--enable-debugger          #打开bochs自己的调试器\n--enable-disasm            #使用bochs支持反汇编\n--enable-iodebug           #启用io接口调试器\n--enable-x86-debugger\t   #支持x86调试器\n--with-x                   #使用x windows\n--with-x11                 #使用x11图形用户接口\n\n\n\n\n\n\n\n\n\n\n\ncpu架构   指令架构\n\n\n\n\n\n\n\n\nCISC   复杂指令集    电脑\n\n32位电脑   intel x86\n64位电脑   amd x64\n\nRISC   精简指令集    手机，嵌入式设备\n\narm公司垄断\n\n\nMASM，NASM，AT&amp;T关系\n\n\n\n\n\n\n\n\nnasm是masm的进化版\nAT&amp;T和linux汇编语法格式\n\n\n\n\n\n\n\n\n在 AT&amp;T 汇编格式中，寄存器名要加上 ‘%’ 作为前缀；而在 Intel 汇编格式中，寄存器名不需要加前缀\n\n\n\nAT&amp;T格式\nInter格式\n\n\n\npush %eax\npush eax\n\n\n\n\n\n\n\n\n\n\n\n在 AT&amp;T 汇编格式中，用 ‘$’ 前缀表示一个立即操作数；而在 Intel 汇编格式中，立即数的表示不用带任何前缀\n\n\n\nAT&amp;T格式\nInter格式\n\n\n\npush $1\npush 1\n\n\n\n\n\n\n\n\n\n\n\nAT&amp;T 和 Intel 格式中的源操作数和目标操作数的位置正好相反。在 Intel 汇编格式中，目标操作数在源操作数的左边；而在 AT&amp;T 汇编格式中，目标操作数在源操作数的右边\n\n\n\nAT&amp;T格式\nInter格式\n\n\n\naddl $1, %eax\nadd eax,1\n\n\n\n\n\n\n\n\n\n\n\n在 AT&amp;T 汇编格式中，操作数的字长由操作符的最后一个字母决定，后缀’b’、’w’、’l’分别表示操作数为字节（byte，8 比特）、字（word，16 比特）和长字（long，32比特）；而在 Intel 汇编格式中，操作数的字长是用 “byte ptr” 和 “word ptr” 等前缀来表示的\n\n\n\nAT&amp;T 格式\nIntel 格式\n\n\n\nmovb val, %al\nmov al, byte ptr val\n\n\n\n\n\n\n\n\n\n\n\n\n在 AT&amp;T 汇编格式中，绝对转移和调用指令（jump&#x2F;call）的操作数前要加上’*‘作为前缀，而在 Intel 格式中则不需要。\n远程转移指令和远程子调用指令的操作码，在 AT&amp;T 汇编格式中为 “ljump” 和 “lcall”，而在 Intel 汇编格式中则为 “jmp far” 和 “call far”\n\n\n\n\nAT&amp;T 格式\nIntel 格式\n\n\n\nljump $section, $offset\njmp far section:offset\n\n\nlcall $section, $offset\ncall far section:offset\n\n\n\n\n\n\n\n\n\n\n\n与之相应的远程返回指令则为\n\n\n\nAT&amp;T 格式\nIntel 格式\n\n\n\nlret $stack_adjust\nret far stack_adjust\n\n\n\n\n\n\n\n\n\n\n\n与之相应的远程返回指令则为\n\n\n\nsection:disp(base, index, scale)\n\n\n\n\n\n\n\n\n\n\n\n\n而在 Intel 汇编格式中，内存操作数的寻址方式为：\n\n\n\nsection:[base + index*scale + disp]\n\n\n\n\n\n\n\n\n\n\n\n\n参考这篇https://blog.csdn.net/dante_tang/article/details/7599512\n++i    i++底层\n\n\n\n\n\n\n\n\n ++i\nxos eax,eax  ;异或清零\nmov eax,1\ninc eax      ;先自增一下            这里已经起到加加效果\nmov ebx,eax  ;自增后再给其他人用\n\n\n\n\n\n\n\n\n\n\ni++\nxos eax,eax  ;异或清零\nmov eax,1\nmov ebx,eax  ;先给其他人用\ninc eax      ;用完后再自增            这里才起到加加效果\n\n\n\n\n\n\n\n\n\n\n这就是为什么说前置++会比后置++快，因为指令少一行，但是现代计算机基本不考虑这个影响\n执行流\n\n\n\n\n\n\n\n\n对执行流的理解程度\n1.能画出堆栈图\n2.任何的c语言代码，可以用汇编实现\n函数的结构\n\n\n\n\n\n\n\n\n通用的，不一定非要如此\n1.创建栈帧(这个函数执行需要栈空间)\n2.保存现场\n3.代码逻辑\n4.恢复现场\n5.恢复栈帧\n实模式内存布局\n\n\n起始地址\n结束地址\n大小\n用途\n\n\n\n0x000\n0x3ff\n1kb\n中断向量表\n\n\n0x400\n0x4ff\n256b\nBIOS数据区\n\n\n0x500\n0x7bff\n29.75kb\n可用区域\n\n\n0x7c00\n0x7dff\n512b\nMBR加载区域\n\n\n0x7e00\n0x9fbff\n607.6kb\n可用区域\n\n\n0x9fc00\n0x9ffff\n1kb\n扩展BIOS数据区\n\n\n0xa0000\n0xaffff\n64kb\n用于彩色显示适配器\n\n\n0xb0000\n0xb7fff\n32kb\n用于黑白显示适配器\n\n\n0xb8000\n0xb8fff\n32kb\n用于文本显示适配器\n\n\n0xc0000\n0xc7fff\n32kb\n显示适配器BIOS\n\n\n0xc8000\n0xeffff\n160kb\n映射内存\n\n\n0xf0000\n0xfffef\n64kb-16b\n系统BIOS\n\n\n0xffff0\n0xfffff\n16b\n系统BIOS入口地址\n\n\n函数的调用约定\n\n\n\n\n\n\n\n\n\nC语言中写汇编lea指令\n我之前好像没有写lea指令，那么就在这里补充吧\n对寄存器来说\n\n\n\n\n\n\n\n\n第二个操作数是寄存器必须要加[],不然报错,这里lea就是取[寄存器]的值\n\n\nmov eax,2\nlea ebx,[eax];执行后ebx=2\nmov ebx,eax;等同于上句\nlea ebx,eax;编译器报错: error A2070: invalid instruction operands无效的指令操作数\n\n对于内存来说\n\n\n\n\n\n\n\n\n都是取内存的地址,相当于指针\n\nmov dword ptr ds:[00dffc0c],2\nlea eax,dword ptr ds:[00dffc0c] \n;这个内存里面的值是2，但是我们是把内存地址给eax的\n\n详解\n\n\n\n\n\n\n\n\n假如我在栈上定义了&#x3D;&#x3D;一个局部变量&#x3D;&#x3D;，实际上的指令大概率是\npush ebp\nmov ebp,esp\nsub esp,4\n\n现在栈上就有了4个字节的空间，这就是局部变量空间，里面给个值\nmov dword ptr[ebp-4],10;赋值10\n\n于是这个局部变量地址就是ebp-4，显然这个不是一个固定的地址，现在需要将他的地址作为参数传给某个函数，我们可以写\nlea eax,[ebp-4]\npush eax\ncall SomeFunc;局部变量地址作为参数传给函数\n\n当然也可以写成\nmov eax,ebp\nsub eax,4\npush eax\ncall SomeFunc\n\n第二种写法明显比第一种多，这就是lea的好处，也可以发现lea可以做简单的算术计算，特别是有了32位指令的增强寻址方式，更是如虎添翼\n假如我要计算eax*4+ebx+3\n第一种\nmov eax,1\nmov edx,eax\nshl edx,2\nadd edx,ebx\nadd edx,3\n\n第二种\nlea edx,[ebx+eax*4+3] &#x2F;&#x2F; 相当于 lea edx, [eax*4+ebx+3]，这里完全与内存地址无关\n\n是不是明显第二种方便\n内联汇编\n\n\n\n\n\n\n\n\n首先什么是内联汇编，内联汇编是指在c&#x2F;c++代码中嵌入的汇编代码，与全部汇编的汇编源文件不同，他们被嵌入到c&#x2F;c++的大环境中，内联汇编方式两个作用\n\n是程序某些关键代码直接用汇编语言编写，可提高代码的执行效率\n有些操作无法通过高级语言实现，或者实现起来很困难，必须借助汇编语言达到目的\n\nx86内联汇编\n\n\n\n\n\n\n\n\n使用内联汇编要用到 __asm关键字，他可以出现在任何允许c&#x2F;c++语句出现的地方。\t对__asm关键字有两种使用方式\n//1.__asm后面跟代码块\n__asm&#123;\n    //汇编代码\n&#125;\n//2.__asm 后面可以单跟汇编指令\n__asm //汇编指令\n-__asm //汇编指令\n\n\n\n\n\n\n\n\n\n\n显然，第一种方法与 C&#x2F;C++ 的风格很一致，并且把汇编代码和 C&#x2F;C++ 代码清楚地分开，还避免了重复输入 __asm 关键字，因此推荐使用第一种方法。\n不像在 C&#x2F;C++ 中的“{ }”，__asm 块的“{ }”不会影响 C&#x2F;C++ 变量的作用范围。同时，__asm 块可以嵌套，而且嵌套也不会影响变量的作用范围。\n为了与低版本的 Visual C++ 兼容，_asm 和 __asm 具有相同的意义。另外，Visual C++ 支持标准 C++ 的 asm 关键字，但是它不会生成任何指令，它的作用仅限于使编译器不会出现编译错误。要使用内联汇编，必须使用 __asm 而不是 asm 关键字。\n\n#include &lt;stdio.h&gt;\n#include &lt;Windows.h&gt;\n#include &lt;tchar.h&gt; \nvoid MyFunc(char* str)\n&#123;\n\tprintf(&quot;%s\\n&quot;, str);\n&#125;\nint _tmain(int argc, _TCHAR* argv[])\n&#123;\n    char str1[] &#x3D; &quot;__asm&#123; &#125;&quot;;\n    char str2[] &#x3D; &quot;__asm&quot;;\n    &#x2F;&#x2F; 32位程序内联汇编 第一种方式\n    __asm\n    &#123;\n        lea       eax, str1\n        push      eax\n        mov       eax, MyFunc\n        call      eax\n    &#125;\n    &#x2F;&#x2F; 32位程序内联汇编 第二种方式\n    __asm lea     eax, str2\n    __asm push    eax\n    __asm mov     eax, MyFunc\n    __asm call    eax\n    &#x2F;&#x2F;让程序暂停一下，然后按任意键继续\n    system(&quot;pause&quot;);\n\treturn 0;\n&#125;\n\nx64 内联汇编\n\n\n\n\n\n\n\n\n在 64 位程序中，已经不能使用关键字 __asm 来添加汇编代码，而应把汇编代码全部写在 .asm 文件中，然后，再将 .asm 包含到项目中编译链接。现在，我们就先来讲解如何使用 VS2019 添加并编译 .asm 文件的步骤\n首先，我们在本地上新建一个 .asm 格式的文件 “myasm.asm”之后，右击项目工程并选择“添加” —&gt; “现有项”，然后选择我们新创建的“myasm.asm”文件，添加到工程中：\n\n在“myasm.asm属性页”中，设置 从生成中排除 为“否”，设置 项类型 为“自定义生成工具”，然后，点击“应用”。这时，在窗口左侧就会生成“自定义生成工具”的扩展栏。如果是从 x64 模式下设置的，在一步，会没有反应或者卡死。所以，一定要从 Win32 模式开始，再创建 x64 模式，并把 Win32 的设置复制到 x64 模式中，便可以解决这个问题。\n\n接着，我们开始新建 x64 模式，因为我们要开发的是 64 位程序。我们选中项目工程，以此选择 “属性” —&gt; “配置属性” —&gt; “配置管理器” —&gt; “活动解决方案平台”选择“新建”。这时，就会来到“新建解决方案平台”页面。我们选择“x64”，并从 Win32 中复制设置，创建新的项目平台，点击“确定”。这时，就可以使用 x64 模式编译 64 位程序了。\n\n然后，我们继续对 .asm 文件进行设置，将其包含到项目工程中来编译链接。选中“myasm.asm”文件，右击选择“属性”，来到“myasm.asm”属性页进行设置。在 命令行 中输入“ml64 &#x2F;c %(fileName).asm”，在 输出 中输入“%(fileName).obj”，其它保持默认即可，点击“确定”即可完成设置。\n\n经过上述几个步骤，我们成功为 x64 程序添加 .asm 文件并设置包含到项目工程中编译链接。接下来，我们就开始讲解如何在 .asm 文件中写汇编代码了。\n\n\n\n\n\n\n\n\n\n对于 64 位程序在 .asm 中写代码，需要遵循以下几个规则：会变文件 .asm 文件必须以关键字 .CODE 开始，关键字 END 结束，大小写都可以\n.code\n    ; 此处写汇编指令代码\nend\n\n所有的汇编代码以函数方式组织在一起。也就是说，我们要将汇编代码封装成一个个汇编函数。要注意 64 位汇编中的函数声明以及调用约定：\n.code\n; _MyAdd是汇编函数\n_MyAdd    proc\n    ; 此处写汇编函数的代码\n_MyAdd    endp\nend\n\n其中， _MyAdd 是汇编函数的名称，proc 是汇编函数的关键字，endp 是汇编函数的结尾关键字。\n要注意和 32 位汇编函数的区别：32 位汇编函数调用约定 __stdcall，所有参数从右到左依次入栈，通过压栈传递参数。64 位汇编函数的调用约定 __fastcall，前 4 个参数是从左至右依次存放于RCX、RDX、R8、R9寄存器里面，剩下的参数从左至右顺序入栈。\n\n\ngcc内联汇编\n\n\n\n\n\n\n\n\nlinux的GUN C 编译器，使用的是AT&amp;T汇编语法\n\n源 - 目标AT&amp;T语法中操作数的方向与intel相反。在 Intel 语法中，第一个操作数是目标，第二个操作数是源，而在 AT&amp;T 语法中，第一个操作数是源，第二个操作数是目标。Interl: Op-code dst srcAT&amp;T: Op-code src ds\n寄存器命名在寄存器名字前加%，例如eax写作%eax。\n立即操作数AT&amp;T立即操作数以”$”开头。对于静态”C”便来也要在前缀加上”$”。对于十六进制，首先看到一个”$”，然后使”0x”，之后是常量。”$0x1”。\n操作数大小在 AT&amp;T 语法中，内存操作数的大小由操作指令名称的最后一个字符确定。“b”、“w”和“l”的操作指令后缀指定字节（8 位）、字（16 位）和长（32 位）内存引用。\n内存操作数在 Intel 语法中，基址寄存器包含在 ‘[‘ 和 ‘]’ 中，而在 AT&amp;T 中它们更改为 ‘(‘ 和 ‘)’。此外，在 Intel 语法中，间接内存引用类似于section:[base + index*scale + disp]，变为section:disp(base, index, scale) 在 AT&amp;T 中。\n\n\n\n\nlnter Code\nAT&amp;T Code\n\n\n\nmov eax,1\nmovl   $1,%eax\n\n\nmov ebx,0ffh\nmovl   $0xff,%ebx\n\n\nint   80h\nint   $0x80\n\n\nmov   ebx, eax\nmovl   %eax, %ebx\n\n\nmov   eax,[ecx]\nmovl   (%ecx),%eax\n\n\nmov   eax,[ebx+3]\nmovl   3(%ebx),%eax\n\n\nmov   eax,[ebx+20h]\nmovl   0x20(%ebx),%eax\n\n\nadd   eax,[ebx+ecx*2h]\naddl   (%ebx,%ecx,0x2),%eax\n\n\nlea   eax,[ebx+ecx]\nleal   (%ebx,%ecx),%eax\n\n\nsub   eax,[ebx+ecx*4h-20h]\nsubl   -0x20(%ebx,%ecx,0x4),%eax\n\n\n基本汇编\n\n\n\n\n\n\n\n\n基本内联汇编的格式非常简单。它的基本形式是\nasm(&quot;assembly code&quot;);\n__asm__(&quot;movb %bh (%eax)&quot;); \n上面用到asm和__asm__，两个都是有效的。当关键字asm在程序中有冲突的时候，可以使用__asm__。如果有多个指令，每行写一个双引号，并在指令后添加”\\n\\t”。这是因为gcc将每条指令作为字符串发送给as(GAS)，通过换行符&#x2F;制表符区分来发送正确格式化字符给汇编器。\n__asm__ (&quot;movl %eax, %ebx\\n\\t&quot;\n         &quot;movl $56, %esi\\n\\t&quot;\n         &quot;movl %ecx, $label(%edx,%ebx,$4)\\n\\t&quot;\n         &quot;movb %ah, (%ebx)&quot;);\n\n\n\n\n\n\n\n\n\n\n如果我们的代码里使用了寄存器, 并且在返回的时候没有还原它, 这将有坏的情况发生. 因为GCC并不知道寄存器的值改变了, 特别是编译器对代码进行优化的时候. 编译器会认为,那些存放变量的寄存器,我们并没有改变它,然后继续自己的优化. 为了避免这种情况, 要么, 我们不改变寄存器的值, 要么, 汇编函数返回之前, 还原寄存器使用前的值, 或者 等着代码崩溃(wait for something to crash). 正是由于存在这样的问题,我们需要使用”Extended Asm”. 它将提供给我们扩展功能, 解决上边的问题\n扩展汇编\n\n\n\n\n\n\n\n\n在基本嵌入汇编格式中,我们只使用了指令. 在扩展汇编中, 我们还可以指定更多操作. 它允许我们指定输入寄存器, 输出寄存器和变化表(clobber list). 我们并不一定要指定使用哪些寄存器. 我们可以把这件头痛的事情交给GCC去做. 扩展汇编的格式如下:\n\nasm ( assembler template \n      : output operands                  &#x2F;* optional *&#x2F;\n      : input operands                   &#x2F;* optional *&#x2F;\n      : list of clobbered registers      &#x2F;* optional *&#x2F;\n    );\n\n\n\n\n\n\n\n\n\n\n这个模板由若干条汇编指令组成, 每个操作数（括号里C语言的变量）都有一个限制符（“”中的内容）加以描述. 冒号用来分割输入的操作和输出的操作. 如果每组内有多个操作数,用逗号分割它们. 操作数最多为10个, 或者依照具体机器而异\n如果没有输出操作, 但是又有输入, 你必须使用连续两个冒号, 两个连续冒号中无内容, 表示没有输出结果的数据操作 \t\nasm (&quot;cld\\n\\t&quot;\n    &quot;rep\\n\\t&quot;\n    &quot;stosl&quot;\n    : &#x2F;* no output registers *&#x2F;\n    : &quot;c&quot; (count), &quot;a&quot; (fill_value), &quot;D&quot; (dest)\n    : &quot;%ecx&quot;, &quot;%edi&quot; \n    );\n\n\n\n\n\n\n\n\n\n\n上面这段代码做了什么? 这段内嵌汇编把 fill_value, count装入寄存器,同时告知GCC,clobber list目录中的寄存器eax,edi,已经改变.\nint a&#x3D;10, b;\nasm (&quot;movl %1, %%eax; \n    movl %%eax, %0;&quot;\n    :&quot;&#x3D;r&quot;(b)        &#x2F;* output *&#x2F;\n    :&quot;r&quot;(a)         &#x2F;* input *&#x2F;\n    :&quot;%eax&quot;         &#x2F;* clobbered register *&#x2F;\n    ); \n\n\n\n\n\n\n\n\n\n\n代码目的是让’b’的值与’a’的值相等.\n\n‘b’是要输出的数据，%0也指它。 ‘a’是输入的数据，%1也指它。\n‘r’ 是对操作数的约束。呆会在详细了解。 暂时这样理解，‘r’告诉GCC选择一个可用的寄存器来保存这个操作数。 输出操作数，应该使用‘&#x3D;’， 表示这个数据只写。\n双%%前缀，指明这是一个寄存器名。 单%指明操作数。 这帮组GCC辨别 操作数和寄存器。\n第三个冒号后边， 这个变化表(clobber list)里的寄存器%eax，告诉gcc声明的寄存器值已经改变，这样，GCC不会在其他地方使用这个寄存器了。\n\n当这段汇编代码执行完毕，’b’变量将会存储这个结果,，正如例子里声明这个变量为输出。 换句话说， ‘b’用来反映汇编程序里值的变化\n汇编模板\n\n\n\n\n\n\n\n\n 这个汇编模板包含一套完整的汇编指令，帮助在c语言内嵌入汇编语言。具体格式如下：每条指令应该加上双括号，或者给整套汇编指令加上双括号（如，最后一个例子）。每条指令结尾都应加上结束符，合法的结束符有（\\n）和（；），或许还应该在 \\n后边加上一个 \\t，我们应该了解原因吧？ 括号里的若干操作数，依次对应%0，%1…等。\n操作数\n\n\n\n\n\n\n\n\nc表达式作为asm中汇编指令的操作数，每个操作数首先加上双引号。对于输出操作数，首先会有一个限制符，然后跟上C变量，运算结果将存入这个变量。\n双引号内的“限制符”是一个规定的格式。在输出操作中，这个限制符会额外多一个符号（&#x3D;）。限制符主要用来决定操作数的寻址方式。同时还可指定使用某一个寄存器。\n如果我们使用多个操作数，它们之间用逗号分隔。\n在汇编器模板中，每个操作数都由数字与之对应。编号如下进行。如果总共有 n 个操作数（包括输入和输出），则第一个输出操作数编号为 0，按递增顺序继续，最后一个输入操作数编号为 n-1。操作数的最大数量与我们在上一节中看到的一样。\n输出操作数表达式必须是左值。输入操作数不受这样的限制。它们可能是表达式。扩展汇编常常用于实现机器平台自身特殊的指令，编译器可能并不能识别他们：-）。如果输出表达式不能直接寻址（例如，它是一个位字段），我们的约束必须允许一个寄存器。在这种情况下，GCC 将使用寄存器作为 asm 的输出，然后将该寄存器内容存储到输出中。\n我们现在分析几个例子。我们想给一个数乘以5。因此，我们使用lea指令： （汇编语句leal（r1，r2，4），r3语句表示r1+r2*4→r3。这个例子可以非常快地将x乘5。）\nasm (&quot;leal (%1,%1,4), %0&quot;\n     : &quot;&#x3D;r&quot; (five_times_x)\n     : &quot;r&quot; (x) \n     );\n\n\n\n\n\n\n\n\n\n\n这里，输入一个变量x，我们并没指定特定的寄存器来存储它，GCC会选择一个（“r”表示gcc选择）。如我们所要求的，gcc会自动选择两个寄存器，一个给input，一个给output。如果我们想给input和output指定同一个寄存器，我们可以要求GCC这样做（通过更改“限制符”内容）。\nasm (&quot;leal (%0,%0,4), %0&quot;\n    : &quot;&#x3D;r&quot; (five_times_x)\n    : &quot;0&quot; (x) \n    );\n\n\n\n\n\n\n\n\n\n\n上例，我们就让input和output使用同一个寄存器，但是不知道具体哪一个。（如果输入操作的限制符为0或为空，则说明使用与相应输出一样的寄存器。）如果，我们想指定使用具体一个寄存器，可以看看如下代码：“c”表示使用寄存器ecx。\nasm (&quot;leal (%%ecx,%%ecx,4), %%ecx&quot;\n    : &quot;&#x3D;c&quot; (x)\n    : &quot;c&quot; (x) \n    );\n\n\n\n\n\n\n\n\n\n\n上面三个例子，我们没有把任何寄存器放入clobber list，为什么？前两个例子，由GCC选择寄存器，所以它知道那些寄存器值改变了。最后一个例子，我们没有把ecx寄存器放入clobber list，GCC知道它的值变成x了。因此，既然GCC知道ecx寄存器的值，就没必要加入到clobber list\nclobber list\n\n\n\n\n\n\n\n\n一些指令改变了硬件寄存器的值。这是需要在clobber list中列举出这些寄存器，位置在asm函数中第三个’:’后。这是为了告知GCC，我们将使用和更改列举出的寄存器。那么，GCC就知道之前装载到寄存器里的值已经无效了，不会使用寄存器的旧值进行错误操作。我们不必把input，output所使用的寄存器列入clobber list，因为GCC知道汇编代码已经使用和改变了那些寄存器\n如果汇编代码将改变条件码寄存器，我们需要在clobber list中加入“cc”\n如果我们的指令以一种不可预知的方式修改了内存，需在clobber list中加入“memory”。这将使GCC在整个汇编指令的寄存器中不保留缓存值。如果受影响的内存没有列在asm的输入或输出中，我们还必须添加volatile关键字。\nclobber list中的寄存器可以反复读写。参考下面这个例子，代码子程序__foo用eax，ecx寄存器传递参数。则这俩寄存器的值不再可靠，所以加入到clobber list中。\nasm (&quot;movl %0,%%eax;\nmovl %1,%%ecx;\ncall _foo&quot;\n: &#x2F;* no outputs *&#x2F;\n: &quot;g&quot; (from), &quot;g&quot; (to)\n: &quot;eax&quot;, &quot;ecx&quot;\n);\n&#x2F;&#x2F; from和to是任意寄存器\n\nVolatile\n\n\n\n\n\n\n\n\n如果你熟悉内核代码或者像她一样漂亮的代码，你一定见到过许多函数被volatile或__volatile__修饰，通常紧跟在 asm或__asm__后边。我先前提到过asm和__asm__的区别。那volatile呢？\n如果你不希望自己编写的汇编代码被gcc优化或移动，你需要使用到volatile这个keyword，将其放在asm和（）之间即可。\n对volatile关键字的使用应非常谨慎。\n如果我汇编代码仅仅做一些简单计算并且没有什么副作用，那么最好不用volatile。不使用它，可以帮助GCC优化代码，让代码更“漂亮”。\n更多限制\n\n\n\n\n\n\n\n\n看到这里，你应该知道汇编里的限制符（constraint）做了很多的事。但，我们只花了很少的篇幅叙述限制符。比如，限制符可以指定一个寄存器，限制符可以指向一块内存空间，限制符可以是一个立即数…等。\n常用限制\n\n\n\n\n\n\n\n\n有大量的限制符，我们常用使用其中很少一部份，现在来看看\n\n寄存器操作数限制(r)当操作指定了“r”限制符，那么操作数将会被存储在通用寄存器内。看下例：asm (“movl %%eax, %0\\n” :”&#x3D;r”(myval));这里的变量myval被存储在一个寄存器内，代码将eax寄存器的值拷贝到myval占用的寄存器内，然后myval寄存器的值将更新myval的内存值。当“r”限制符被指定，GCC可能分配任意一个通用寄存器来存储操作数。如果要确切使用某个寄存器，你应该指定这个寄存器名称，通过下表的格式：\n\n\n\n\nr\nRegister(s)\n\n\n\na\n%eax, %ax, %al\n\n\nb\n%ebx, %bx, %bl\n\n\nc\n%ecx, %cx, %cl\n\n\nd\n%edx, %dx, %dl\n\n\ns\n%esi, %si\n\n\nD\n%edi, %di\n\n\n\n\n\n内存操作数限制(m)如果限制符“m”后的操作数在内存中，任何对它们的操作都会直接更改内存值。与“r”限制符不同，“r”首先将操作数保存在寄存器内，然后在寄存器里进行数据操作，接着把数据写回内存区域。使用“r”限制符，通常是由于某些指令必须使用，或者为了加快程序运行，所以占用寄存器。“m”限制符运用更频繁，当我们希望在汇编执行过程中就更新内存，或者不希望额外占用一个宝贵的寄存器来装载变量值，就使用“m”限制符。如下：idtr的值就被保存在loc那块内存。\n\nasm(&quot;sidt %0\\n&quot;, : :&quot;m&quot;(loc));\n\n\nMatching(Digit) constraints在某些情况下，单个变量可以同时作为输入操作数和输出操作数。这种情况可以通过使用匹配约束在”asm中。asm(“incl %0” : “&#x3D;a”(var)”:”0”(var));上边见到过类似的例子，此例“0”使用了匹配限制符，寄存器eax同时供input，output使用。输入变量var被读入到eax，运算结束后，再被存储到eax。“0”这个限制符表示：与第0个操作数使用相同的寄存器。这样，就指明了输出输入使用同一个寄存器。这个限制符在如下地方可能用到：读取输入变量或修改变量，并将变量修改写回同一变量的情况下。没有必要使用更多的寄存器时。使用匹配限制符最重要的作用是：使得对有限寄存器资源使用更高效。\n\n\n其他一些限制\n\n\n\n\n\n\n\n\n\n“m”：内存操作被允许，机器通常支持的任何合法地址。\n“o”：内存操作被允许，但前提是支持地址偏移值。即，地址加上一个小的偏移量给出一个有效地址。\n“V”：内存操作不支持偏移量。也就是说，支持“m”限制符，但不支持“o”的那些地址。\n“i”：立即数操作被允许。包括在汇编时才知道的常量。\n“n”：立即数为已经数值的操作被允许。许多系统不支持汇编中的操作数小于一个字宽。对于这些操作数的限制应该使用”n”而不是”i”。\n“g”：任意寄存器，内存，立即数都被允许。除了非通用寄存器。\n\nx86特定限制符\n\n\n\n\n\n\n\n\n\n“r”：寄存器约束，查看上面。\n“q”：寄存器们 a，b，c或d\n“I”：常量范围0到31位\n“J”：常量范围0到63位\n“K”：oxff\n“L”：0xffff\n“M”：0，1，2或3（适用于lea指令的移位）\n“N”：常量范围0到255（对于输出指令）\n“f”：浮点寄存器\n“t”：第一个（栈顶）浮点寄存器\n“u”：第二个浮点寄存器\n“A”：指定’a’或’d’寄存器。这主要用于要返回的 64 位整数值，“d”寄存器保存最高有效位，“a”寄存器保存最低有效位。\n\n限制修饰符\n\n\n\n\n\n\n\n\n在使用限制符，为了更精确的控制限制的影响，GCC提供给我们一些限制语句修饰符。最常用的修饰符有：”&#x3D;”，”&amp;”。\n\n“&#x3D;”：表示该指令的操作数类型是只写。之前的值会被丢弃，并将输出数据写入。\n“&amp;”：表示一个操作数是一个早期会变(earlyclobber)的操作数，在指令完成之前使用输入操作进行修改。因此，此操作数可能不会用作输入操作数或用作任何内存地址的一部分的寄存器中。如果输入操作数仅用作输入操作且在写入早期结果之前，则可以将输入操作数绑定到 earlyclobber 操作数。\n\nSome Useful Recipes.\n\n\n\n\n\n\n\n\n现在我们已经接触GCC内联汇编的基本理论，我应该专注于几个简单的例子。使用内联汇编来定义宏是非常精妙的，我们可以在内核代码中看到许多asm函数\n1.首先以一个简单的开始，两个数相加\nint main(void)\n&#123;\n  int foo &#x3D; 10, bar &#x3D; 15;\n  __asm__ __volatile__(&quot;addl %%ebx, %%eax&quot;\n                        :&quot;&#x3D;a&quot;(foo)\t\t\t\t\t&#x2F;&#x2F; output\n                        :&quot;a&quot;(foo), &quot;b&quot;(bar)\t&#x2F;&#x2F; input\n                        );\n  printf(&quot;foo+bar&#x3D;%d\\n&quot;,foo);\n  return 0;\n&#125;\n\n这里我们指定gcc让eax寄存器存储foo，bar存放在ebx，并且将结果放在eax寄存器中。这里的”&#x3D;”表示是存放输出结果的寄存器。\n接下来，我们可以用一些其他方式来添加一个整数\n__asm__ __volatile__(\n                      &quot;\tlock\t;\\n&quot;\n                      &quot;\taddl %1,%0\t;\\n&quot;\n                      :&quot;&#x3D;m&quot;\t(my_var)\n                      :\t&quot;ir&quot;\t(my_int), &quot;m&quot;\t(my_var)\n                      :\n                      );\n\n这是一个原子加法。可以去除”lock”指令来去除原子性。在输出域，”&#x3D;m”的意思是my_var是输出操作数，并且是在内存中。相似的，”ir”的意思是my_int是一个整数，可以选择一个通用寄存器来存放。没有寄存器在clobber list中\n2.现在我们执行一些操作在寄存器&#x2F;变量上，并且比较它们的值。\n__asm__ __volatile__(\t&quot;decl %0; sete %1&quot;\n                      : &quot;&#x3D;m&quot;(my_var), &quot;&#x3D;q&quot; (cond)\n                      : &quot;m&quot; (my_var)\n                      : &quot;memory&quot;\n                      );\n\n这里，my_var的值自减一，如果结果为0，则cond置1。可以通过增加指令”lock;\\n\\t”来确保原子性。\n类似的方式，我们可以使用“incl %0”而不是“decl %0”，这个是增加 my_var。\n要点：1.my_var值的变化是直接在内存中。2.cond的限制是”&#x3D;q”，所以它使用的寄存器是eax，ebx，ecx，edx中的一个。3.可以看到”memory”在clobber list中，即，代码改变的内容都在内存中。\n3.如何设置&#x2F;清除寄存器的一位？请看下面的例子：\n__asm__ __volatile__(\t&quot;btsl %1, %0&quot;\n                      :\t&quot;&#x3D;m&quot; (ADDR)\n                      : &quot;Ir&quot;\t(pos)\n                      : &quot;cc&quot;\n                      );\n\n将’pos’的ADDR(内存变量)变量的比特位置1。我们可以使用’blrl’代替’btsl’来清理这个比特位。pos的限制”Ir”是说pos位于寄存器中，值的范围0-31位。即，我们可以设置&#x2F;清除任何0-31比特位的值在ADDR中。因为条件代码将会改变，所以我们增加”cc”到clobberlist。\n4.现在我看几个复杂但是有用的函数，字符串拷贝\nstatic inline char *strcpy(char *dest, const char *src)\n&#123;\n  int d0, d1, d2;\n  __asm__ volatile__(\t&quot;1:\\tlodsb\\n\\t&quot;\t\t     \t\t&#x2F;&#x2F;加载DS:[esi]处1字节-&gt;al,并更新esi\n                      &quot;stosb\\n\\t&quot;\t\t\t\t\t\t\t\t&#x2F;&#x2F;存储字节al-&gt;ES:[edi],并更新edi\n                      &quot;testb %%al, %%al\\n\\t&quot;\t\t&#x2F;&#x2F;刚存储的字节是0?\n                      &quot;jne 1b&quot;\n                      : &quot;&#x3D;&amp;S&quot; (d0), &quot;&#x3D;&amp;D&quot; (d1), &quot;&#x3D;&amp;a&quot; (d2)\t&#x2F;&#x2F;output &quot;S&quot;:esi &quot;D&quot;:edi\n                      : &quot;0&quot;(src), &quot;1&quot; (dest)\t\t&#x2F;&#x2F; input\n                      :&quot;memory&quot;);\n   return dest;\n&#125;\n\n源地址存放在esi中，目标在edi中，然后开始拷贝，当到达0，拷贝完成。限制符”&amp;S”,”&amp;D”,”&amp;a”是说寄存器esi,edi和eax，并且它们是早期改变的寄存器，即，它们的内容在函数结束之前会有改变。所以clobberlist同样为”memory”。\n接下来看一个相似的函数，移动2个字节的块。注意，它以宏的方式实现。\n#define mov_blk(src, dest, numwords) \\\n__asm__ __volatile__ (                                          \\\n                       &quot;cld\\n\\t&quot;                                \\\n                       &quot;rep\\n\\t&quot;                                \\\n                       &quot;movsl&quot;                                  \\\n                       :                                        \\\n                       : &quot;S&quot; (src), &quot;D&quot; (dest), &quot;c&quot; (numwords)  \\\n                       : &quot;%ecx&quot;, &quot;%esi&quot;, &quot;%edi&quot;                 \\\n                       )\n\n这里没有输出，寄存器ecx,esi和edi的内容发生变化是因为块的移动的原因。所以需要将它们添加到colbberlist中。\n5.在Linux中，系统调用是使用GCC内联汇编实现的。接下来我们看看系统调用是如何实现的。所有的系统都写成宏(linux&#x2F;unistd.h)。举例，具有三个参数的系统调用被定义为如下所示的宏。\n#define _syscall3(type,name,type1,arg1,type2,arg2,type3,arg3) \\\ntype name(type1 arg1,type2 arg2,type3 arg3) \\\n&#123; \\\nlong __res; \\\n__asm__ volatile (  &quot;int $0x80&quot; \\\n                  : &quot;&#x3D;a&quot; (__res) \\\n                  : &quot;0&quot; (__NR_##name),&quot;b&quot; ((long)(arg1)),&quot;c&quot; ((long)(arg2)), \\\n                    &quot;d&quot; ((long)(arg3))); \\\n__syscall_return(type,__res); \\\n&#125;\n\n在每次进行带有三个参数的系统调用时，都会使用上面显示的宏进行调用。系统调用名称放在 eax 中，参数放在 ebx、ecx、edx 中。 最后“int 0x80”是使系统调用工作的指令。 返回值存入 eax 。\n每个系统调用都以类似的方式实现。 Exit 是一个单参数系统调用，让我们看看它的代码是什么样子的。 如下：\n&#123;\n        asm(&quot;movl $1,%%eax;         &#x2F;* SYS_exit is 1 *&#x2F;\n             xorl %%ebx,%%ebx;      &#x2F;* Argument is in ebx, it is 0 *&#x2F;\n             int  $0x80&quot;            &#x2F;* Enter kernel mode *&#x2F;\n             );\n&#125;\n\nexit的编号是1，参数是0。所以将eax存放1，ebx存放0，然后执行指令”int $0x80”。这就是exit的工作方式。\n文章参考\n原文\nclion调试\n\n\n\n\n\n\n\n\n\n裸函数声明裸函数\n\n\n\n\n\n\n\n\n裸函数与普通函数的区别在于在函数前多声明了\n__declspec (naked) 动态链接库  裸体的\n以此来表明该函数是一个裸函数\n裸函数作用\n\n\n\n\n\n\n\n\n要讲裸函数的作用，就不得不提到裸函数与普通函数的区别\n裸函数与普通函数区别\n前面反汇编C语言的笔记里，我们可以得知一个普通空函数的反汇编代码并不少，保护现场、恢复现场等等都有，那么这些反汇编代码是如何产生的呢？\n答案是：编译器\n编译器会为我们产生这些反汇编代码\n相比之下，只要普通函数加上裸函数前缀转化为裸函数，编译器就会知道这个函数无需额外生成上面所说的保护现场、恢复现场等反汇编代码，函数执行所需的反汇编代码由我们自己来实现\n于是裸函数的作用呼之欲出：\n当我们不希望编译器为我们生成函数里的汇编代码，而是想要自己实现函数内部的汇编代码时，就可以使用裸函数来告诉编译器不要去额外生成汇编代码\n最简单的裸函数\n\n\n\n\n\n\n\n\nvoid __declspec (naked) function()&#123;\n        __asm&#123;\n                ret\n        &#125;\n&#125;\n\n上面是一个最简单的裸函数，反汇编代码只有一行ret\n与普通空函数相比，同样是什么都没做，但却要加上ret，为什么？\n我们可以来看看这个最简单的裸函数的执行流程，并注意与普通空函数对比\n\n内联汇编实现加法函数\n\n\n\n\n\n\n\n\n\n不难发现，其实我们自己实现的加法函数就是模拟了编译器为我们做的事情\nint __declspec (naked) __stdcall  plus(int x, int y) &#123;\n\t__asm &#123;\n\t\t&#x2F;&#x2F;保留调用前堆栈\n\t\tpush ebp\n\t\t&#x2F;&#x2F;提升堆栈\n\t\tmov ebp, esp\n\t\tsub esp, 0x40\n        &#x2F;&#x2F;保护现场\n        push ebx\n        push esi\n        push edi\n        &#x2F;&#x2F;初始化提升的堆栈，填充缓冲区\n        mov eax, 0xCCCCCCCC\n        mov ecx, 0x10\n        lea edi, dword ptr ds : [ebp - 0x40]\n        rep stosd\n        &#x2F;&#x2F;函数核心功能\n\n        &#x2F;&#x2F;取出参数\n        mov eax, dword ptr ds : [ebp + 8]\n        &#x2F;&#x2F;参数相加\n        add eax, dword ptr ds : [ebp + 0xC]\n        &#x2F;&#x2F;恢复现场\n        pop edi\n        pop esi\n        pop ebx\n        &#x2F;&#x2F;降低堆栈\n        mov esp, ebp\n        pop ebp\n\n        &#x2F;&#x2F;返回\n        ret 8\n    &#125;\n&#125;\nint main()\n&#123;\n    int ret &#x3D; plus(1, 2);\n    printf(&quot;%d\\n&quot;,ret);\n    return 0;\n&#125;\n\n结构体压缩\n\n\n\n\n\n\n\n\n我们首先要知道编译器默认是结构体内存对齐的，牺牲空间提高时间\n\n压缩结构体的方法\nwindows下\n#pragma\n&#x3D;&#x3D;语法&#x3D;&#x3D;\n\n#pragma pack (n) 作用：C编译器将按照n个字节对齐。\n#pragma pack () 作用：取消自定义字节对齐方式。\n#pragma pack (push,1) 作用：是指把原来对齐方式设置压栈，并设新的对齐方式设置为一个字节对齐\n#pragma pack(pop) 作用：恢复对齐状态\n\n\ngcc下\n__attribute__((packed))或者__attribute__((__packed__))\n\n二级标题三级标题四级标题五级标题六级标题","slug":"汇编/汇编","date":"2020-08-15T10:49:36.000Z","categories_index":"工具","tags_index":"汇编,Ubuntu","author_index":"虫子"},{"id":"88d34cf14213785f83521b3d3b17b57d","title":"汇编中的C","content":"汇编视角中的C\n\n\n\n\n\n\n\n\n如果绝大多数人都是c进入大门，那么汇编就是地下室。而我们现在就是在地下室朝上面望，透彻看懂c的底部构造\n参数传递和返回值\n\n\n\n\n\n\n\n\n\n变量全局变量\n\n\n\n\n\n\n\n\n1.编译的时候就已经确定了内存地址和宽度了，变量名就是内存地址的别名\n2.如果不重写编译，全局变量的内存地址不变，游戏外挂中找“基址”，其实就是找全局变量\n3.全局变量中的值任何程序都可以改，是公用的\n\n\n\n局部变量\n\n\n\n\n\n\n\n\n1.局部变量是函数内部申请的，如果函数没有执行，那么局部变量内有内存空间\n2.局部变量的内存在堆栈中分配的，程序执行时才分配，我们无法预知程序何时执行，这也就意味着，我们无法确定局部变量的内存地址\n3.因为局部变量地址内存是不确定的，所以局部变量只能在函数内部使用，其他函数不能使用\n\n变量与参数的内存布局\n\n\n\n\n\n\n\n\n1.参数在内存中的位置\n2.局部变量在内存中的位置\n3.返回值是如何返回的，如何使用的\n\n函数嵌套调用的内存布局\n\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;后面没画好不想画了&#x3D;&#x3D;\n整数类型\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;c语言变量类型&#x3D;&#x3D;\n\n整数类型的数据宽度\n\n\n\nchar\n8bit\n1字节\n0~0xff\n\n\n\n\n\n\nshort\n16bit\n2字节\n0~0xffff\n\n\n\n\n\n\nint\n32bit\n4字节\n0~0xffffffff\n\n\n\n\n\n\nlong\n32bit\n4字节\n0~0xffffffff\n\n\n\n浮点类型\n\n\n\n\n\n\n\n\n\n\n\nfloat\n4字节\n\n\n\n\n\n\ndouble\n8字节\n\n\n\n\n\n\nlong double\n8字节(某些平台的编译器可能是16个字节)\n\n\n\n运算符与表达式\n\n\n\n\n\n\n\n\n表达式结果\n(x+y)*(x-y)\n无论多么复杂的结构他都会有一个结果，那么这里结果是什么类型的呢？如果表达式里面有char或者short类型的变量只要一参与运算他会先转变为int类型，然后再参与运算\nmovsx\n\n\n\n\n\n\n\n\n我们要先了解movsx和movzx\nmovsx是先符号扩展，再传送\n\nmovzx\n\n\n\n\n\n\n\n\n先零扩展,再传送\nMOVZX不用像MOVSX哪样，先判断符号，再填充，MOVZX直接用0来填充\n\n表达式中char，short运算\n\n\n\n\n\n\n\n\n\n我们通过底层可以看到short和char参与运算的时候还会提升成int类型进行运算\n\n运算符\n\n\n\n\n\n\n\n\n算数运算符\n+-*&#x2F;% ++ –\n\n\n关系运算符\n&lt; &lt;&#x3D; &gt; &gt;&#x3D; &#x3D;&#x3D; !&#x3D;\n关系运算符的值只能是0或1\n逻辑运算符\n！ &amp;&amp;  ||\n可以把很多个表达式给串起来\nx&gt;y &amp;&amp; x&lt;z只有一个结果\nx&lt;y || x&lt;z 只有一个结果\n\n位运算符\n&lt;&lt; &gt;&gt; ~ | ^ &amp;\n\n赋值运算符\n&#x3D;拓展赋值\n+&#x3D; -+ &lt;&lt;&#x3D; ….\n条件运算符\n? :\n\n分支语句\n\n\n\n\n\n\n\n\n没必要讲了\nswitch语句\n\n\n\n\n\n\n\n\n\nswitch语句为什么高效\n\n\n\n\n\n\n\n\nswitch语句比if  else高效\n\n\n&#x3D;&#x3D;我们选项乱的话不影响他的大表，那我们不从1，2，3，4开始，我们随机数卡看看反汇编&#x3D;&#x3D;\n\n循环语句while\n\n\n\n\n\n\n\n\n\ndo while\n\n\n\n\n\n\n\n\n\nfor\n\n\n\n\n\n\n\n\n\n数组\n\n\n\n\n\n\n\n\n\n多维数组\n\n\n\n\n\n\n\n\n多维数组和一维数组实际上没有什么区别\n\n结构体\n\n\n\n\n\n\n\n\n\n字节对齐\n\n\n\n\n\n\n\n\n\n\n指针类型\n\n\n\n\n\n\n\n\n\n带有*的变量类型的标准写法，变量类型*变量名\n任何类型都可以带*加上*以后的新的类型，统称“指针类型”\n*可以是任意多个\n\n指针类型的自加和自减(++&#x2F;–)\n\n\n\n\n\n\n\n\n\n\n不带*类型的变量，++或者–都是加1或者减1\n带*类型的变量，++或者–新增(减少)的数量是去掉一个*后变量的宽度\n\n&amp;的使用\n\n\n\n\n\n\n\n\n&amp;是地址符，任何变量都可以使用&amp;来获取地址，但不能用在常量上\n取值运算符\n\n\n\n\n\n\n\n\n\n数组参数传递\n\n指针与字符串常用的字符串函数\n\n\n\n\n\n\n\n\n\nint strlen(char* s)\n返回值是字符串s的长度，不包括结束符‘&#x2F;0’\n\n\nchar* strcpy(char* dest,char* src)\n复制字符串src到dest中，返回指针为dest的值\n\n\nchar* strcat(char* dest,char* src)\n将字符串src添加到dest尾部，返回指针为dest的值\n\n\nint strcmp(char* s1,char* s2）\n一样返回0，不一样返回非0\n\n\n\n\n指针函数\n本质就是函数，只不过函数的返回值类型是某一类型的指针\nchar* strcpy (char* dest,char* src)\nchar* strcat (char* dest,char* src)\n调用约定\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;函数调用约定&#x3D;&#x3D;\n就是告诉编译器，怎么传递参数，怎么传递返回值，怎么平衡堆栈\n常见的几种调用约定\n\n\n调用约定\n参数压栈顺序\n平衡堆栈\n\n\n\n__cdecl\n从右向左入栈\n调用者清理栈\n\n\n__stdcall\n从右向左入栈\n自身清理堆栈\n\n\n__fastcall\nECX&#x2F;EDX传送前两个剩下:从右至左入栈\n自身清理堆栈\n\n\n函数指针函数指针类型变量的定义\n\n\n\n\n\n\n\n\n函数指针变量定义的格式\n返回类型 (调用约定* 变量名)(参数列表)\nint (__cdecl* pFun)(int,int)\n函数指针通常用来干什么，用来别人写好的函数，假如在我手里面只有一个二进制代码，没有原来他声明的那种格式，不清楚这个函数是什么样的，那么我们就可以通过他的汇编代码进行分析，分析完了后我想执行哪里就把那里的地址赋值给我的函数指针变量。\n\n预处理之宏定义什么是预处理\n\n\n\n\n\n\n\n\n预处理一般是指在程序源代码被转换为二进制代码之前，由预处理器对程序源文件文本进行处理，处理后的结果再由编译器进一步编译，预处理功能只要包括宏定义，文件包含，条件编译三部分\n条件编译与文件包含\n\n\n\n\n\n\n\n\n\n条件编译\n前置声明\n\n二级标题三级标题四级标题五级标题六级标题","slug":"汇编/逆魔C本质","date":"2020-08-15T10:49:36.000Z","categories_index":"汇编","tags_index":"汇编,C语言","author_index":"虫子"},{"id":"e3fd262092e25289deee8899b8334891","title":"IDA","content":"IDAIDA目录结构\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n界面视图\n\n\n\n\n\n\n\n\n\nhex dump\n\n\n\n\n\n\n\n\n直接查看程序的二进制内容（以hex值表示）一般用于直接查找存在程序中的明文字符串和动态调试时的内容查看\n\ndisassembly\n\n\n\n\n\n\n\n\n查看程序反编译出的汇编代码（以汇编语言显示）一般用于直接分析相关函数的汇编代码\n\n&#x3D;&#x3D;ctrl+e跳到main&#x3D;&#x3D;\n\nFunctions_window\n\n\n\n\n\n\n\n\n函数表（重要）用于分析每一个单独的函数在逆向分析中往往都是直接利用Function_windows 查找关键函数开始对整个程序进行分析该窗口提供ctrl+F 的搜索功能 例如可以直接ctrl+f 定位到main函数\n\nnames\n\n\n\n\n\n\n\n\n符号表,包括函数名，变量名等\n\nstrings\n\n\n\n\n\n\n\n\n快捷键shift+f12）：字符串表 包括程序中存储的字符串常量（在逆向分析中对于定位关键函数有很大帮助）\n\nimport export\n\n\n\n\n\n\n\n\n\n\n段表\n\n\n\n\n\n\n\n\n包程序的各个段的信息比如.text（代码段）.data（数据段）（涉及到PE结构的相关知识）\n\n二级标题三级标题四级标题五级标题六级标题","slug":"汇编/逆魔苗头","date":"2020-08-15T10:49:36.000Z","categories_index":"工具","tags_index":"工具,IDA","author_index":"虫子"},{"id":"f064c88a47efdfeb654dd100ef52134b","title":"OD","content":"OD\n\n\n\n\n\n\n\n\n\n\n五种内存形式立即数形式\n\n\n\n\n\n\n\n\n\n[reg]  reg代表寄存器，可以是8个通用寄存器中的任意一个\n\n\n\n\n\n\n\n\n\n[reg+立即数]\n\n\n\n\n\n\n\n\n\n[reg+reg*{1,2,4,8}]\n\n\n\n\n\n\n\n\n数组就是这么搞的\n\n\n[reg+reg*{1,2,4,8}+立即数]\n\n\n\n\n\n\n\n\n\n\nmovs指令  特殊移动    内存 – &gt;内存\n\n\n\n\n\n\n\n\n\n\nstos指令\n\n\n\n\n\n\n\n\n将al&#x2F;ax&#x2F;eax的值存储到[edi]指定的内存单元\n\n什么是堆栈\n\n\n\n\n\n\n\n\n\n就是一块内存，操作系统在程序启动的时候已经分配好的，供程序执行时使用\n和数据结构的堆栈无关\n参看堆栈\n\n\n\n&#x3D;&#x3D;我们每次使用堆栈都要自己去控制esp显然是不现实的，所以有了push和pop&#x3D;&#x3D;\n\n修改eip\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;jmp修改&#x3D;&#x3D;\n\n&#x3D;&#x3D;call修改&#x3D;&#x3D;\n\n&#x3D;&#x3D;ret修改&#x3D;&#x3D;\n\n堆栈平衡\n\n\n\n\n\n\n\n\n1.如果要反回父程序，则当我们在堆栈中进行堆栈的操作的时候，一定要保证在ret这条指令之前，esp指向我们压入栈中的地址\n2.如果通过堆栈传递参数了，那么在函数执行完毕后，要平衡参数导致的堆栈变化\n外挂&#x3D;&#x3D;修改内存的形式&#x3D;&#x3D;\n\n\n\n\n\n\n\n\n这个本质还是别的程序(他原本程序)调用它射击功能的\n\n&#x3D;&#x3D;正常3秒&#x3D;&#x3D;\n\n&#x3D;&#x3D;修改内存快速射击&#x3D;&#x3D;\n\n\n也可以用代码的方式进行跨进程读写内存\n&#x3D;&#x3D;用户调用它的程序&#x3D;&#x3D;\n\n\n\n\n\n\n\n\n用户写的程序调用他的射击\n\n用户自己可以随便注入\n\nesp寻址\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;我们参数少的时候可以用寄存器的方式来实现参数的传递&#x3D;&#x3D;\n\n但是难免我们有时候参数会很多，所以这时候寄存器会不够用，所以就会使用堆栈的形式来传递参数\n\n&#x3D;&#x3D;用堆栈来传递参数非常舒服，但是有没有弊端呢？&#x3D;&#x3D;\n是有弊端的，就是函数复杂的时候我们需要保存现场\n\nebp寻址\n\n\n\n\n\n\n\n\n\njcc指令\n\n\n\n\n\n\n\n\n学jcc指令前要了解标志寄存器eflags\neflags\n\n\n\n\n\n\n\n\n\nCF(bit 0) [Carry flag]\n\n\n\n\n\n\n\n\n若算术操作产生的结果在最高有效位发生进位或借位则将其置一，反之清零\n这个标志通常用来指示无符号整形运算的溢出状态\nPF(bit 2) [Parity flag]\n\n\n\n\n\n\n\n\n如果结果的最低有效字节包含偶数个1位，则该位置1，否则清零\n利用PF可进行奇偶校验检查\n需要传输“110011100”数据中包含5个1，所以其奇校验为0，同时把110011100传输给接收方，接收方收到数据后再一次计算奇偶性，110011100中任然含有5个1，所以接收方计算出的奇校验位还是0，与发送方一致，表示在此次传输过程中未发生错误\nAF(bit 4) [Auxiliary Carry flag]\n\n\n\n\n\n\n\n\n如果算术操作在结果的第3位发生进位或借位则将标志置1，否则清零\n这个标志在BCD算术运算中被使用\nZF(bit 6) [Zero flag]\n\n\n\n\n\n\n\n\n若结果为0则将其置1，反之清零\n经常与CMP或者TEST等指令一起使用\nSF(bit 7) [Sign flag]\n\n\n\n\n\n\n\n\n该标志被设置为有符号整型的最高有效位\n(0指示结果为正，反之则为负)\nOF(bit 11) [Overflow flag]\n\n\n\n\n\n\n\n\n溢出标志OF用于反映有符号数加减运算所得结果是否溢出\n如果是无符号运算，是否溢出看CF位\n如果是有符号数运算，是否溢出看OF位\nDF(bit 10) [Direction flag]\n\n\n\n\n\n\n\n\n这个方向标志控制串指令(MOVS,CMPS,SCAS,LODS以及STOS)，设置DF标志使得串指令自动递减(从高地址向低地址方向处理字符串)，清除该标志则使得串指令自动递增\nSTD以及CLD指令分别用于设置以及清除DF标志\n所有jcc指令\n\n\n1\nJE，JZ\n结果为零则跳转(相等时跳转)\nZF&#x3D;1\n\n\n\n2\nJNE，JNZ\n结果不为零则跳转(不相等时跳转)\nZF&#x3D;0\n\n\n3\nJS\n结果为负则跳转\nSF&#x3D;1\n\n\n4\nJNS\n结果为非负则跳转\nSF&#x3D;0\n\n\n5\nJP，JPE\n结果中的1的个数为偶数则跳转\nPE&#x3D;1\n\n\n6\nJNP，JPO\n结果中的1的个数为偶数则跳转\nPE&#x3D;0\n\n\n7\nJO\n结果溢出了则跳转\nOF&#x3D;1\n\n\n8\nJNO\n结果没有溢出则跳转\nOF&#x3D;0\n\n\n9\nJB，JNAE\n小于则跳转(无符号数)\nCF&#x3D;1\n\n\n10\nJNB，JAE\n大于等于则跳转(无符号数)\nCF&#x3D;0\n\n\n11\nJBE，JNA\n小于则跳转(无符号数)\nCF&#x3D;1 or ZF&#x3D;1\n\n\n12\nJNBE，JA\n大于则跳转(无符号数)\nCF&#x3D;0 and ZF&#x3D;0\n\n\n13\nJL，JNGE\n小于则跳转(有符号数)\nSF!&#x3D;OF\n\n\n14\nJNL,JGE\n大于等于则跳转(有符号数)\nSF&#x3D;OF\n\n\n15\nJLE，JNG\n小于等于则跳转(有符号数)\nZF&#x3D;1 or  SF!&#x3D;OF\n\n\n16\nJNLE,JG\n大于则跳转(有符号数)\nZF&#x3D;0 and SF&#x3D;OF\n\n\n二级标题三级标题四级标题五级标题六级标题","slug":"汇编/逆魔初级","date":"2020-08-15T10:49:36.000Z","categories_index":"工具","tags_index":"工具,OD","author_index":"虫子"},{"id":"c6db4d1ad0c97adc524f1401c6716083","title":"WIFI主机-催眠师手札","content":"WIFI主机\n\n\n\n\n\n\n\n\n有些函数名后面写的时候会改一下名字，方面整体记忆。比如Systick_ms改为hal_SystickCoreClockInit\n项目中的一些细节\n\n\n\n\n\n\n\n\n\n\nGPIO\n\n\n\n\n\n\n\n\n我们wifi主机采用的信号是STM32F103C8T6，封装就是LQFP48 ，flash大小就是64K,GPIO就相当于STC15单片机里面的IO口，比如P1，P2，而在STM32中就被命名为PA，PC等等，我们这个型号有48个引脚PA，PB各15个\n\n\n\n\n\n系统定时器\n\n\n\n\n\n\n\n\nSystick是一个24位的系统节拍定时器，SysTick—系统定时器是属于内核的一个定时器，一个 24bit 的向下递减的计数器，计数器每计数一次的时间为 1&#x2F;SYSCLK，一般我们设置系统时钟 SYSCLK 等于 72M。当重装载数值寄存器的值递减到 0 的时候，系统定时器就产生一次中断，以此循环往复。\nSystick的作用：为操作系统任务调度（比如RTOS）提供一个有节奏的定时节拍，也可以用于普通定时。\n\ncounter在时钟的驱动下，从reload初值开始往下递减计数到0，产生中断和置位COUNTFLAG标志。然后又从reload值开始重新递减计数，如此循环。\nSysTick寄存器结构体在固件库文件：core_cm3.h中定义\n\nSysTick配置库函数在固件库文件：core_cm3.h中定义\n\nstatic __INLINE uint32_t SysTick_Config(uint32_t ticks)\n&#123; \n  //判断tick的值是否大于2^24，如果大于则不符合规则\n  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */\n  \n  //初始化重装载(reload)寄存器的值\t\n  SysTick->LOAD  = (ticks &amp; SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */\n  //配置中断优先级，配置15，默认为最低的优先级\n  NVIC_SetPriority (SysTick_IRQn, (1&lt;&lt;__NVIC_PRIO_BITS) - 1);  /* set Priority for Cortex-M0 System Interrupts */\n  //配置counter计数器的值\n  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */\n  //配置systick的时钟是72M\n  //使能中断\n  //使能systick\n  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk | \n                   SysTick_CTRL_TICKINT_Msk   | \n                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */\n  return (0);                                                  /* Function successful */\n&#125;\n\nSysTick中断优先级\n\n\n\n\n\n\n\n\n有一个问题就是SysTick是属于内核里面的外设，他的中断优先级跟片上外设的中断优先级相比，哪个高？？？是内核必然高于片上吗？\n不是的，STM32里面无论是内核还是外设都是使用4个二进制位来表示中断优先级；中断优先级的分组对内核和外设同样适用。当比较的时候，只需要把内核外设的中断优先级的四个位按照外设的中断优先级来分组来解析即可，即人为的分出抢占优先级和子优先级\nsystick中断优先级配置的是scb-&gt;shprx寄存器；而外设的中断优先级配置的是nvic-&gt;iprx，有优先级分组，有抢占优先级和子优先级的说法。\n\n\n\n定时器定时器功能\n\n\n\n\n\n\n\n\n定时、输出比较、输入捕获、互补输出\n定时器分类\n\n\n\n\n\n\n\n\n基本定时器、通用定时器、高级定时器\n基本定时器:只有定时功能\n\n通用定时器：具备定时，输出比较，输入捕获\n高级定时器：包含基本定时器和通用定时器的所有功能\n\n\n\n定时器资源\n\n\n\n\n\n\n\n\nF103系列有2个高级定时器TIM1和TIM8、4个通用定时器TIM2&#x2F;3&#x2F;4&#x2F;5、2个基本定时器TIM6和TIM7\n基本定时器\n\n\n\n\n\n\n\n\n\n时钟源\n\n\n\n\n\n\n\n\n\n时钟源来自RCC的TIMx_CLK（属于内部的CK_INT）\n2-TIMx_CLK等于多少呢？如何确定？72M，这个看RCC时钟树\n\n控制器\n\n\n\n\n\n\n\n\n\n控制器用于控制定时器的：复位、使能、计数、触发DAC\n涉及到的寄存器为：CR1&#x2F;2、DIER、EGR、SR\n\n\n时基（定时器的心脏）\n\n\n\n\n\n\n\n\n定时器最主要的就是时基部分：包括 预分频器、计数器、自动重装载寄存器。\n预分频器:也叫PSC，对时钟进行分频的\n\n16位的预分频器PSC对内部时钟CK_PSC进行分频之后，得到计数器时钟CK_CNT=CK_PSC/(PSC+1)\n计数器CNT在计数器时钟的驱动下开始计数，计数一次的时间为1/CK_CNT,那么他的周期是不是不要再乘上ARR，而我们的计数是从0开始计数的，所以我们ARR还要加一，所以周期是(1/CK_CNT)*(ARR+1)\n\n计数器、自动重装载寄存器:计数器CNT，自动重装载寄存器ARR\n定时器使能(CEN 置 1)后，计数器 CNT在CK_CNT 驱动下计数，当 TCNT 值与 ARR 的设定值相等时就自动生成事件并 CNT 自动清零，然后自动重新开始计数，如此重复以上过程。\n影子寄存器\n\n\n\n\n\n\n\n\n\n\nPSC和ARR都有影子寄存器，功能框图上有个影子\n\n影子寄存器的存在起到一个&#x3D;&#x3D;缓冲的作用&#x3D;&#x3D;，用户值-&gt;寄存器-&gt;影子寄存器-&gt;起作用，如果不使用影子寄存器则用户值在写到寄存器之后则里面起作用。\n&#x3D;&#x3D;ARR影子，TIMx_CR1:APRE位控制&#x3D;&#x3D;\n\n\n定时时间的计算\n\n\n\n\n\n\n\n\n\nPSC &#x3D; 72-1，定时器频率&#x3D;72M&#x2F;(PSC+1)&#x3D;1MHZ     &#x3D;&#x3D;(我来说说为啥PSC要减一加一，首先我们计数是从0开始计数的，所以0也是算一个的，比如我们要计10个数，那么我们计到9就行，计到10就是11个多一个了；PSC+1就是加那个0的计数)&#x3D;&#x3D;\nARR &#x3D; 1000-1，从0计数到999，则计了1000次\n中断周期T &#x3D; 1000 *1&#x2F;1000000 &#x3D; 1mS\n\n时基初始化结构体\n\n\n\n\n\n\n\n\n\n//时基初始化结构体\ntypedef struct\n&#123;\n  //分频因子\n  uint16_t TIM_Prescaler;     \n  //计数模式，基本定时器只能向上\n  uint16_t TIM_CounterMode;  \n  //自动重装载值\n  uint16_t TIM_Period;           \n  //外部输入时钟分频因子，基本定时器没有\n  uint16_t TIM_ClockDivision;     \n  //重复计数器，基本定时器没有，高级定时器专有\n  uint8_t TIM_RepetitionCounter;  \n&#125; TIM_TimeBaseInitTypeDef; \n\n\n\n\n\n\n\n\n\n\n比较一个难受的是C8T6的定时器只有1-4没有基本定时器，导致我在中断源那边一直报错，明明我是在另一个板子上有用，咋C8T6不行了呢，然后查了手册是没有基本定时器的，那么我们WIFI主机就不用基本定时器就用1个高级和3个通用的，那么下面的高级才是高潮部分，上面的基本就是前戏。\n\n\n高级定时器\n\n\n\n\n\n\n\n\n\n时钟源\n\n\n\n\n\n\n\n\n这里先说一下时钟源百分之99用内部的，其他3个基本不用，下面三个当做了解，有地方错了，有点迷糊\n\n\n\n\n\n\n\n\n\n\n内部时钟源CK_INT\n外部时钟模式1—外部的GPIO Tix（x&#x3D;1 2 3 4）\n外部时钟模式2—外部的GPIO ETR\n内部触发输入\n\n内部时钟源\n\n\n\n\n\n\n\n\n\n内部时钟源来自RCC的TIMx_CLK\nTIMx_CLK等于多少呢？如何确定？\n\n\n外部时钟模式1\n\n\n\n\n\n\n\n\n\n时钟信号输入引脚\n\n\n\n\n\n\n\n\n\n外部的GPIO TIx，对应：TIMx_CH1&#x2F;2&#x2F;3&#x2F;4\nTIM_CCMRx 的位 CCxS[1:0]配置，其中 CCMR1 控制 TI1&#x2F;2， CCMR2 控制 TI3&#x2F;4\n\n滤波器\n\n\n\n\n\n\n\n\n\n如果来自外部的时钟信号的频率过高或者混杂有高频干扰信号的话，我们就需要使用滤波器对 ETRP 信号重新采样，来达到降频或者去除高频干扰的目的\n由TIMx_CCMRx 的位 ICxF[3:0]配置\n\n边沿检测\n\n\n\n\n\n\n\n\n\n边沿检测的信号来自于滤波器的输出，在成为触发信号之前，需要进行边沿检测，决定是上升沿有效还是下降沿有效。\n由 TIMx_CCER 的位 CCxP 和 CCxNP 配置\n\n触发选择\n\n\n\n\n\n\n\n\n\n当使用外部时钟模式 1 时，触发源有两个，一个是滤波后的定时器输入 1（ TI1FP1）和滤波后的定时器输入 2（ TI2FP2）\n由 TIMx_SMCR 的位 TS[2:0]配置\n\n使能计数器\n\n\n\n\n\n\n\n\n\n经过上面的 5 个步骤之后， 最后我们只需使能计数器开始计数，外部时钟模式 1 的配置就算完成。\n使能计数器由 TIMx_CR1 的位 CEN 配置。\n\n外部时钟模式2\n\n\n\n\n\n\n\n\n\n时钟信号输入引脚\n\n\n\n\n\n\n\n\n当使用外部时钟模式 2 的时候，时钟信号来自于定时器的特定输入通道 TIMx_ETR，只有 1 个。\n外部触发极性\n\n\n\n\n\n\n\n\n\n来自 ETR 引脚输入的信号可以选择为上升沿或者下降沿有效\n具体的由 TIMx_SMCR的位 ETP 配置\n\n外部触发预分频器\n\n\n\n\n\n\n\n\n\n由于 ETRP 的信号的频率不能超过 TIMx_CLK（ 180M）的 1&#x2F;4，当触发信号的频率很高的情况下，就必须使用分频器来降频\n具体的由 TIMx_SMCR 的位 ETPS[1:0]配置\n\n滤波器\n\n\n\n\n\n\n\n\n\n如果 ETRP 的信号的频率过高或者混杂有高频干扰信号的，需要使用滤波器对 ETRP 信号重新采样，来达到降频或者去除高频干扰的目的\n具体的由 TIMx_SMCR 的位 ETF[3:0]配置，其中的 fDTS 是由内部时钟 CK_INT 分频得到，具体的由 TIMx_CR1 的位CKD[1:0]配置\n\n从模式选择\n\n\n\n\n\n\n\n\n\n经过滤波器滤波的信号连接到 ETRF 引脚后，触发信号成为外部时钟模式 2 的输入，最终等于 CK_PSC，然后驱动计数器 CNT 计数。\n具体的配置 TIMx_SMCR 的位 ECE 为 1即可选择外部时钟模式 2\n\n使能计数器\n\n\n\n\n\n\n\n\n\n经过上面的 5 个步骤之后， 最后我们只需使能计数器开始计数，外部时钟模式 2 的配置就算完成\n使能计数器由 TIMx_CR1 的位 CEN 配置。\n\n内部触发输入\n\n\n\n\n\n\n\n\n\n内部触发输入是使用一个定时器作为另一个定时器的预分频器。硬件上高级控制定时器和通用定时器在内部连接在一起，可以实现定时器同步或级联。\n由TIMx_SMCR 的位 TS[2:0]配置\n\n\n\n控制器\n\n\n\n\n\n\n\n\n\n控制器就是用来控制的，发送命令的\nCR1、CR2、SMCR、CCER，主要学习这几个寄存器即可。\n\n时基单元\n\n\n\n\n\n\n\n\n\n时基单元的组成\n\n\n\n\n\n\n\n\n\n16位的预分频器 PSC，PSC\n16位的计数器CNT， CNT\n8位的重复计数器RCR，RCR（高级定时器独有）\n16位的自动重装载寄存器ARR，ARR\n\n\n\n\n\n输入捕获\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n输入通道\n\n\n\n\n\n\n\n\n当使用需要被测量的信号从定时器的外部引脚 TIMx_CH1&#x2F;2&#x2F;3&#x2F;4 进入，通常叫 TI1&#x2F;2&#x2F;3&#x2F;4，在后面的捕获讲解中对于要被测量的信号我们都以 TIx 为标准叫法。\n输入滤波和边沿检测\n\n\n\n\n\n\n\n\n\n捕获通道\n\n\n\n\n\n\n\n\n\n预分频器\n\n\n\n\n\n\n\n\n\nICx 的输出信号会经过一个预分频器，用于决定发生多少个事件时进行一次捕获。\n具体的由寄存器 CCMRx 的位 ICxPSC 配置，如果希望捕获信号的每一个边沿，则不分频。\n\n捕获寄存器\n\n\n\n\n\n\n\n\n\n输出比较\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n输出比较寄存器\n\n\n\n\n\n\n\n\n\n死区发生器\n\n\n\n\n\n\n\n\n\n带死区插入的半桥驱动电路\n\n\n\n\n\n\n\n\n\n带死区插入的互补输出波形图\n\n\n\n\n\n\n\n\n\n输出控制\n\n\n\n\n\n\n\n\n\n输出引脚\n\n\n\n\n\n\n\n\n\n输入捕获的应用\n\n\n\n\n\n\n\n\n测量脉宽和频率\n\nPWM输入模式\n\n\n\n输出比较模式总共有 8 种，常用的是PWM模式。\n由寄存器 CCMRx 的位 OCxM[2:0]配置。\n\n\n\n代码\n\n\n\n\n\n\n\n\n首先我们选好脚，这里我们用高级定时器\nPWM互补输出实验，带死区时间，带刹车控制\n\n\n\n\n\n\n\n\n互补需要两个脚，死区可以软件配置，刹车还需要一个脚。我们只能用高级定时器1了，没有8\n\n\n二级标题三级标题四级标题五级标题六级标题","slug":"wifi主机/wifi主机第一部分  催眠师手札","date":"2020-08-15T10:49:36.000Z","categories_index":"单片机","tags_index":"STM32,主机","author_index":"虫子"},{"id":"305e9861f0d0a15e58206d22cf8af734","title":"硬编码","content":"硬编码\n\n\n\n\n\n\n\n\n一跃跻身神之列\n眼读远祖二进制\n同辈把玩各初代\n青年一辈领军人\n什么是硬编码\n\n\n\n\n\n\n\n\n\n指令编码(硬编码)的结构\n\n\n\n\n\n\n\n\n\n反汇编引擎(DTDebug)\n\n\n\n\n\n\n\n\n把硬编码转化成汇编，这个过程只有看说明书才能知道，比如55就是push ebp，这种功能我们就叫做反汇编引擎\n前缀指令 instruction prefixes\n\n\n\n\n\n\n\n\n\n可选的也就意味着前缀指令不是必须存在的，那么也就意味着当前cpu某些指令是前缀指令还是后面的操作码呢\n二级标题三级标题四级标题五级标题六级标题","slug":"汇编/逆魔硬编码","date":"2020-08-15T10:49:36.000Z","categories_index":"汇编","tags_index":"汇编,硬编码","author_index":"虫子"},{"id":"cc63799a1b9642350fcc7dd68903abec","title":"WIFI主机-资源存储","content":"WIFI主机\n\n\n\n\n\n\n\n\n\n常用存储器存储器种类\n\nRAM存储器\n\n\n\n\n\n\n\n\nRAM是“Random Access Memory”的缩写，被译为随机存储器。所谓“随机存取”，指的是当存储器中的消息被读取或写入时，所需要的时间与这段信息所在的位置无关。这个词的由来是因为早期计算机曾使用磁鼓作为存储器，磁鼓是顺序读写设备，而RAM可随读取其内部任意地址的数据，时间都是相同的，因此得名\n实际上现在RAM已经专门用于指代作为计算机内存的易失性半导体存储器\n根据RAM的存储机制，又分为动态随机存储器DRAM(Dynamic RAM)以及静态随机存储器SRAM(Static RAM)两种\nDRAM的存储单元结构\n动态随机存储器DRAM(Dynamic RAM)\n\n&#x3D;&#x3D;DRAM以电容的电荷来表示数据&#x3D;&#x3D;\nSRAM的存储单元结构\n静态随机存储器SRAM(Static RAM)\n\n&#x3D;&#x3D;SRAM以锁存器来存储数据&#x3D;&#x3D;\nDRAM与SRAM的特性\n\n同步&#x2F; 异步存储器\n\n\n\n\n\n\n\n\n可直接根据是否有时钟信号线区分\n同步方式\n\n异步方式\n\n常见的DRAM都采用同步方式，称为SDRAM(Synchronous DRAM)。\n常见的SRAM都采用异步方式，它们被直接称为SRAM。\n不同种类SDRAM的差异\n\nROM存储器\n\n\n\n\n\n\n\n\nROM是“Read Only Memory”的缩写，意为只能读的存储器。由于技术的发展，后来设计出了可以方便写入数据的ROM，而这个“Read Only Memory”的名称被沿用下来了，现在一般用于指代非易失性半导体存储器，包括后面介绍的FLASH存储器，有些人也把它归到ROM类里边\n\nFLASH存储器\n\n\n\n\n\n\n\n\nFLASH存储器又称为闪存，它也是可重复擦写的储器，部分书籍会把FLASH存储器称为FLASH ROM，但它的容量一般比EEPROM大得多，且在擦除时，一般以多个字节为单位。\n根据存储单元电路的不同，FLASH存储器又分为NORFLASH和NAND FLASH\n\n什么是EEPROM\n\n\n\n\n\n\n\n\n就是一个存储芯片，可以按字节进行读写操作。最常用的有AT24Cxx系列，比如AT24C64/C128\n我们用的是AT24C128，根据芯片手册描述，内存总共有131072个Bit大小，除以8就是Byte，再除1024就是KB。\n\n和Flash有什么区别\n\n\n\n\n\n\n\n\n\nEEPROM可以按“字节”擦写，而FLASH只能按“块”一大片一大片的擦写。\nEEPROM容量一般比Flash小。\n读的速度的话，应该不是两者的差别，只是EERPOM一般用于低端产品，读的速度不需要那么快，真要做的话，其实也是可以做的和FLASH差不多。\nEEPROM价格比Flash便宜，一般用于低端产品。\n\n我们产品对内存需求不大，对读写速度没太大要求，所以选用价格便宜的EEPROM。\nIIC协议简介\n\n\n\n\n\n\n\n\nI2C 通讯协议(Inter－Integrated Circuit)是由Phiilps公司开发的，由于它引脚少，硬件实现简单，可扩展性强，不需要USART、CAN等通讯协议的外部收发设备，现在被广泛地使用在系统内多个集成电路(IC)间的通讯。\nI2C物理层的特点\n\n\n\n\n\n\n\n\n\n\n它是一个支持多设备的总线。“总线”指多个设备共用的信号线。在一个I2C通讯总线中，可连接多个I2C通讯设备，支持多个通讯主机及多个通讯从机\n一个I2C总线只使用两条总线线路，一条双向串行数据线(SDA) ，一条串行时钟线 (SCL)。数据线即用来表示数据，时钟线用于数据收发同步\n每个连接到总线的设备都有一个独立的地址，主机可以利用这个地址进行不同设备之间的访问\n总线通过上拉电阻接到电源。当I2C设备空闲时，会输出高阻态，而当所有设备都空闲，都输出高阻态时，由上拉电阻把总线拉成高电平\n多个主机同时使用总线时，为了防止数据冲突，会利用仲裁方式决定由哪个设备占用总线。\n具有三种传输模式：标准模式传输速率为100kbit&#x2F;s ，快速模式为400kbit&#x2F;s ，高速模式下可达 3.4Mbit&#x2F;s，但目前大多I 2 C设备尚不支持高速模式。\n连接到相同总线的 IC 数量受到总线的最大电容 400pF 限制\n\nI2C 总线在物理连接上非常简单，分别由&#x3D;&#x3D;SDA(串行数据线)&#x3D;&#x3D;和&#x3D;&#x3D;SCL(串行时钟线)&#x3D;&#x3D;及上拉电阻组成。通信原理是通过对SCL和SDA线高低电平时序的控制，来产生I2C总线协议所需要的信号进行数据的传递。在总线空闲状态时，这两根线一般被上面所接的上拉电阻拉高，保持着高电平\nI2C的协议层\n\n\n\n\n\n\n\n\nI2C的协议定义了通讯的起始和停止信号、数据有效性、响应、仲裁、时钟同步和地址广播等环节\nI2C基本读写过程\n&#x3D;&#x3D;主机写数据到从机&#x3D;&#x3D;\n\n&#x3D;&#x3D;主机由从机中读数据&#x3D;&#x3D;\n\n&#x3D;&#x3D;通讯复合格式&#x3D;&#x3D;\n\n 通讯的起始和停止信号\n\n\n\n\n\n\n\n\n\n\n当 SCL 线是高电平时 SDA 线从高电平向低电平切换，这个情况表示通讯的起始。\n当 SCL 是高电平时 SDA 线由低电平向高电平切换，表示通讯的停止。\n起始和停止信号一般由&#x3D;&#x3D;主机&#x3D;&#x3D;产生。\n\n 数据有效性\n\n\n\n\n\n\n\n\nI2C使用SDA信号线来传输数据，使用SCL信号线进行数据同步。SDA数据线在SCL的每个时钟周期传输一位数据\n\n\nSCL为高电平的时候SDA表示的数据有效，即此时的SDA为高电平时表示数据“1”，为低电平时表示数据“0”。\n当SCL为低电平时，SDA的数据无效，一般在这个时候SDA进行电平切换，为下一次表示数据做好准备\n\n 地址及数据方向\n\n\n\n\n\n\n\n\n\nI2C总线上的每个设备都有自己的独立地址，主机发起通讯时，通过SDA信号线发送设备地址(SLAVE_ADDRESS)来查找从机。设备地址可以是7位或10位。\n紧跟设备地址的一个读写位R&#x2F;W用来表示数据传输方向，数据方向位为“1”时表示主机由从机读数据，该位为“0”时表示主机向从机写数据。\n\n\n 响应\n\n\n\n\n\n\n\n\nI2C的数据和地址传输都带响应。响应包括“应答(ACK)”和“非应答(NACK)”两种信号\n\n传输时主机产生时钟，在第9个时钟时，数据发送端会释放SDA的控制权，由数据接收端控制SDA，若SDA为高电平，表示非应答信号(NACK)，低电平表示应答信号(ACK)。\nSTM32的I2C特性及架构\n\n\n\n\n\n\n\n\n软件模拟协议：使用CPU直接控制通讯引脚的电平，产生出符合通讯协议标准的逻辑。硬件实现协议：由STM32的I2C片上外设专门负责实现I2C通讯协议，只要配置好该外设，它就会自动根据协议要求产生通讯信号，收发数据并缓存起来，CPU只要检测该外设的状态和访问数据寄存器，就能完成数据收发。这种由硬件外设处理I2C协议的方式减轻了CPU的工作，且使软件设计更加简单\nSTM32的I2C外设可用作通讯的主机及从机，支持100Kbit&#x2F;s和400Kbit&#x2F;s的速率，支持7位、10位设备地址，支持DMA数据传输，并具有数据校验功能。\n\n通讯引脚\n\n\n\n\n\n\n\n\nSTM32芯片有多个I2C外设，它们的I2C通讯信号引出到不同的GPIO引脚上\n\n时钟控制逻辑\n\n\n\n\n\n\n\n\nSCL线的时钟信号，由I 2 C接口根据时钟控制寄存器(CCR)控制，控制的参数主要为时钟频率。\n\n可选择I2C通讯的“标准&#x2F;快速”模式，这两个模式分别I2C对应100&#x2F;400Kbit&#x2F;s的通讯速率。\n在快速模式下可选择SCL时钟的占空比，可选T low &#x2F;T high &#x3D;2或T low &#x2F;T high &#x3D;16&#x2F;9模式\nCCR寄存器中12位的配置因子CCR，它与I2C外设的输入时钟源共同作用，产生SCL时钟。STM32的I2C外设输入时钟源为PCLK1\n\n&#x3D;&#x3D;计算时钟频率&#x3D;&#x3D;(了解就行，我们之后都是直接用库)\n\n数据控制逻辑\n\n\n\n\n\n\n\n\nI2C的SDA信号主要连接到数据移位寄存器上，数据移位寄存器的数据来源及目标是数据寄存器(DR)、地址寄存器(OAR)、PEC寄存器以及SDA数据线\n\n当向外发送数据的时候，数据移位寄存器以“数据寄存器”为数据源，把数据一位一位地通过SDA信号线发送出去；\n当从外部接收数据的时候，数据移位寄存器把SDA信号线采样到的数据一位一位地存储到“数据寄存器”中\n\n整体控制逻辑\n\n\n\n\n\n\n\n\n整体控制逻辑负责协调整个I2C外设，控制逻辑的工作模式根据我们配置的“控制寄存器(CR1&#x2F;CR2)”的参数而改变。\n在外设工作时，控制逻辑会根据外设的工作状态修改“状态寄存器(SR1和SR2)”，只要读取这些寄存器相关的寄存器位，就可以了解I2C的工作状态。\nSTM32 的I2C\n\n\n\n\n\n\n\n\n使用I2C外设通讯时，在通讯的不同阶段它会对“状态寄存器(SR1及SR2)”的不同数据位写入参数，通过读取这些寄存器标志来了解通讯状态。\n主发送器\n\n\n\n\n\n\n\n\n\n可使用STM32标准库函数来直接检测这些事件的复合标志，降低编程难度\n\n控制产生起始信号(S)，当发生起始信号后，它产生事件“EV5”，并会对SR1寄存器的“SB”位置1，表示起始信号已经发送\n发送设备地址并等待应答信号，若有从机应答，则产生事件“EV6”及“EV8”，这时SR1寄存器的“ADDR”位及“TXE”位被置1，ADDR 为1表示地址已经发送，TXE为1表示数据寄存器为空；\n往I2C的“数据寄存器DR”写入要发送的数据，这时TXE位会被重置0，表示数据寄存器非空，I2C外设通过SDA信号线一位位把数据发送出去后，又会产生“EV8”事件，即TXE位被置1，重复这个过程，可以发送多个字节数据；\n发送数据完成后，控制I2C设备产生一个停止信号(P)，这个时候会产生EV2事件，SR1的TXE位及BTF位都被置1，表示通讯结束\n\n主接收器\n\n\n\n\n\n\n\n\n\n\n起始信号(S)是由主机端产生的，控制发生起始信号后，它产生事件“EV5”，并会对SR1寄存器的“SB”位置1，表示起始信号已经发送；\n发送设备地址并等待应答信号，若有从机应答，则产生事件“EV6”这时SR1寄存器的“ADDR”位被置1，表示地址已经发送\n从机端接收到地址后，开始向主机端发送数据。当主机接收到这些数据后，会产生“EV7”事件，SR1寄存器的RXNE被置1，表示接收数据寄存器非空，读取该寄存器后，可对数据寄存器清空，以便接收下一次数据。此时可以控制I2C发送应答信号(ACK)或非应答信号(NACK)，若应答，则重复以上步骤接收数据，若非应答，则停止传输；\n发送非应答信号后，产生停止信号(P)，结束传输\n\nI2C初始化结构体\n\n\n\n\n\n\n\n\n\ntypedef struct\n&#123;\n  uint32_t I2C_ClockSpeed;         //设置SCL时钟频率，此值要低于40 0000        \n  uint16_t I2C_Mode;               // 指定工作模式，可选I2C模式和SMBUS模式\n  uint16_t I2C_DutyCycle;          //指定时钟占空比，可选low/high=2:1及16:9模式\n  uint16_t I2C_OwnAddress1;        // 指定自身的I2C设备地址\n  uint16_t I2C_Ack;                //使能或关闭响应(一般都要使能)\n  uint16_t I2C_AcknowledgedAddress;// 指定地址长度，可为7位或10位\n&#125;I2C_InitTypeDef;\n\n模拟IIC协议代码实战\n\n\n\n\n\n\n\n\n不是我不想硬件IIC，而是自古以来硬件IIC都有bug，所以很多公司都是软件IIC的，主要也是软件IIC移植性很高，我有时间也把硬件IIC写出来吧，硬件IIC比软件难不少\n模拟IIC就是通过我们控制单片机IO输出指定脉宽的高低电平组合去完成整个IIC的软件协议功能(时序)。STM32F103内部是带硬件IIC模块，也就是说不用自己辛苦去控制IO口完成时序，我们只需要调用他们读写的函数就可以了，至于时序怎么搞由单片机硬件IIC模块自己处理，这就是硬件IIC。那为什么硬件IIC这么方便还要用模拟的IIC？1.模拟的移植性更强，更换单片机只需要更改IO口，IIC时序部分代码基本不用改。2.据说STM32F103系列硬件IIC有问题，我是从来没用过内部硬件IIC，都是用模拟。\n我们写模拟IIC程序的思路是模块化思维，避免大量重复代码。所以我们一般会把最底层的起始时序、停止时序、应答时序和非应答时序都封装成函数方便后面字节写、页写、连续读功能代码使用\n这个代码实战需要完成的功能：写几个字节数据到EEPROM，再读出来看值是否和写进去的一样。\n功能代码实现流程\n\n\n\n\n\n\n\n\n\n配置EEPROM对应STM32引脚成普通IO口。\n完成起始时序。\n完成停止时序。\n完成应答和非应答时序。\n完成写8位数据时序。\n完成写一个字节数据功能函数。\n完成读8位数据时序。\n完成读1个字节数据功能函数\n\niic配置函数\n\n\n\n\n\n\n\n\n\n//iic配置函数\nstatic void hal_I2C_Config(void)\n&#123;\n  GPIO_InitTypeDef  GPIO_InitStructure; \n  /* Configure I2C2 pins: PB8->SCL and PB9->SDA */\n  I2C_GPIO_APBxClkCmd(I2C_GPIO_CLK, ENABLE);\n  GPIO_InitStructure.GPIO_Pin =  I2C_SCL_PIN | I2C_SDA_PIN;\n  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n  //开漏输出\n  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;  \n  GPIO_Init(I2C_SCL_PORT, &amp;GPIO_InitStructure);\n  \n  hal_I2C_SDA(1);\n  hal_I2C_SCL(1);\n&#125;\n\n 通讯的起始和停止信号\n\n\n\n\n\n\n\n\n\n//iic起始信号\nvoid I2C_Start(void)\n&#123;\n\thal_I2C_SDA(1);\n\thal_I2C_SCL(1);\n\t//延时一丢丢时间\n\tI2C_delay(1);\n\thal_I2C_SDA(0);\n\t//延时一丢丢时间\n\tI2C_delay(1);\n&#125;\n//iic停止信号\nvoid I2C_Stop(void)\n&#123;\n\thal_I2C_SCL(1);\n\thal_I2C_SDA(0);\n\t//延时一丢丢时间\n\tI2C_delay(1);\n\thal_I2C_SDA(1);\n\t//延时一丢丢时间\n\tI2C_delay(1);\n&#125;\n\n 数据有效性\n\n\n\n\n\n\n\n\n\n//iic发字节\nvoid I2C_SendByte(uint8_t SendByte) \n&#123;\n    uint8_t i=0;\n\tuint8_t temp;\n\ttemp = SendByte;\n\tfor(i=0;i&lt;8;i++)\n\t&#123;\n\t\thal_I2C_SCL(0);\n\t\tI2C_delay(1);\n\t\ttemp&amp;0x80 ? hal_I2C_SDA(1)\n\t\t          : hal_I2C_SDA(0);\n\t\tI2C_delay(1);\n\t\thal_I2C_SCL(1);\n\t\tI2C_delay(1);\n\t\ttemp&lt;&lt;=1;\n\t&#125;\n\thal_I2C_SCL(0);\n\tI2C_delay(1);\n&#125;\n\n 响应\n\n\n\n\n\n\n\n\n\n//iic数据线IO设置\nvoid hal_I2C_SDA_IO_Set(uint8_t IOMode)\n&#123;\n\tif(!IOMode)\t\t\t\t\t//输出\n\t&#123;\n\t\tGPIO_InitTypeDef  GPIO_InitStructure; \n\t\tI2C_GPIO_APBxClkCmd(I2C_GPIO_CLK, ENABLE);\n\t\tGPIO_InitStructure.GPIO_Pin = I2C_SDA_PIN;\n\t\tGPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n\t\t//开漏输出\n\t\tGPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;  \n\t\tGPIO_Init(I2C_SDA_PORT, &amp;GPIO_InitStructure);\n\t&#125;else if(IOMode)\t\t\t//输入\t\n\t&#123;\n\t\tGPIO_InitTypeDef  GPIO_InitStructure; \n\t\tI2C_GPIO_APBxClkCmd(I2C_GPIO_CLK, ENABLE);\n\t\tGPIO_InitStructure.GPIO_Pin = I2C_SDA_PIN;\n\t\tGPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n\t\t//上拉输入\n\t\tGPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;  \n\t\tGPIO_Init(I2C_SDA_PORT, &amp;GPIO_InitStructure);\n\t&#125;\n&#125;\n//iic数据线输入\nuint8_t hal_I2C_SDA_INPUT(void)\n&#123;\n\treturn GPIO_ReadInputDataBit(I2C_SDA_PORT, I2C_SDA_PIN);\t\t\n&#125;\n//iic应答\nvoid I2C_Ack(void)\n&#123;\t\n\thal_I2C_SCL(0);\n\tI2C_delay(1);\n\thal_I2C_SDA(0);\n\tI2C_delay(1);\n\thal_I2C_SCL(1);\n\tI2C_delay(1);\n\thal_I2C_SCL(0);\n\tI2C_delay(1);\n&#125;\n//iic非应答\nvoid I2C_NoAck(void)\n&#123;\t\n\thal_I2C_SCL(0);\n\tI2C_delay(1);\n\thal_I2C_SDA(1);\n\tI2C_delay(1);\n\thal_I2C_SCL(1);\n\tI2C_delay(1);\n\thal_I2C_SCL(0);\n\tI2C_delay(1);\n&#125;\n//iic等待应答\nuint8_t I2C_WaitAck(void) \t\n&#123;\n\thal_I2C_SDA(1);\n\t//SDA主机输入，控制权给接收端\n\thal_I2C_SDA_IO_Set(1);\t\t \n\thal_I2C_SCL(1);\n\tI2C_delay(1);\n\t//接收端发出高电平表示非应答\n\tif(hal_I2C_SDA_INPUT())\n\t&#123;\n\t\treturn 0;\n\t&#125;\n\thal_I2C_SCL(0);\n\t//控制权重新交给主机\n\thal_I2C_SDA_IO_Set(0);\t\t \n\tI2C_delay(1); \n\treturn 1;\n&#125;\n\n 读一个字节\n\n\n\n\n\n\n\n\n\n//读1个字节\nuint8_t I2C_ReadByte(uint16_t address)\n&#123;\n\tuint8_t dat;\n\tI2C_Start();\n\tI2C_SendByte(0xA0);\n\tI2C_WaitAck();\n\n\tI2C_SendByte((address>>8)&amp;0xFF);\n\tI2C_WaitAck();\n\n\tI2C_SendByte(address&amp;0xFF);\n\tI2C_WaitAck();\n\n\tI2C_Start();\n\tI2C_SendByte(0xA1);\n\tI2C_WaitAck();\n\t\n\tdat = I2C_ReceiveByte();\n\tI2C_NoAck();\n\tI2C_Stop();\n\treturn dat;\n&#125;\n\n 接收字节\n\n\n\n\n\n\n\n\n\n//iic接收字节\nuint8_t I2C_ReceiveByte(void)  \n&#123; \n\tuint8_t i;\n\tuint8_t ReceiveByte=0;\n\t\n\thal_I2C_SCL(0);\n\tI2C_delay(1);\n\thal_I2C_SDA(1);\n\thal_I2C_SDA_IO_Set(1);\t\t //SDA设置成输入\n\tfor(i=0; i&lt;8; i++)\n\t&#123;\n\t\tReceiveByte &lt;&lt;= 1;\n\t\tI2C_delay(1);\n\t\thal_I2C_SCL(1);\n\t\tI2C_delay(1);\n\t\tif(hal_I2C_SDA_INPUT())\n\t\t&#123;\n\t\t\tReceiveByte|=0x01;\n\t\t&#125;\n\t\thal_I2C_SCL(0);\n\t\t\n\t&#125;\n\thal_I2C_SDA_IO_Set(0);\t\t//SDA设置成输出\n\tI2C_delay(1);\n\treturn ReceiveByte;\n&#125;\n\n 字节写\n\n\n\n\n\n\n\n\n前面我们讲的都是底层传输的时序定义，时序明白以后就要封装成写一个字节这种时序的函数。\n\n//字节写\nvoid I2C_WriteByte(uint16_t address,uint8_t dat)\n&#123;\n\tI2C_Start();\n\t\n\tI2C_SendByte(0xA0);\n\tI2C_WaitAck();\n\t\n\tI2C_SendByte((address>>8)&amp;0xFF);\n\tI2C_WaitAck();\n\t\n\tI2C_SendByte(address&amp;0xFF);\n\tI2C_WaitAck();\n\t\n\tI2C_SendByte(dat);\n\tI2C_WaitAck();\n\t\n\tI2C_Stop();\t\n&#125;\n\n 页写功能\n\n\n\n\n\n\n\n\n芯片内部有256页不同分区组成，类似于我们电脑的硬盘分区。那每页的容量是64个字节。\n芯片规定一个起始信号最多只能写64个字节的数据，也就是1页，如果一次性要写64个字节以上的数据就要做翻页的功能，否则超过64个字节的数据会把数据给覆盖掉\n那翻页功能简单来说就是先判断写入的数据有多少个，如果超过64个就又重新发送起始信号，再继续往下写数据\n我们需要考虑到2种情况\n\n一次性写入的数据小于页字节\n一次性写入的数据大于页字节\n\n\n//页写函数,有自动翻页功能,24C64一页32Byte,num最大可写65523个字节\nvoid I2C_PageWrite(uint16_t address,uint8_t* pDat, uint16_t num)\n&#123;\n\tuint8_t *pBuffer,j;\n\tuint16_t len,i,page,remainder,addr,temp;\n\tpBuffer = pDat;\n\tlen = num;\t\t\n\taddr = address;\n\ttemp = 0;\n\tif(addr % EEPROM_PAGE_SIZE)\t//判断要写的地址\n\t&#123;\n\t\ttemp = EEPROM_PAGE_SIZE-(addr%EEPROM_PAGE_SIZE);\t\t\t//32-7=25 //计算出当前地址还差多少字节满1页\n\t\tif(len&lt;=temp)\n\t\t&#123;\n\t\t\ttemp = len;\n\t\t&#125;\n\t&#125;\n\t//先填满写入地址页\n\tif(temp)\n\t&#123;\n\t\tI2C_Start();\n\t\t\n\t\tI2C_SendByte(0xA0);\n\t\tI2C_WaitAck();\n\t\t\n\t\tI2C_SendByte((addr>>8)&amp;0xFF);\n\t\tI2C_WaitAck();\n\t\t\n\t\tI2C_SendByte(addr&amp;0xFF);\n\t\tI2C_WaitAck();\n\t\t\n\t\tfor(j=0; j&lt;temp; j++)\t\t \n\t\t&#123;\n\t\t\tI2C_SendByte(pBuffer[j]);\n\t\t\tI2C_WaitAck();\t\n\t\t&#125;\n\t\tI2C_Stop();\n\t\tI2C_delay(20000);\t\n\t&#125;\n\tlen -= temp;\t\t\t\n\taddr += temp;\t\t\t//地址加上已经写入的字节\n \n\tpage = len/EEPROM_PAGE_SIZE;\t\t\t\n\tremainder = len%EEPROM_PAGE_SIZE;\n\tfor(i=0; i&lt;page; i++)\t\t\n\t&#123;\n\t\tI2C_Start();\n\t\tI2C_SendByte(0xA0);\n\t\tI2C_WaitAck();\n\t\t\n\t\tI2C_SendByte((addr>>8)&amp;0xFF);\n\t\tI2C_WaitAck();\n\t\t\n\t\tI2C_SendByte(addr&amp;0xFF);\n\t\tI2C_WaitAck();\n\t\t\n\t\t\n\t\tfor(j=0;j&lt;EEPROM_PAGE_SIZE;j++)\n\t\t&#123;\n\t\t\tI2C_SendByte(pBuffer[temp+j]);\n\t\t\tI2C_WaitAck();\n\t\t&#125;\n\t\tI2C_Stop();\n\t\taddr += EEPROM_PAGE_SIZE;\n\t//\ttemp += EEPROM_PAGE_SIZE;\n\t\tI2C_delay(20000);\t\t\n\t&#125;\t\n\tif(remainder)\n\t&#123;\n\t\tI2C_Start();\n\t\tI2C_SendByte(0xA0);\n\t\tI2C_WaitAck();\n\t\t\n\t\tI2C_SendByte((addr>>8)&amp;0xFF);\n\t\tI2C_WaitAck();\n\t\t\n\t\tI2C_SendByte(addr&amp;0xFF);\n\t\tI2C_WaitAck();\n\t\t\n\t\tfor(j=0; j&lt;remainder; j++)\t\t \n\t\t&#123;\n\t\t\tI2C_SendByte(pBuffer[temp+j]);\n\t\t\tI2C_WaitAck();\t\n\t\t&#125;\n\t\tI2C_Stop();\n\t\tI2C_delay(20000);\t\t\n\t&#125;\n&#125;\n\n 连续读\n\n\n\n\n\n\n\n\n连续读功能比较简单，不需要解决翻页的问题\n\n//连续读多个字节\nvoid I2C_Read(uint16_t address,uint8_t* pBuffer, uint16_t len)\n&#123;\n\tuint16_t length;\n\tlength = len;\n\tI2C_Start();\n\tI2C_SendByte(0xA0);\n\tI2C_WaitAck();\n\n\tI2C_SendByte((address>>8)&amp;0xFF);\n\tI2C_WaitAck();\n\n\tI2C_SendByte(address&amp;0xFF);\n\tI2C_WaitAck();\n\n\tI2C_Start();\n\tI2C_SendByte(0xA1);\n\tI2C_WaitAck();\n\t\n\t//dat = I2C_ReceiveByte();\n\twhile(length)\n    &#123;\n      *pBuffer = I2C_ReceiveByte();\n      length == 1 ? I2C_NoAck()\n                  : I2C_Ack(); \n      pBuffer++;\n      length--;\n    &#125;\n\t \n\tI2C_Stop();\n\neeprom初始化\n\n\n\n\n\n\n\n\n\n//eeprom初始化\nvoid hal_eepromInit(void)\n&#123;\n\thal_I2C_Config();\n&#125;\n\nEEPROM实现探测器参数掉电保存什么是探测器\n\n\n\n\n\n\n\n\n\n探测器参数有哪些\n\n\n\n\n\n\n\n\n\n一般需要掉电保存的数据都是通过结构体的形式来定义，因为很多数据都是不同的数据类型，比如有unsignedchar类型,unsigned short类型，数组类型，枚举类型、指针类型等等。\n用结构体定义的方式更便于管理，更灵活，可读性也越强\n//支持探测器的总数量  这个取决于eeprom有多大\n#define PARA_DTC_SUM\t\t20\t\t\t\t\t\t\n\n//探测器类型\ntypedef enum\n&#123;\n\tDTC_DOOR,\t\t    //门磁探测器\n\tDTC_PIR,\t\t    //红外探测器\n\tDTC_REMOTE,\t\t\t//遥控器\n\tDTC_TYP_SUM,\n&#125;DTC_TYPE_TYPEDEF;\t    //探测器类型设置值\n\n//探测器防区类型\ntypedef enum\n&#123;\n\tZONE_TYP_24HOURS,\t//24小时警戒\t\n\tZONE_TYP_1ST,\t\t//布防警戒\n\tZONE_TYP_2ND,\t\t//在家布放警戒\n\tSTG_DEV_AT_SUM\n&#125;ZONE_TYPED_TYPEDEF;\n\n//探测器属性\ntypedef struct\n&#123;\n\tunsigned char ID;\t\t\t\t\t\t//设备ID\n\tunsigned char Mark;\t\t \t\t\t\t//0-未学习 1-已学习\n\tunsigned char NameNum;\t\t\t\t\t//名称序号\n\tunsigned char Name[16];\t\t\t\t\t//设备名称\n\tDTC_TYPE_TYPEDEF DTCType;\t\t\t\t//设备类型\n\tZONE_TYPED_TYPEDEF ZoneType;\t\t\t//防区类型\n\n\tunsigned char Code[3];\t\t\t\t\t//1527/2262  24Bit数据\n&#125;Stu_DTC;\n\nFactoryReset  出厂设置函数\n\n\n\n\n\n\n\n\n\n//出厂设置函数\nvoid FactoryReset(void)\n&#123;\n\tuint16_t i;\n\tuint8_t j;\n\t//所有传感器初始化\n\tfor(i=0; i&lt;PARA_DTC_SUM; i++)\n\t&#123;\n\t\tDTC[i].ID = 0;\n\t\tDTC[i].Mark = 0;\n\t\tDTC[i].NameNum = 0;\n\t\tfor(j=0; j&lt;16; j++)\n\t\t&#123;\n\t\t\tDTC[i].Name[i] = 0;\n\t\t&#125;\n\t\tDTC[i].DTCType = DTC_DOOR;\n\t\tDTC[i].ZoneType = ZONE_TYP_1ST;\n\t\tDTC[i].Code[0] = 0;\n\t\tDTC[i].Code[1] = 0;\n\t\tDTC[i].Code[2] = 0;\n\t&#125;\n\tCreatDtc(PARA_DTC_SUM);\n\tI2C_PageWrite(STU_DEVICEPARA_OFFSET,(uint8_t*)(&amp;DTC),sizeof(DTC));\n\tI2C_Read(STU_DEVICEPARA_OFFSET,(uint8_t*)(&amp;DTC),sizeof(DTC));\n&#125;\n\nCreatDtc  创建探测器函数\n\n\n\n\n\n\n\n\n\n//创建探测器函数\nstatic void CreatDtc(uint8_t n)\n&#123;\n\tuint8_t i,NameStrIndex,Temp,j,k;\n\tconst char str[] = \"zone-\";\n\tfor(i=0; i&lt;n; i++)\n\t&#123;\n\t\tDTC[i].ID = i+1;\n\t\tDTC[i].Mark = 1;\t\n\t\tfor(k = 0;k&lt;strlen(str);++k)\n\t\t&#123;\n\t\t\tDTC[i].Name[k]=str[k];\n\t\t&#125;\n\t\t//名称索引，就是这里的\"zone-\"后面的数字\n\t\tNameStrIndex = strlen(str);\n\t\tTemp = \ti+1;\t\n\t\tDTC[i].NameNum = Temp;\t\t\n\t\tDTC[i].Name[NameStrIndex++] = '0'+(Temp/100);\n\t\tDTC[i].Name[NameStrIndex++] = '0'+((Temp%100)/10);\n\t\tDTC[i].Name[NameStrIndex++] = '0'+((Temp%100)%10);\n\t\tfor(j=NameStrIndex; j&lt;16; j++)\n\t\t&#123;\n\t\t\t//把没用到的名字字节清零\n\t\t\tDTC[i].Name[j] = 0;\t\t\t\t\t\n\t\t&#125;\n\t\tDTC[i].DTCType = DTC_DOOR;\n\t\tDTC[i].ZoneType = ZONE_TYP_1ST;\n\t\tDTC[i].Code[0] = 0x0C;\n\t\tDTC[i].Code[1] = 0xBB;\n\t\tDTC[i].Code[2] = 0xAA;\t\t\t\n\t&#125;\n&#125;\n\nParaCheck  参数检测函数\n\n\n\n\n\n\n\n\n\n//参数检查\nstatic uint8_t ParaCheck(void)\n&#123;\n\tuint8_t i;\n\tuint8_t error = 0;\n\tif(DTC[0].ID != 1)\n\t&#123;\n\t\terror = 1;\n\t&#125;\n\tfor(i=0; i&lt;PARA_DTC_SUM; i++)\n\t&#123;\n\t\tif(DTC[i].ID >= PARA_DTC_SUM)\n\t\t&#123;\n\t\t\terror = 1;\n\t\t&#125;\n\t\tif(DTC[i].Mark > 1)\n\t\t&#123;\n\t\t\terror = 1;\n\t\t&#125;\n\t\tif(DTC[i].NameNum > PARA_DTC_SUM)\n\t\t&#123;\n\t\t\terror = 1;\n\t\t&#125;\n\t\t \n\t\tif(DTC[i].DTCType>= DTC_TYP_SUM)\n\t\t&#123;\n\t\t\terror = 1;\n\t\t&#125;\n\t\t\n\t\tif(DTC[i].ZoneType>= STG_DEV_AT_SUM)\n\t\t&#123;\n\t\t\terror = 1;\n\t\t&#125;\t\t \n\t&#125;\t\n\treturn error;\n&#125;\n\n测试\n\n\n\n\n\n\n\n\n\nDelSpecifyDtc  删除特定的探测器\n\n\n\n\n\n\n\n\n\n//删除指定的传感器\n//pDevPara - 要删除的传感器\nvoid DelSpecifyDtc(Stu_DTC *pdPara)\n&#123;\n\tuint8_t i,id;\n\tStu_DTC* pDevPara;\n\tpDevPara = pdPara;\n\tid = pDevPara->ID-1;\n\tpDevPara->ID = 0;\n\tpDevPara->Mark = 0;\n\tpDevPara->NameNum = 0;\n\tfor(i=0; i&lt;16; i++)\n\t&#123;\n\t\tpDevPara->Name[i] = 0;\n\t&#125;\n\tpDevPara->DTCType = DTC_DOOR;\n\tpDevPara->ZoneType = ZONE_TYP_1ST;\n\tpDevPara->Code[0] = 0;\n\tpDevPara->Code[1] = 0;\n\tpDevPara->Code[2] = 0;\n\t//修改设备参数\n\tI2C_PageWrite(STU_DEVICEPARA_OFFSET+id*STU_DTC_SIZE,(uint8_t*)(pDevPara),STU_DTC_SIZE); \n\tI2C_Read(STU_DEVICEPARA_OFFSET+id*STU_DTC_SIZE,(uint8_t*)&amp;DTC[id],STU_DTC_SIZE);\n&#125;\n\nGetDtcNum  获取探测器数量\n\n\n\n\n\n\n\n\n\n//获取探测器数量\n//type - 传感器类型\nuint8_t GetDtcNum(void)\n&#123;\n\tuint8_t i,num,count;\n\tcount = 0;\n\tnum = PARA_DTC_SUM;\n\tfor(i=0;i&lt;num; i++)\n\t&#123;\n\t\tif(DTC[i].Mark)\t\t\t\t//判断设备是否已学习\n\t\t&#123;\t\t\n\t\t\tcount++;\n\t\t&#125;\n\t&#125;\n\treturn count;\n&#125;\n\nAddDtc  添加探测器\n\n\n\n\n\n\n\n\n\n//传感器添加,返回探测器ID,返回0xFF则学习失败\nuint8_t AddDtc(Stu_DTC *pDevPara)\n&#123;\n\tStu_DTC DevPara;\n\tuint8_t i,j,Temp,NameStrIndex,k;\n\tconst char str[] = \"zone-\";\n\tNameStrIndex = 0;\n\tTemp = 0;\t\n\tfor(i=0; i&lt;PARA_DTC_SUM; i++)\n\t&#123;\n\t\tif(DTC[i].Mark &amp;&amp; \n\t\t(DTC[i].Code[1]==pDevPara->Code[1]) &amp;&amp;\n\t\t(DTC[i].Code[2]==pDevPara->Code[2]))\t\t\t//判断探测器是否存在\n\t\t&#123;\t\t\t\t\n\t\t\treturn (i);\t\t\t\t\t\t\t\t\t//探测器已存在，也提示配对成功\n\t\t&#125;\n\t&#125;\n\tfor(i=0; i&lt;PARA_DTC_SUM; i++)\n\t&#123;\n\t\tif(!DTC[i].Mark)\n\t\t&#123;\n\t\t\tfor(k = 0;k&lt;strlen(str);++k)\n\t\t\t&#123;\n\t\t\t\tDevPara.Name[k] = str[k];\n\t\t\t&#125;\n\t\t\tNameStrIndex = strlen(str);\n\t\t\tTemp = \ti+1;\t\t\t\t\n\t\t\tDevPara.Name[NameStrIndex++] = '0'+(Temp/100);\n\t\t\tDevPara.Name[NameStrIndex++] = '0'+((Temp%100)/10);\n\t\t\tDevPara.Name[NameStrIndex++] = '0'+((Temp%100)%10);\n\t\t\t\n\t\t\tfor(j=NameStrIndex; j&lt;16; j++)\n\t\t\t&#123;\n\t\t\t\tDevPara.Name[j] = 0;\t\t\t\t\t//把没用到的名字字节清零\n\t\t\t&#125;\n\t\t\tDevPara.ID = i+1;\n\t\t\tDevPara.Mark = 1;\n\t\t\tDevPara.NameNum = Temp;\t\t\t\n\t\t\tDevPara.DTCType = pDevPara->DTCType;\n\t\t\tDevPara.ZoneType = pDevPara->ZoneType;\t\t\t\n\t\t\tDevPara.Code[0] = pDevPara->Code[0];\n\t\t\tDevPara.Code[1] = pDevPara->Code[1];\n\t\t\tDevPara.Code[2] = pDevPara->Code[2];\n\t\t\tI2C_PageWrite(STU_DEVICEPARA_OFFSET+i*STU_DTC_SIZE,(uint8_t*)(&amp;DevPara),sizeof(DevPara)); //新设备信息写入EEPROM\n\t\t\tI2C_Read(STU_DEVICEPARA_OFFSET+i*STU_DTC_SIZE,(uint8_t*)&amp;DTC[i],STU_DTC_SIZE);\n\t\t\treturn (i);\t\t\t\t\t\t\t//学习成功，返回探测器的存储下标\n\t\t&#125;\n\t&#125;\n\treturn 0xFF;\t\t\t//学习失败\n&#125;\n\nDtcMatching  探测器匹配\n\n\n\n\n\n\n\n\n这里就是RFD匹配\n\n//RFD匹配，返回0xFF匹配失败，探测器不存在,匹配成功返回探测器ID\nuint8_t DtcMatching(uint8_t *pCode)\n&#123;\n\tuint8_t i=0;\n\tfor(i=0; i&lt;PARA_DTC_SUM; i++)\n\t&#123;\n\t\tif(DTC[i].Mark &amp;&amp; \n\t\t(DTC[i].Code[1]==pCode[1]) &amp;&amp;\n\t\t(DTC[i].Code[2]==pCode[2]))\t\t\t//判断探测器是否存在\n\t\t&#123;\t\t\t \n\t\t\treturn (DTC[i].ID);\n\t\t&#125; \n\t&#125;\n\treturn 0xFF;\n&#125;\n\nCheckPresenceofDtc  检查探测器是否存在\n\n\n\n\n\n\n\n\n\n//检查DTC是否存在，0不存在，1存在\nuint8_t CheckPresenceofDtc(uint8_t i)\n&#123;\n\tuint8_t result = 0;\n\tif(i &lt; PARA_DTC_SUM)\t//防溢出检测\n\t&#123;\n\t\tif(DTC[i].Mark)\n\t\t&#123;\n\t\t\tresult = 1;\n\t\t&#125;\n\t&#125;\t\n\treturn result;\n&#125;\n\nGetDtcID  获取探测器ID\n\n\n\n\n\n\n\n\n\n//获取指定探测器的ID,idx-探测器结构体数组下表\nuint8_t GetDtcID(uint8_t idx)\n&#123;\n\tuint8_t result = 0;\n\tif(idx &lt; PARA_DTC_SUM)\t//防溢出检测\n\t&#123;\n\t\tresult = DTC[idx].ID;\n\t&#125;\n\treturn result;\n&#125;\n\nGetDtcStu  获取探测器结构体数据\n\n\n\n\n\n\n\n\n\n//获取指定探测器的结构体数据,*pdDevPara-外部结构体指针，id-要获取的探测器ID\nvoid GetDtcStu(Stu_DTC *pdDevPara,uint8_t idx)\n&#123;\n\tuint8_t i; \n\tif(idx >= PARA_DTC_SUM)\t\t\n\t&#123;\n\t\treturn;\t\t\t//id异常\n\t&#125;\t\n\tpdDevPara->ID = DTC[idx].ID;\t\n\tpdDevPara->Mark = DTC[idx].Mark ;\n\tpdDevPara->NameNum = DTC[idx].NameNum;\t\n\tfor(i=0; i&lt;16; i++)\n\t&#123;\n\t\tpdDevPara->Name[i] = DTC[idx].Name[i];\n\t&#125;\n\tpdDevPara->DTCType = DTC[idx].DTCType;\n\tpdDevPara->ZoneType = DTC[idx].ZoneType;\t \n\tpdDevPara->Code[0] = DTC[idx].Code[0];\n\tpdDevPara->Code[1] = DTC[idx].Code[1];\n\tpdDevPara->Code[2] = DTC[idx].Code[2];\n&#125;\n\nSetDtcAbt  修改探测器属性attribute\n\n\n\n\n\n\n\n\n\n//修改探测器属性,id->指定探测器ID psDevPara->探测器属性结构体\nvoid SetDtcAbt(uint8_t id,Stu_DTC *psDevPara)\n&#123;\n\tunsigned char i;\n\tif(id >= PARA_DTC_SUM)\t\t\n\t&#123;\n\t\treturn;\t\t\t//id异常\n\t&#125;\n\tDTC[id].ID = psDevPara->ID;\n\tDTC[id].Mark = psDevPara->Mark ;\n\tDTC[id].NameNum =  psDevPara->NameNum;\n\t\n\tfor(i=0; i&lt;16; i++)\n\t&#123;\n\t\tDTC[id].Name[i] = psDevPara->Name[i];\n\t&#125;\n\tDTC[id].DTCType = psDevPara->DTCType;\n\tDTC[id].ZoneType = psDevPara->ZoneType;\n\tDTC[id].Code[0] = psDevPara->Code[0];\n\tDTC[id].Code[1] = psDevPara->Code[1];\n\tDTC[id].Code[2] = psDevPara->Code[2];\t\n\tI2C_PageWrite(STU_DEVICEPARA_OFFSET+id*STU_DTC_SIZE,(uint8_t*)psDevPara,STU_DTC_SIZE); //新设备信息写入EEPROM\n\tI2C_Read(STU_DEVICEPARA_OFFSET+id*STU_DTC_SIZE,(uint8_t*)&amp;DTC[id],STU_DTC_SIZE);\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n二级标题三级标题四级标题五级标题六级标题","slug":"wifi主机/wifi主机第七部分  资源存储地","date":"2020-08-15T10:49:36.000Z","categories_index":"单片机","tags_index":"STM32,主机","author_index":"虫子"},{"id":"a9e5c50c2e33194989c356519407f89c","title":"WIFI主机-高端技巧","content":"WIFI主机\n\n\n\n\n\n\n\n\n到了这里中断就要深入了解，定时器高端玩法。。。。\n这里我们带着一个问题去，就是玩过STC的单片机大家都是知道中断是有一个中断向量入口的，但是STM32中断函数我们是不是没有interrupt这个向量入口。那么他是如何触发中断的，我们下面就会看看中断向量表。\n中断中断简介\n\n\n\n\n\n\n\n\nSTM32 中断非常强大，每个外设都可以产生中断，&#x3D;&#x3D;异常就是中断，中断就是异常。&#x3D;&#x3D;\n中断类型\n\n\n\n\n\n\n\n\n系统异常，体现在内核水平\n外部中断，体现在外设水平\n具体看STM32F10xxx产品(小容量、中容量和大容量)的向量表&#x3D;&#x3D;(中断向量表)&#x3D;&#x3D;\n\n我们可以看到复位Reset优先级是最高的，不管其他程序怎么跑，只要一复位那边就重新运行了\nNVIC\n\n\n\n\n\n\n\n\nNVIC ：嵌套向量中断控制器，属于内核外设，管理着包括内核和片上所有外设的中断相关的功能。\n两个重要的库文件：core_cm3.h和misc.h\nNVIC寄存器简介，core_cm3.h定义\n\n中断优先级的定义\n\n\n\n\n\n\n\n\n优先级设定：NVIC-&gt;IPRx\n\n优先级分组：SCB-&gt;AIRCR:PRIGROUP[10:8]\n\n主优先级也叫着抢占优先级\n中断编程顺序\n\n\n\n\n\n\n\n\n1-使能中断请求\n2-配置中断优先级分组\n3-配置NVIC寄存器，初始化NVIC_InitTypeDef;\n4-编写中断服务函数\n\n编写中断服务函数\n\n\n\n\n\n\n\n\n这里就是我们开始需要解决的问题\n1-中断服务函数名要怎么写？写错了怎么办？\n2-中断服务函数要写在什么地方？\n\n中断服务函数的话就写在…it.c这个文件里面，方面查阅优先级\nEXTI\n\n\n\n\n\n\n\n\nEXTI：External interrupt / event controller\n外部中断&#x2F;事件控制器\nEXTI功能框图\n\nEXTI初始化结构体\n\n\n\n\n\n\n\n\n\n定时器矩阵什么是定时器矩阵\n我们在产品开发当中，经常会碰到一些不同的定时要求，比如说按键消抖，LED做一些每秒闪1次，每几秒闪几次，还有其他乱七八糟的定时需求。\n那定时器矩阵就是解决这些有不同定时需求的痛点。\nLED定时、按键定时、其他功能定时的集合就叫定时器矩阵\n定时器矩阵原理\n\n\n\n\n\n\n\n\n\n为了保证定时精确性，一般会使用单片机定时器，给定时器矩阵一个基准定时。类似于systick，比如说50us中断一次，这样能满足绝大多数定时要求。\n比如说让LED每秒闪1次，那就需要500ms改变一次LED控制引脚电平。那根据单片机定时器50us基准定时，500ms的话就需要中断500000&#x2F;50&#x3D;10000次。\n再比如说按键扫描定时需要10ms执行一次，那10000&#x2F;50&#x3D;200，单片机定时器中断200次就执行一次按键扫描。有的定时器是从程序开始运行到结束都需要循环定时的，比如说按键扫描。但有些是一次性的，比如说我想让灯亮2秒后自动熄灭，这种定时器就没必要让它一直计数浪费资源。所以，我们需要可以灵活创建，用完可删，任意定时的定时器矩阵功能。那接下来我们会把这些功能用C语言的高级技巧来封装下，让它显得更人性化，使用起来更方便。\n定时器矩阵程序实战\n\n\n\n\n\n\n\n\n\n创建一个定时器结构体\n编写定时器初始化函数 hal_timerInit\n编写创建定时器函数 hal_CreatTimer\n编写定时器中断函数 Hal_TimerHandle，把这个函数放在单片机定时器中断里\n编写定时器复位函数hal_ResetTimer\n编写其他辅助函数:  控制定时器动作函数hal_CtrlTimerAction;  删除定时器函数hal_DeleteTimer  获取定时器状态函数 hal_GetTimerState\n\n定时器初始化函数  hal_timerInit\n\n\n\n\n\n\n\n\n\n//创建定时器结构体数组\nvolatile Stu_TimerTypedef Stu_Timer[T_SUM];\n\n//现在才是我们通用定时器初始化函数\n//为了以后方便移植将GENERAL_TIM_Init名字改为hal_TimeInit\nvoid hal_TimeInit()\n&#123;\n\tuint8_t i;\n\t//通用定时器中断配置\n\tGENERAL_TIM_NVIC_Config();\n\t//通用定时器配置\n\tGENERAL_TIM_Config();\n\t//轮询定时器\n\tfor(i = 0;i&lt;T_SUM;++i)\n\t&#123;\n\t\tStu_Timer[i].state = T_STA_STOP;    //先把定时器设置为停止\n\t\tStu_Timer[i].CurrentCount = 0;      //当前计时值为0\t\n\t\tStu_Timer[i].Period = 0;            //定时周期设置0\n\t\tStu_Timer[i].func = 0;              //函数指针先指向空\n\t&#125;\n&#125;\n\n创建定时器函数 hal_CreatTimer\n\n\n\n\n\n\n\n\n\n/*******************************************************************************\n* Function Name  : hal_CreatTimer(TIMER_ID_TYPEDEF id,void (*proc)(void), unsigned short Period,unsigned char state)\n* Description    : 创建定时器 \n* Input          : - id：定时器ID\n*\t\t\t\t   - (*proc)() 函数指针 \n*\t\t\t\t   - Period 定时周期，单位50us\n* \t\t\t\t   - state 定时器初始状态\n* Output         : None\n* Return         : None\n* Attention\t\t \t : None\n*******************************************************************************/\nvoid hal_CreatTimer(TIMER_ID_TYPEDEF id,void (*proc)(void), unsigned short Period,TIMER_STATE_TYPEDEF state)\n&#123;\t\n\tStu_Timer[id].state = state;\n \n\tStu_Timer[id].CurrentCount = 0;\n\tStu_Timer[id].Period = Period;\n\tStu_Timer[id].func = proc;\n&#125;\n\n\n定时器中断函数 Hal_TimerHandle\n\n\n\n\n\n\n\n\n\n/*******************************************************************************\n* Function Name  : static void Hal_TimerHandle(void)\n* Description    : 定时器中断计时函数\n* Input          : None\n* Output         : None\n* Return         : None\n* Attention\t\t : None\n*******************************************************************************/\nstatic void Hal_TimerHandle(void)\n&#123;\n\tunsigned char i;\n\t \n\tfor(i=0; i&lt;T_SUM; i++)\n\t&#123;\n\t\tif((Stu_Timer[i].func) &amp;&amp; (Stu_Timer[i].state==T_STA_START))\n\t\t&#123;\t\n\t\t\t\tStu_Timer[i].CurrentCount++;\n\t\t\t if(Stu_Timer[i].CurrentCount >= Stu_Timer[i].Period)\n\t\t\t &#123;\n\t\t\t\t Stu_Timer[i].state = T_STA_STOP;\n\t\t\t\t Stu_Timer[i].CurrentCount = Stu_Timer[i].CurrentCount;\n\t\t\t\tStu_Timer[i].func();\n\t\t\t&#125;\n \n\t\t&#125;\n\t\t\n\t&#125;\n&#125;\n\n定时器复位函数hal_ResetTimer\n\n\n\n\n\n\n\n\n\n/*******************************************************************************\n* Function Name  : hal_ResetTimer(TIMER_ID_TYPEDEF id,TIMER_STATE_TYPEDEF sta)\n* Description    : 复位定时器状态和计时时间\n* Input          : - id：定时器ID\n*\t\t\t       - sta 定时器状态\n* Output         : None\n* Return         : None\n* Attention\t\t \t : None\n*******************************************************************************/\nTIMER_RESULT_TYPEDEF hal_ResetTimer(TIMER_ID_TYPEDEF id,TIMER_STATE_TYPEDEF sta)\n&#123;\n\tif(Stu_Timer[id].func)\t\t//判断定时器是否存在\n\t&#123;\n\t\tStu_Timer[id].state = sta;\n\t\tStu_Timer[id].CurrentCount = 0;\n\t\t \n\t\treturn T_SUCCESS;\n\t&#125;else\n\t&#123;\n\t\treturn T_FAIL;\n\t&#125;\n&#125;\n\n控制定时器动作函数hal_CtrlTimerAction\n\n\n\n\n\n\n\n\n\n/*******************************************************************************\n* Function Name  : unsigned char hal_CtrlTimerAction(TIMER_ID_TYPEDEF id,TIMER_STATE_TYPEDEF sta)\n* Description    : 控制定时器动作 \n* Input          : - id：定时器ID\n*\t\t\t\t   - sta 定时器状态\n* Output         : None\n* Return         : None\n* Attention\t\t \t : None\n*******************************************************************************/\nTIMER_RESULT_TYPEDEF hal_CtrlTimerAction(TIMER_ID_TYPEDEF id,TIMER_STATE_TYPEDEF sta)\n&#123;\n\tif(Stu_Timer[id].func)\t\t//判断定时器是否存在\n\t&#123;\n\t\tStu_Timer[id].state = sta;\n\t\treturn T_SUCCESS;\n\t&#125;else\n\t&#123;\n\t\treturn T_FAIL;\n\t&#125;\n&#125;\n\n删除定时器函数hal_DeleteTimer  \n\n\n\n\n\n\n\n\n\n/*******************************************************************************\n* Function Name  : hal_DeleteTimer(TIMER_ID_TYPEDEF id)\n* Description    : 删除定时器 \n* Input          : - id：定时器ID\n*\t\t\t\t\t\t\t\t \n* Output         : None\n* Return         : None\n* Attention\t\t \t : None\n*******************************************************************************/\nTIMER_RESULT_TYPEDEF hal_DeleteTimer(TIMER_ID_TYPEDEF id)\n&#123;\n\tif(Stu_Timer[id].func)\n\t&#123;\n\t\tStu_Timer[id].state = T_STA_STOP;\n\t \n\t\tStu_Timer[id].CurrentCount = 0;\n\t\t//Stu_Timer[id].Period = 0;\n\t\tStu_Timer[id].func = 0;\n\t\treturn T_SUCCESS;\n\t&#125;else\n\t&#123;\n\t\treturn T_FAIL;\n\t&#125;\n&#125;\n\n获取定时器状态函数 hal_GetTimerState \n\n\n\n\n\n\n\n\n\n&#x2F;*******************************************************************************\n* Function Name  : TIMER_STATE_RESULT_TYPEDEF\thal_GetTimerState(TIMER_ID_TYPEDEF id)\n* Description    : 获取定时器状态\n* Input          : - id：定时器ID\n*\t\t\t\t   - sta 定时器状态\n* Output         : None\n* Return         : None\n* Attention\t\t \t : None\n*******************************************************************************&#x2F;\nTIMER_STATE_TYPEDEF\thal_GetTimerState(TIMER_ID_TYPEDEF id)\n&#123;\n\tif(Stu_Timer[id].func)\t\t&#x2F;&#x2F;判断定时器是否存在\n\t&#123;\n\t\treturn Stu_Timer[id].state;\n\t \n\t&#125;else\n\t&#123;\n\t\treturn T_STA_INVAILD;\n\t&#125;\n&#125;\n\n定时器矩阵实战\n\n\n\n\n\n\n\n\n上面定时器矩阵代码讲解好了，就进入实战\n创建一个定时器，让LED每秒闪1次\n&#x3D;&#x3D;注意点&#x3D;&#x3D;\n\n使用前必须先创建和添加定时器。\n如果需要循环定时，定时回调函数结束后要调用hal_ResetTimer让定时器复位启动\n\n\n定时器矩阵超级大bug\n\n\n\n\n\n\n\n\n\n现在是错误代码跑出正确的现象\n\n所以我们调试一波\n\n\n 网上这种故障的类似解决\n\n\n\n\n\n\n\n\n我们平时的项目，可能会遇到死机的情况，通过在线调试，或者**消息，怎么可能会发现，怎么进入了HardFault_Handler中断呢？\n这种“硬故障”是我们常见的一种故障，导致硬故障的原因也有很多，这里针对Cortex-M3说说Fault故障相关的内容\nFault故障种类\nFault故障的种类有很多，拿本文Cortex-M3来说，主要有：\nHardFault：硬故障\nMemManager：存储器管理故障\nBusFault：总线故障\nUsageFault：用法故障\n\n\n\n硬(hard)fault\n-1\n所有被除能的fault，都将“上访”(escalation)成硬fault，只要FAULTTMASK没有置位，硬fault服务例程就被强制执行。fault被除能的原因包括被禁用，或者FAULTMASK被置位\n\n\n\nMemManager fault\n可编程\n存储器管理fault，MPU访问犯规以及访问非法位置均可引发，企图在非执行区取值也会引发此fault\n\n\n总线 fault\n可编程\n从总线系统收到了错误响应，原因可以是预取流产(Abort)或数据流产，或者企图访问协处理器\n\n\n用法(usage) fault\n可编程\n由于程序错误导致的异常，通常是使用一条无效指令，或者是非法的状态转换，例如尝试切换到ARM状态\n\n\n&#x3D;&#x3D;比如 在stm32f10x_it.c源代码中，有这样的中断入口&#x3D;&#x3D;\n/**\n  * @brief  This function handles Hard Fault exception.\n  * @param  None\n  * @retval None\n  */\nvoid HardFault_Handler(void)\n&#123;\n  /* Go to infinite loop when Hard Fault exception occurs */\n  while (1)\n  &#123;\n  &#125;\n&#125;\n\n/**\n  * @brief  This function handles Memory Manage exception.\n  * @param  None\n  * @retval None\n  */\nvoid MemManage_Handler(void)\n&#123;\n  /* Go to infinite loop when Memory Manage exception occurs */\n  while (1)\n  &#123;\n  &#125;\n&#125;\n\n/**\n  * @brief  This function handles Bus Fault exception.\n  * @param  None\n  * @retval None\n  */\n\nvoid BusFault_Handler(void)\n&#123;\n  /* Go to infinite loop when Bus Fault exception occurs */\n  while (1)\n  &#123;\n  &#125;\n&#125;\n\n/**\n  * @brief  This function handles Usage Fault exception.\n  * @param  None\n  * @retval None\n  */\nvoid UsageFault_Handler(void)\n&#123;\n  /* Go to infinite loop when Usage Fault exception occurs */\n  while (1)\n  &#123;\n  &#125;\n&#125;\n\nFault故障描述\n\n\n\n\n\n\n\n\n每一种Fault故障的产生，都肯定是有一定原因的，如果你代码产生了Fault故障中断，说明代码某些地方引起了Fault故障\n1.HardFault：硬故障\n\n\n\n\n\n\n\n\n我们发现硬故障是一种“不可编程”的故障，因为存储器管理故障，总线故障，用法故障如果不能得到执行，就上访为硬故障\n比如在取向量时产生的总线故障也按会硬件故障进行处理，所以，你会发现出现故障，很多时候都是硬故障\n&#x3D;&#x3D;硬故障状态寄存器描述&#x3D;&#x3D;\n\n\n\n位段\n名称\n类型\n复位值\n描述\n\n\n\n31\nDEBUGEVT\nR&#x2F;Wc\n0\n硬fault因调试事件而产生\n\n\n30\nFORCED\nR&#x2F;Wc\n0\n硬fault是总线fault，存储器管理fault或是用法fault上访的结果\n\n\n29:2\n-\n-\n-\n-\n\n\n1\nVECTBL\nR&#x2F;Wc\n0\n硬fault是在取向量时发生的\n\n\n0\n–\n-\n-\n-\n\n\n通过状态寄存器你会发现产生硬故障的原因有以上几种\n2.MemManager：存储器管理故障\n\n\n\n\n\n\n\n\n存储器管理故障通常与MPU(内存保护单元)有关，之前给大家分享过MPU相关的文章《什么是Cortex-M内核的MPU》\n通常就是我们说的“内存越界”就会导致存储器管理故障，细说引起该故障的诱因有：\n访问了MPU设置区域覆盖范围之外的地址\n往只读region写数据\n用户级下访问了只允许在特权下访问的地址\n存储器管理故障状态寄存器\n\n\n\n位段\n名称\n类型\n复位值\n描述\n\n\n\n7\nMMARVALID\n-\n0\n&#x3D;1时表示MMAR有效\n\n\n6:5\n-\n-\n-\n-\n\n\n4\nMSTKERR\nR&#x2F;Wc\n0\n入栈时发生错误\n\n\n3\nMUNSTKERR\nR&#x2F;Wc\n0\n出栈时发生错误\n\n\n2\n-\n-\n-\n-\n\n\n1\nDACCVIOL\nR&#x2F;Wc\n0\n数据访问违例\n\n\n0\nIACCVIOL\nR&#x2F;Wc\n0\n取指访问违例\n\n\n通过状态寄存器你会发现引起该故障的一些原因\n3.BusFault：总线故障\n\n\n\n\n\n\n\n\n总线故障，顾名思义就是对“总线”操作出现问题，导致的故障\n比如：当AHB接口上正在传送数据时，如果回复了一个错误信号(error response),则会产生总线故障\n产生中线故障的场合\n取指，通常被称作“预取流产”\n数据读&#x2F;写，通常被称为“数据流产”\n触发总线故障的动作\n中断处理起始阶段的堆栈PUSH动作，称为入栈错误\n中断处理收尾阶段的堆栈POP动作，称为出栈错误\n\n同样，通过总线故障状态寄存器了解产生的原因\n\n\n\n位段\n名称\n类型\n复位值\n描述\n\n\n\n7\nBFARVALID\n-\n0\n&#x3D;1时表示BFAR有效\n\n\n6:5\n-\n-\n-\n-\n\n\n4\nSTKERR\nR&#x2F;Wc\n0\n入栈时发生错误\n\n\n3\nUNSTKERR\nR&#x2F;Wc\n0\n出栈时发生错误\n\n\n2\nIMPRECISERR\nR&#x2F;Wc\n0\n不精确的数据访问违例(violation)\n\n\n1\nPRECISERR\nR&#x2F;Wc\n0\n精确的数据访问违例\n\n\n0\nIBUSERR\nR&#x2F;Wc\n0\n取指时的访问违例\n\n\n4.UsageFault：用法故障\n\n\n\n\n\n\n\n\n用法故障相对不常见，出现该故障通常是进行了“未对齐访问操作”，其他导致该故障问题很少见\n比如：执行了未定义的指令，除数为0(编译器都会避免)，无效的中断返回等这些情况比较少见\n用法故障状态寄存器\n\n\n\n位段\n名称\n类型\n复位值\n描述\n\n\n\n9\nDIBYZERO\nR&#x2F;Wc\n0\n表示除法运算时除数为零(只有在DIV_O_TRP置位时才会发生)\n\n\n8\nUNALIGNED\nR&#x2F;Wc\n0\n未对齐访问导致的fault\n\n\n7:4\n-\n-\n-\n-\n\n\n3\nNOCP\nR&#x2F;Wc\n0\n试图执行协处理器相关命令\n\n\n2\nINVPC\nR&#x2F;Wc\n0\n在异常返回时试图非法的加载EXC_RETURN到PC。包括非法的指令，非法的上下文以及非法的EXC_RETURN值。The return PC指向的指令试图设置PC的值(要理解此位的含义，还需学习后面的讨论中断级异常的文章)\n\n\n1\nINVSTSTE\nR&#x2F;Wc\n0\n试图切入ARM状态\n\n\n0\nUNDEFINSTR\nR&#x2F;Wc\n0\n执行的指针及其编码是未定义的–解码不能\n\n\n如何应对故障\n不知道大家平时有没有进行有效的避免，这里简单说几点应对故障的措施\n1.通过故障状态寄存器的值来判定程序错误\n在故障中断函数中，读取故障的状态(上面描述了状态寄存器)，比如硬故障\nvoid HardFault_Handler(void)\n&#123;\n    //读取装态寄存器，打印寄存器，判断什么原因引起故障\n    printf(\"状态X信息\");\n    while(1);&#123;&#125;\n&#125;\n//如果不想死机状态，可以在中断里面软复位\n\n\n\n\n\n\n\n\n\n\n2.提前对代码进行分析，预判\n比如：通过代码静态分析工具，对代码进行分析，查找bug\nLED特效\n\n\n\n\n\n\n\n\n就是我们在产品开发当中，经常会碰到一些对LED有不同闪烁效果的功能，有时候一个LED灯效果都会搞到你头疼，所以我们需要不一样的方法\n LED多种特效实现原理\n\n\n\n\n\n\n\n\n我们从另外一个角度去思考，其实可以解决很多问题，就是先思考输出波形，然后再把波形转换成数据，因为不管是单片机还是任何处理器，最终处理的肯定是数据。\n举个例子\n比如说我要控制LED灯每秒闪一次，那控制LED灯那个单片机引脚对应的波形如下\n\n那我们再举个复杂点的，让LED每隔5秒快闪2次，以此循环，那么波形如下\n\n代码实战看别人代码段思路\n\n\n\n\n\n\n\n\n\n先熟悉所实现功能\n从函数调用作为入口，我们这个程序只需要调用一个函数，然后传入要控制的设备类型，(LED还是蜂鸣器)type，然后实现的效果命令cmd，最后一个参数是否清楚队列里的命令，立即执行当下命令LedMsgInput(LED1,LED_BLINK2,1);``LedMsgInput(BUZ,LED_DARK,1);\n分析LedMsgInput函数体的代码实现\n分析其他具有连带关系的函数或者变量或者数组\n\nLedMsgInput 特效设备消息输入函数\n\n\n\n\n\n\n\n\n\n/********************************************************************************************************\n*  @函数名   LedMsgInput\t\t\t\t\t                                                           \n*  @描述     特效设备消息输入函数\t\t\t\t\t\t\t\t                                     \n*  @参数     type-特效设备   cmd-特效命令   clr-1立即执行 0稍后执行，先放到消息队列里面\n*  @返回值   无   \n*  @注意     无\n********************************************************************************************************/\nvoid LedMsgInput(unsigned char type,LED_EFFECT_TEPEDEF cmd,unsigned char clr)\n&#123;\t\n\tunsigned char  bLedCMD;\n\tif(type >= LED_SUM)\n\t&#123;\n\t\treturn;\n\t&#125;\n\tbLedCMD = cmd;\n\tif(clr)\n\t&#123;\n\t\tQueueEmpty(LedCmdBuff[type]);\n\t\tLedLoadFlag[type] = 0;\n\t\t \n\t&#125;\n\tQueueDataIn(LedCmdBuff[type],&amp;bLedCMD,1);\t\n&#125;\n\nhal_LedProc 小灯任务函数\n\n\n\n\n\n\n\n\n数据丢到消息队列里面必须还要取，我们把消息放到队列里面仅仅是数据，还没有变成特效，也就是我们还要放到任务里面\n\n但是还是没有控制led，还是一些数据处理\nvoid hal_LedProc(void)\n&#123;\n\tunsigned char i;\n\tunsigned char cmd;\n\tfor(i=0; i&lt;LED_SUM; i++)\n\t&#123;\n\t\t\n\t\tif((QueueDataLen(LedCmdBuff[i])>0) &amp;&amp; (LedLoadFlag[i]==0))\n\t\t&#123;\n\t\t\t\tQueueDataOut(LedCmdBuff[i], &amp;cmd);\n\t\t\t\tLedLoadFlag[i] = 1;\n\t\t\t\tswitch(cmd)\n\t\t\t\t&#123;\n\t\t\t\t\tcase LED_DARK:\n\t\t\t\t\t\tpLed[i] = Led_Dark;\n\t\t\t\t\t\tLedTimer[i] = *(pLed[i]+1);\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase LED_LIGHT:\n\t\t\t\t\t\tpLed[i] = Led_Light;\n\t\t\t\t\t\tLedTimer[i] = *(pLed[i]+1);\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase LED_LIGHT_100MS:\n\t\t\t\t\t\tpLed[i] = Led_Light100ms;\n\t\t\t\t\t\tLedTimer[i] = *(pLed[i]+1);\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase LED_BLINK1:\n\t\t\t\t\t\tpLed[i] = Led_Blink1;\n\t\t\t\t\t\tLedTimer[i] = *(pLed[i]+1);\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase LED_BLINK2:\n\t\t\t\t\t\tpLed[i] = Led_Blink2;\n\t\t\t\t\t\tLedTimer[i] = *(pLed[i]+1);\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase LED_BLINK3:\n\t\t\t\t\t\tpLed[i] = Led_Blink3;\n\t\t\t\t\t\tLedTimer[i] = *(pLed[i]+1);\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase LED_BLINK4:\n\t\t\t\t\t\tpLed[i] = Led_Blink4;\n\t\t\t\t\t\tLedTimer[i] = *(pLed[i]+1);\n\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:break;\t\t\t\t\t \n\t\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\nhal_LedHandle 小灯处理函数  也就是这里的特效处理\n\n\n\n\n\n\n\n\n那么我们控制在哪里处理，在自己的小灯定时器处理函数里面，到时间就控制就行\n\n//led处理函数传给定时器的函数指针\nstatic void hal_LedHandle()\n&#123;\n\tunsigned char i;\n\tfor(i=0; i&lt;LED_SUM; i++)\n\t&#123;\n\t\tif(LedTimer[i])\n\t\t&#123;\n\t\t\tLedTimer[i]--;\n\t\t&#125;\n\t\tif(!LedTimer[i])\n\t\t&#123;\n\t\t\t//定时时间到\n\t\t\t//Led_Light[] = &#123;1,10,LED_EFFECT_END&#125;;\n\t\t\tif(*(pLed[i]+2) == LED_EFFECT_END)\n\t\t\t&#123;\n\t\t\t\t\tLedLoadFlag[i] = 0;\n\t\t\t&#125;else\n\t\t\t&#123;\n\t\t\t\tpLed[i] += 2;\n\t\t\t\tif(*pLed[i] == LED_EFFECT_AGN)\n\t\t\t\t&#123;\n\t\t\t\t\t//Led_Blink1[] = &#123;1,10,0,10,LED_EFFECT_AGN,2&#125;;\n\t\t\t\t\tpLed[i] = pLed[i] - (*(pLed[i]+1) * 2);\n\t\t\t\t&#125;\n\t\t\t\tLedTimer[i] = *(pLed[i]+1);\n\t\t\t&#125;\n\t\t&#125;\n\t\thal_LedDrive[i](*pLed[i]);\n\t&#125;\n\thal_ResetTimer(T_LED,T_STA_START);\n&#125;\n\nhal_LedInit led初始化函数\n\n\n\n\n\n\n\n\n\nvoid hal_LedInit(void)\n&#123;\n\tunsigned char i;\n\thal_ledConfig();\n\thal_CreatTimer(T_LED,hal_LedHandle,200,T_STA_START);\n\t\n\tfor(i=0; i&lt;LED_SUM; i++)\n\t&#123;\n\t\tLedLoadFlag[i] = 0;\n\t\tpLed[i] = (unsigned short *)Led_Dark;\n\t\tLedTimer[i] = *(pLed[i]+1);\n\t\tQueueEmpty(LedCmdBuff[i]);\n\t&#125;\n\tLedMsgInput(LED1,LED_BLINK2,1);\n\tLedMsgInput(BUZ,LED_DARK,1);\n&#125;\n\n上面一些重要函数的补充吧\n\n\n\n\n\n\n\n\n\n模块化编程思维，LED和蜂鸣器作为硬件驱动，最好是直接通过一个函数就能控制制定的设备完成制定的效果，硬件驱动层.c文件和应用层.c文件完全可以独立，互不干扰。\n波形数据数组\n重申enum的作用\n加static关键词定义的变量或者函数代表只能在该.c文件里使用，作用就是为了增加代码可读性，很直观的看的出哪些变量或者函数是在该.c文件内部使用的，便于后期代码的分析和调试。\n\n","slug":"wifi主机/wifi主机第三部分  高端手法","date":"2020-08-15T10:49:36.000Z","categories_index":"单片机","tags_index":"STM32,主机","author_index":"虫子"},{"id":"cc1ca5f7b232d316a6eb483fac865b2d","title":"WIFI主机-打通域界","content":"WIFI主机\n\n\n\n\n\n\n\n\n现在才是产品阶段\n433M无线通讯的一些常识\n\n\n\n\n\n\n\n\n我们这个主机是防盗报警主机，所以必须要配合周边传感器形成一道防御网络，比如说门磁传感器装在大门，开门后，门磁探测器触发然后通过433MHz频段的无线发送一组数据给主机，然后主机接收到就报警。\n为什么要用无线\n因为免去了布线的麻烦，但也伴随着一些问题，比如说同频干扰，安全性等，但是综合考虑还是无线的比较适用\n为什么选用433M频率\n常用频段有非常多种，315&#x2F;433&#x2F;868,2.4G，433M成本低廉，距离远，穿墙能力强，缺点就是传输速率小，通常只适合做一些无线数据量小的产品，比如说只需要传输几个字节的。而且数据传输也是透明的，数据容易被破解，安全性比较差。但是大多数环境下都能正常使用，也有一些用Lora做的，功耗更低，但成本高些\n无线接收模块简介\n\n\n\n\n\n\n\n\n为什么要用433M无线接收模块\n数据通过无线传输，如果是发送数据就需要把单片机输出的&#x3D;&#x3D;数字信号转换成电磁波&#x3D;&#x3D;进行传播\n如果是接收数据的话，就需要把这种&#x3D;&#x3D;电磁波转换成数字信号&#x3D;&#x3D;，而接收模块就是帮你把&#x3D;&#x3D;电磁波转换成数字信号&#x3D;&#x3D;输出，用很高的性价比简化你的硬件电路，然后用单片机来把&#x3D;&#x3D;数字信号解码还原真实的数据&#x3D;&#x3D;\n\n\n我们通过433M接收模块引脚定义可以看到，最终模块处理好的数据就是通过一个DAT引脚输出的\n我们通过原理图可以看到，433M模块2,3脚其实是连在一起的，然后接到单片机PA11引脚。所以首先从硬件上可以判断出，是通过433M模块是用单口通讯来传输数据的。\n\nEV1527和2262编码\n\n\n\n\n\n\n\n\n不管是电磁波也好，还是433M接收模块输出的数字信号也好，这都只是一种传输数据的物理层媒介。就像人都能通过声音去和别人交流，但是除了有声音以外，你们语言(中文、英文)还得相同才能表达出彼此的想法\n那无线传输也是这样，有了传输渠道，那数据过去之后，双方还得有统一的数据格式，这样才能正确的还原原始数据\n而EV1527和2262就是一种无线通讯的数据格式\nEV1527和2262都有专门的芯片去实现这种数据格式，但是我们产品为了节约成本，采用软解码\nEV1527和2262数据格式\n\n\n\n\n\n\n\n\n同步头+24Bit数据+结束位\n结束位一般不解码，所以我们一般关注同步头和24Bit数据\n同步头：\n首先是&#x3D;&#x3D;4LCK&#x3D;&#x3D;的高电平脉宽，时间一般是&#x3D;&#x3D;400us&#x3D;&#x3D;，然后是&#x3D;&#x3D;124LCK&#x3D;&#x3D;低电平脉宽，时间一般是&#x3D;&#x3D;12.4ms&#x3D;&#x3D;高电平和低电平是&#x3D;&#x3D;31倍&#x3D;&#x3D;的关系\n24Bit数据定义：总共3个字节，前20位是地址码，后面4位是数据码\n比如&#x3D;&#x3D;0xAA 0xBB 0xC2&#x3D;&#x3D;AABBC是地址码，2是数据码\n地址码每个探测器唯一，相同的探测器地址码不同，数据码相同，比如说门磁开门是0x0A，关门0x0B等等。\n我们数据传输的时候，是一个个Bit这样去传输的，用不同的脉宽代表Bit”0”和Bit”1”\n\n\n\n这个时间可能不同的厂家做出来的探测器各不同，但是专业的都知道高低电平是遵循3倍的关系\n那数据位一共是需要传输3个字节，也就是24个Bit\n还有最后一个结束位，一般不解码\nEV1527和2262编码有什么区别\n\n\n\n\n\n\n\n\n两种编码方式就是地址位和数据位的区别。\nEV1527是20个Bit的地址码，4个Bit的数据码。2262是16个Bit的地址码，8个Bit的数据码。\nEV1527牺牲了数据码位数，增加了地址码位数，减少了不同设备的重复几率。\n2262牺牲了地址码位数，增加了数据码位数。\n一帧数据的波形图\n\n\n\n\n\n\n\n\n\n多帧数据的波形图\n\n\n\n\n\n\n\n\n\n做探测器的时候，一般触发一次要发15-20帧数据，根据主机来调节，理论上帧数越多主机越容易接收到，但是发的数据帧越多功耗也越大，也更占用频段，可能会干扰到其他探测器触发后发送的数据\n一般触发一次要发15-20帧数据，因为数据最终通过电磁波传播，存在太多不确定性。比如同频干扰，环境影响等等，&#x3D;&#x3D;数据从电磁波解码成数字信号&#x3D;&#x3D;到单片机的时候，前面几帧可能都是不完整的，所以你如果只发1帧甚至几帧数据的话，基本上灵敏度非常低，经常接收不到\n具体发多少帧，一般是根据主机来调节，如果主机程序写的好的话，通常15帧足以，理论上帧数越多主机越容易接收到，但是发的数据帧越多功耗也越大，也更占用频段，可能会干扰到其他探测器触发后发送的数据。\n代码实现思路\n\n\n\n\n\n\n\n\n把串行输入的编码数据帧，还原成编码之前的状态，读取其中的地址码和按键码，称之为&#x3D;&#x3D;解码&#x3D;&#x3D;。\n数据帧都是由&#x3D;&#x3D;同步头&#x3D;&#x3D;开始，然后是 &#x3D;&#x3D;24位&#x3D;&#x3D;的数据码，并且此数据帧在门磁探测器、遥控器等按键的过程中是重复出现的，我们首先要判断同步码，判断出了同步码，就知道数据码是从那一位开始了。对于一款量产的无线探测器来说，他的编码是固定值，也就是说它发射的数据帧的脉冲宽度是不变的，所以我们可以通过测量高低脉冲宽度的方式来分辨同步码、逻辑“1”、逻辑“0”\n具体的方法是这样的，首先启用定时器，定时器产生一个50us的定时中断。在中断程序中，我们读取数据输入引脚的状态，如果为高电平，就在高电平状态累加计数，反之就在低电平状态计数，当电平发生上升沿变化的时候，判断接收到的高低电平宽度的值是否符合同步信号的要求，如果符合就进入数据位的接收，以同样的方式判断逻辑“1”或逻辑“0”。如果接收过程中出现不符合要求的电平状态，就退出接收，为了增加可靠性和灵敏度，我们一般要求做容错机制，就是除了判断高低电平脉宽以外，还要算它们高低电平脉宽的倍数，把它范围适当加大，比如说&#x3D;&#x3D;实际是3倍。那我们可以设置成2-5倍&#x3D;&#x3D;，这样能最大程度满足灵敏度的需求，但是范围也不能调太广，否则会产生误报，这个都是根据产品量产验证后得来的经验和数据。\n代码实战RF解码流程：\n\n\n\n\n\n\n\n\n\n配置无线接收GPIO为输入模式\n创建50us定时器中断，并在中断函数里读取无线接收GPIO电平存起来丢进队列。\n创建一个RF解码任务，轮训任务里对电平队列里的数据进行解析\n\n解码任务数据解析流程\n\n\n\n\n\n\n\n\n\n先把队列电平&#x3D;&#x3D;数据取出&#x3D;&#x3D;，把高低电平脉宽时间都计算出来丢进&#x3D;&#x3D;脉宽队列&#x3D;&#x3D;。\n解析脉宽队列数据，开始判断同步头。\n如果同步头判断成功，则进入真正的RF数据解析，根据脉宽来判断是Bit”1”或者Bit”0”。\n连续接收到24个Bit有效数据后把数据整合成到数据里，数组大小是3个字节。\n通过回调函数把数据传递给应用层。\n\nhal_RFDConfig  RFD底层配置函数\n\n\n\n\n\n\n\n\n\n//RFD底层IO口配置函数\nstatic void hal_RFDConfig(void)\n&#123;\n\tGPIO_InitTypeDef GPIO_InitStructure;\t\n\t//开时钟\n\tRCC_APB2PeriphClockCmd(RFD_RX_GPIO_CLK, ENABLE);\n\t\n\tGPIO_InitStructure.GPIO_Pin = RFD_RX_PIN;\n\tGPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n\t//上拉输入，CPU可以随时读取IO口的电平状态，减少干扰\n\tGPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; \n\tGPIO_Init(RFD_RX_PORT, &amp;GPIO_InitStructure);\n&#125;\n\nhal_GetRFDIOSta  接收RFD io口电平状态函数\n\n\n\n\n\n\n\n\n\n//获取RFD接收IO口电平状态\nstatic uint8_t hal_GetRFDIOSta(void)\n&#123;\n\treturn (GPIO_ReadInputDataBit(RFD_RX_PORT, RFD_RX_PIN));\t\t\n&#125;\n\nhal_PulseAQT_Handle  RFD脉冲采集中断函数\n\n\n\n\n\n\n\n\n\n//RFD脉冲采集(Acquisition)，这个作为回调函数放在50us定时器中断里\nstatic void hal_PulseAQT_Handle(void)\n&#123;\n\tstatic uint8_t Temp, Count1 = 0;\n\tTemp &lt;&lt;= 1;\n\tif(hal_GetRFDIOSta()) \n\t\tTemp |= 0x01;  \n\telse \n\t\tTemp &amp;= 0xFE;\n\tif(++Count1 == 8)\n\t&#123;\n\t\tCount1 = 0;\n\t\tQueueDataPush(RFDBuff, &amp;Temp, 1);\n\t&#125;\n\thal_ResetTimer(T_RFD_RCV,T_STA_START);\n&#125;\n\nhal_RFDProc  RFD任务函数  (我写的函数中最恶心的一个)\n\n\n\n\n\n\n\n\n这个解码比较长，需要考虑容错率，大概200行，我除了红黑就他最恶心了\n所以分段讲解\n\n这里有一个细节就是我case RFD_READ_CLKLEN里面没有break，也就是脉宽计数结束后，直接进入下一个case\n\n\n//RFD任务函数\nvoid hal_RFDProc(void)\n&#123;\n\t//创建一个脉宽队列\n\tQueue256 ClkTimeBuff;\n\tstatic uint16_t Time1 = 0, Time2 = 0;\n\tstatic uint8_t ReadDataFlag = 0;\n\tstatic uint8_t Len, Code[3];\n\tstatic uint8_t CodeTempBuff[3];\n    //收码\n\tswitch(RFDRcvSteps)\n\t&#123;\t\t\t\n\t\tcase RFD_READ_CLKLEN:\n\t\t&#123;\n\t\t\tuint8_t Temp, Num;\n\t\t\tstatic uint8_t Dsta = 0;\n\t\t\tstatic uint16_t Count = 0;\n\t\t\tQueueEmpty(ClkTimeBuff);\n\t\t\twhile(QueueDataPop(RFDBuff, &amp;Temp))\n\t\t\t&#123;\n\t\t\t\t\tNum = 8;\t\t\t\t\n\t\t\t\t\twhile(Num--)\n\t\t\t\t\t&#123;\t\t\t\t\t\t\t\n\t\t\t\t\t\tif(Dsta)\n\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t//1\n\t\t\t\t\t\t\tif(!(Temp&amp;0x80))\t//这里检测电平是否为低，如果为低代表高电平脉宽结束\n\t\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t\tuint8_t Data;\n\t\t\t\t\t\t\t\tData = Count / 256;\t\t\t//存储高电平脉宽高字节\n\t\t\t\t\t\t\t\tData |= 0x80;\t\t\t\t//电平标志 1为高 0为低\n\t\t\t\t\t\t\t\tQueueDataPush(ClkTimeBuff, &amp;Data, 1);\n\t\t\t\t\t\t\t\tData = Count % 256;\t\t\t//存储高电平脉宽低字节\n\t\t\t\t\t\t\t\tQueueDataPush(ClkTimeBuff, &amp;Data, 1);\n\t\t\t\t\t\t\t\t//注意这里Data的值x50us等于脉宽时间\n\t\t\t\t\t\t\t\tDsta = 0;\n\t\t\t\t\t\t\t\tCount = 0;\n\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t&#125;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t//0\n\t\t\t\t\t\t\tif(Temp&amp;0x80)\t//这里检测电平是否为高，如果为高代表低电平脉宽结束\n\t\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t\tuint8_t Data;\n\t\t\t\t\t\t\t\tData = Count / 256;\t\t//存储低电平脉宽高字节\n\t\t\t\t\t\t\t\t//Data &amp;= 0xFF7F;\t\t//电平标志 1为高 0为低\n\t\t\t\t\t\t\t\tData &amp;= 0x7F;\t\t    //Bit7为脉宽电平标志,1为高 0为低\n\t\t\t\t\t\t\t\tQueueDataPush(ClkTimeBuff, &amp;Data, 1);\n\t\t\t\t\t\t\t\tData = Count % 256;\t\t//存储低电平脉宽低字节\n\t\t\t\t\t\t\t\tQueueDataPush(ClkTimeBuff, &amp;Data, 1);\t\n\t\t\t\t\t\t\t\t//注意这里Data的值x50us等于脉宽时间\n\t\t\t\t\t\t\t\tDsta = 1;\n\t\t\t\t\t\t\t\tCount = 0;\n\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t&#125;\n\t\t\t\t\t\tCount++;\n\t\t\t\t\t\tTemp &lt;&lt;= 1;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\tcase RFD_READ_DATA:\n\t\t&#123;\n\t\t\twhile(QueueDataSize(ClkTimeBuff))\t//判断有没波形数据\n\t\t\t&#123;   //读头\n\t\t\t\tif(!ReadDataFlag)\n\t\t\t\t&#123;\n\t\t\t\t\tunsigned char Temp;\n\t\t\t\t\twhile(!Time1 || !Time2)\n\t\t\t\t\t&#123;\t\t\t\t\t\n\t\t\t\t\t\tif(!Time1)\t\t\n\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t//获取第一个波形数据\n\t\t\t\t\t\t\twhile(QueueDataPop(ClkTimeBuff, &amp;Temp))\n\t\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t\t\t//Driver_GUART1SendByByter('*');\n\t\t\t\t\t\t\t\t\tif(Temp&amp;0x80)\t\t//先获取高电平波形\n\t\t\t\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t\t\t\t\tTemp &amp;= 0x7F;\n\t\t\t\t\t\t\t\t\t\t\tTime1 = Temp &lt;&lt; 8;\n\t\t\t\t\t\t\t\t\t\t\tQueueDataPop(ClkTimeBuff, &amp;Temp);\n\t\t\t\t\t\t\t\t\t\t\tTime1 += Temp;\n\t\t\t\t\t\t\t\t\t\t\tTime2 = 0;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\tQueueDataPop(ClkTimeBuff, &amp;Temp);\t\n\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t\tif(!QueueDataSize(ClkTimeBuff))\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t&#125;\t\t\t\t\n\t\t\t\t\t\tif(!Time2)\n\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t//获取低电平波形\n\t\t\t\t\t\t\tQueueDataPop(ClkTimeBuff, &amp;Temp);\n\t\t\t\t\t\t\tTime2 = Temp * 256;\n\t\t\t\t\t\t\tQueueDataPop(ClkTimeBuff, &amp;Temp);\n\t\t\t\t\t\t\tTime2 += Temp;\n\t\t\t\t\t\t\t//判断高电平*20时间，和高电平*44的时间\n\t\t\t\t\t\t\tif((Time2 >= (Time1*RFD_TITLE_CLK_MINL))\n\t\t\t\t\t\t\t&amp;&amp; (Time2 &lt;= (Time1*RFD_TITLE_CLK_MAXL)))\n\t\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t\tTime1 = 0;\n\t\t\t\t\t\t\t\tTime2 = 0;\n\t\t\t\t\t\t\t\tLen = 0;\n\t\t\t\t\t\t\t\tReadDataFlag = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t&#125;\t\t\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t\tTime1 = 0;\n\t\t\t\t\t\t\t\tTime2 = 0;\n\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t&#125;\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\t\n\t\t\t\t//读数据\t\t\n\t\t\t\tif(ReadDataFlag)\n\t\t\t\t&#123;\n\t\t\t\t\tunsigned char Temp;\n\t\t\n\t\t\t\t\tif(!Time1)\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tif(QueueDataPop(ClkTimeBuff, &amp;Temp))\n\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t//这里经过头验证后，第一个字节肯定是高电平，所以要&amp;0x7F把高电平标志位清除\n\t\t\t\t\t\t\t\tTemp &amp;= 0x7F;\n\t\t\t\t\t\t\t\tTime1 = Temp &lt;&lt; 8;\n\t\t\t\t\t\t\t\tQueueDataPop(ClkTimeBuff, &amp;Temp);\n\t\t\t\t\t\t\t\tTime1 += Temp;\n\t\t\t\t\t\t\t\tTime2 = 0;\n\t\t\t\t\t\t&#125;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t&#125;\t\t\t\n\t\t\t\t\tif(!Time2)\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tif(QueueDataPop(ClkTimeBuff, &amp;Temp))\n\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\tbool RecvSuccFlag;\n\t\t\t\t\t\t\tTime2 = Temp * 256;\n\t\t\t\t\t\t\tQueueDataPop(ClkTimeBuff, &amp;Temp);\n\t\t\t\t\t\t\tTime2 += Temp;\t\t\n\t\t\t\t\t\t\tif((Time1 > (Time2*RFD_DATA_CLK_MINL))  \n\t\t\t\t\t\t\t&amp;&amp; (Time1 &lt;= (Time2*RFD_DATA_CLK_MAXL)))\n\t\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t\tunsigned char i, c = 0x80;\n\t\t\t\t\t\t\t\t//'1'\n\t\t\t\t\t\t\t\tfor(i = 0; i &lt; Len%8; i++)\n\t\t\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t\t\tc >>= 1;\n\t\t\t\t\t\t\t\t\tc &amp;= 0x7F;\n\t\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t\t\tCode[Len/8] |= c;\n\t\t\t\t\t\t\t\tRecvSuccFlag = 1; \n\t\t\t\t\t\t\t&#125;\t\t\n\t\t\t\t\t\t\telse if((Time2 > (Time1*RFD_DATA_CLK_MINL))\n\t\t\t\t\t\t\t     &amp;&amp; (Time2 &lt;= (Time1*RFD_DATA_CLK_MAXL)))\n\t\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t\tunsigned char i, c = (unsigned char)0xFF7F;\n\t\t\t\t\t\t\t\t//'0'\n\t\t\t\t\t\t\t\tfor(i = 0; i &lt; Len%8; i++)\n\t\t\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t\t\tc >>= 1;\n\t\t\t\t\t\t\t\t\tc |= 0x0080;\n\t\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t\t\tCode[Len/8] &amp;= c;\n\t\t\t\t\t\t\t\tRecvSuccFlag = 1;\n\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t\t//error\n\t\t\t\t\t\t\t\tRecvSuccFlag = 0;\n\t\t\t\t\t\t\t\tReadDataFlag = 0;\n\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t\tTime1 = 0;\n\t\t\t\t\t\t\tTime2 = 0;\n\t\t\t\t\t\t\tif((++Len ==24)  &amp;&amp; RecvSuccFlag)\n\t\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t\tReadDataFlag = 0;\n\t\t\t\t\t\t\t\tif((CodeTempBuff[0]==Code[0])\n\t\t\t\t\t\t\t\t &amp;&amp;(CodeTempBuff[1]==Code[1])\n\t\t\t\t\t\t\t\t &amp;&amp;(CodeTempBuff[2]==Code[2]))\n\t\t\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t\t\tRFD_CodeHandle(Code);\n\t\t\t\t\t\t\t\t&#125;else\n\t\t\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t\t\tmemcpy(CodeTempBuff, Code, 3);\n\t\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t&#125;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\t\t\n&#125;\n\nhal_RFDDecodeFlt_Handle  RFD重复码过滤处理\n\n\n\n\n\n\n\n\n创建定时器的时候丢进去\n\n//RFD重复码过滤处理，1s内有重复码的话不做重复处理，这个作为回调函数放在1s定时器中断里\nstatic void hal_RFDDecodeFlt_Handle(void)\n&#123;\t\t \n\tRFD_DecodeFltTimerOk = 1;\n&#125;\n\nRFD_CodeHandle  RFD代码过滤函数\n\n\n\n\n\n\n\n\n不仅仅有过滤作用，还有把数据传给应用层的作用\n\n\nhal_RFCRcvCBSRegister  RFD接收回调注册函数\n\n\n\n\n\n\n\n\n\n应用层RfdRcvHandle  RFD接收回调函数\n二级标题三级标题四级标题五级标题六级标题","slug":"wifi主机/wifi主机第五部分  打通界域","date":"2020-08-15T10:49:36.000Z","categories_index":"单片机","tags_index":"STM32,主机","author_index":"虫子"},{"id":"91f6d7c8b6037035fbfa6686cc2db239","title":"WIFI主机-宗师","content":"WIFI主机\n\n\n\n\n\n\n\n\n这一篇与主机无关，完全就是瓶颈突破\nMDK的编译过程及文件类型全解\n\n\n\n\n\n\n\n\n我们已经非常熟练地使用MDK创建应用程序了，平时使用MDK编写源代码，然后编译生成机器码，再把机器码下载到STM32芯片上运行，但是这个编译、下载的过程MDK究竟做了什么工作？它编译后生成的各种文件又有什么作用？这里将对这些过程进行讲解，了解编译及下载过程有助于理解芯片的工作原理，这些知识对制作IAP(bootloader)以及读写控制器内部FLASH的应用时非常重要。\n编译过程\n\n\n\n\n\n\n\n\n这个是vs和linux那边的编译过程\n\n现在是MDK的编译过程，它与其它编译器的工作过程是类似的\n\n编译\n\n\n\n\n\n\n\n\n MDK软件使用的编译器是armcc和armasm，它们根据每个c&#x2F;c++和汇编源文件编译成对应的以“.o”为后缀名的对象文件(Object Code，也称目标文件)，其内容主要是从源文件编译得到的机器码，包含了代码、数据以及调试使用的信息\n链接\n\n\n\n\n\n\n\n\n 链接器armlink把各个.o文件及库文件链接成一个映像文件“.axf”或“.elf”\n格式转换\n\n\n\n\n\n\n\n\n一般来说Windows或Linux系统使用链接器直接生成可执行映像文件elf后，内核根据该文件的信息加载后，就可以运行程序了，但在单片机平台上，需要把该文件的内容加载到芯片上，所以还需要对链接器生成的elf映像文件利用格式转换器fromelf转换成“.bin”或“.hex”文件，交给下载器下载到芯片的FLASH或ROM中\n具体工程中的编译过程\n\n\n\n\n\n\n\n\n\n程序的组成、存储与运行\n\n\n\n\n\n\n\n\nCODE 、RO 、RW 、ZI Data 域及堆栈空间\n在工程的编译提示输出信息中有一个语句“Program Size：Code&#x3D;xx RO-data&#x3D;xx RW-data&#x3D;xx ZI-data&#x3D;xx”，它说明了程序各个域的大小，编译后，应用程序中所有具有同一性质的数据(包括代码)被归到一个域，程序在存储或运行的时候，不同的域会呈现不同的状态，这些域的意义如下\nCode\n\n\n\n\n\n\n\n\n 即代码域，它指的是编译器生成的机器指令，这些内容被存储到ROM区。\nRO-data \n\n\n\n\n\n\n\n\nRead Only data，即只读数据域，它指程序中用到的只读数据，这些数据被存储在ROM区，因而程序不能修改其内容。例如C语言中const关键字定义的变量就是典型的RO-data\nRW-data \n\n\n\n\n\n\n\n\nRead Write data，即可读写数据域，它指初始化为“非0值”的可读写数据，程序刚运行时，这些数据具有非0的初始值，且运行的时候它们会常驻在RAM区，因而应用程序可以修改其内容。例如C语言中使用定义的全局变量，且定义时赋予“非0值”给该变量进行初始化。\nZI-data \n\n\n\n\n\n\n\n\nZero Initialie data，即0初始化数据，它指初始化为“0值”的可读写数据域，它与RW-data的区别是程序刚运行时这些数据初始值全都为0，而后续运行过程与RW-data的性质一样，它们也常驻在RAM区，因而应用程序可以更改其内容。例如C语言中使用定义的全局变量，且定义时赋予“0值”给该变量进行初始化(若定义该变量时没有赋予初始值，编译器会把它当ZI-data来对待，初始化为0)；\nZI-data 的栈空间(Stack) 及堆空间(Heap) \n\n\n\n\n\n\n\n\n 在C语言中，函数内部定义的局部变量属于栈空间，进入函数的时候从向栈空间申请内存给局部变量，退出时释放局部变量，归还内存空间。而使用malloc动态分配的变量属于堆空间。在程序中的栈空间和堆空间都是属于ZI-data区域的，这些空间都会被初始值化为0值。编译器给出的ZI-data占用的空间值中包含了堆栈的大小(经实际测试，若程序中完全没有使用malloc动态申请堆空间，编译器会优化，不把堆空间计算在内)。\n\n\n\n\n\n\n\n\n\n\n\nRW-data和ZI-data它们仅仅是初始值不一样而已，为什么编译器非要把它们区分开？这就涉及到程序的存储状态了，应用程序具有静止状态和运行状态\n静止态的程序被存储在非易失存储器中，如STM32的内部FLASH，因而系统掉电后也能正常保存\n但是当程序在运行状态的时候，程序常常需要修改一些暂存数据，由于运行速度的要求，这些数据往往存放在内存中(RAM)，掉电后这些数据会丢失\n\n图中的左侧是应用程序的存储状态，右侧是运行状态，而上方是RAM存储器区域，下方是ROM存储器区域\n程序在存储状态时，RO节(RO section)及RW节都被保存在ROM区。当程序开始运行时，内核直接从ROM中读取代码，并且在执行主体代码前，会先执行一段加载代码，它把RW节数据从ROM复制到RAM， 并且在RAM加入ZI节，ZI节的数据都被初始化为0。加载完后RAM区准备完毕，正式开始执行主体程序。\n编译生成的RW-data的数据属于图中的RW节，ZI-data的数据属于图中的ZI节。是否需要掉电保存，这就是把RW-data与ZI-data区别开来的原因，因为在RAM创建数据的时候，默认值为0，但如果有的数据要求初值非0，那就需要使用ROM记录该初始值，运行时再复制到RAM\nSTM32的RO区域不需要加载到SRAM，内核直接从FLASH读取指令运行。计算机系统的应用程序运行过程很类似，不过计算机系统的程序在存储状态时位于硬盘，执行的时候甚至会把上述的RO区域(代码、只读数据)加载到内存，加快运行速度，还有虚拟内存管理单元(MMU)辅助加载数据，使得可以运行比物理内存还大的应用程序。而STM32没有MMU，所以无法支持Linux和Windows系统。\n当程序存储到STM32芯片的内部FLASH时(即ROM区)，它占用的空间是Code、RO-data及RW-data的总和，所以如果这些内容比STM32芯片的FLASH空间大，程序就无法被正常保存了。当程序在执行的时候，需要占用内部SRAM空间(即RAM区)，占用的空间包括RW-data和ZI-data。\n\n\n\n\n\n\n\n\n\n\n在MDK中，我们建立的工程一般会选择芯片型号，选择后就有确定的FLASH及SRAM大小，若代码超出了芯片的存储器的极限，编译器会提示错误，这时就需要裁剪程序了，裁剪时可针对超出的区域来优化\n编译工具链\n\n\n\n\n\n\n\n\n在前面编译过程中，MDK调用了各种编译工具，平时我们直接配置MDK，不需要学习如何使用它们，但了解它们是非常有好处的。\n若希望使用MDK编译生成bin文件的，需要在MDK中输入指令控制fromelf工具；在本章后面讲解AXF及O文件的时候，需要利用fromelf工具查看其文件信息，这都是无法直接通过MDK做到的\n设置环境变量\n\n\n\n\n\n\n\n\n调用这些编译工具，需要用到Windows的“命令行提示符工具”，为了让命令行方便地找到这些工具，我们先把工具链的目录添加到系统的环境变量中。\n添加到 路径到PATH\n\narmcc\n\n\n\n\n\n\n\n\narmcc用于把c&#x2F;c++文件编译成ARM指令代码，编译后会输出ELF格式的O文件(对象、目标文件)，在命令行中输入“armcc”回车可调用该工具，它会打印帮助说明\n\narmasm\n\n\n\n\n\n\n\n\n\narmlink\n\n\n\n\n\n\n\n\narmlink是链接器，它把各个O文件链接组合在一起生成ELF格式的AXF文件，AXF文件是可执行的，下载器把该文件中的指令代码下载到芯片后，该芯片就能运行程序了；利用armlink还可以控制程序存储到指定的ROM或RAM地址。在MDK中可在“Option for Target-&gt;Linker”页面配置armlink选项：\n\narmar\n\n\n\n\n\n\n\n\narmar工具用于把工程打包成库文件\n\nfromelf\n\n\n\n\n\n\n\n\nfromelf可根据axf文件生成hex\n\n这边就别想了，我是wintogo，这个fromelf打不开\nMDK工程的文件类型\n\n\n\n\n\n\n\n\n\n\no 、axf 及elf 文件\n\n\n\n\n\n\n\n\n.o、.elf、*.axf、*.bin及*.hex文件都存储了编译器根据源代码生成的机器码，根据应用场合的不同，它们又有所区别。\nELF是Executable and Linking Format的缩写，译为可执行链接格式，该格式用于记录目标文件的内容。在Linux及Windows系统下都有使用该格式的文件(或类似格式)用于记录应用程序的内容，告诉操作系统如何链接、加载及执行该应用程序。\n目标文件主要有如下三种类型\n&#x3D;&#x3D;可重定位的文件(Relocatable File)&#x3D;&#x3D;包含基础代码和数据，但它的代码及数据都没有指定绝对地址，因此它适合于与其他目标文件链接来创建可执行文件或者共享目标文件。 这种文件一般由编译器根据源代码生成\n例如MDK的armcc和armasm生成的*.o文件就是这一类，另外还有Linux的*.o 文件，Windows的 *.obj文件。\n&#x3D;&#x3D;可执行文件(Executable File)&#x3D;&#x3D;它包含适合于执行的程序，它内部组织的代码数据都有固定的地址(或相对于基地址的偏移)，系统可根据这些地址信息把程序加载到内存执行。这种文件一般由链接器根据可重定位文件链接而成，它主要是组织各个可重定位文件，给它们的代码及数据一一打上地址标号，固定其在程序内部的位置，链接后，程序内部各种代码及数据段不可再重定位(即不能再参与链接器的链接)。\n例如MDK的armlink生成的*.elf及*.axf文件，(使用gcc编译工具可生成*.elf文件，用armlink生成的是*.axf文件，*.axf文件在*.elf之外，增加了调试使用的信息，其余区别不大，后面我们仅讲解*.axf文件)，另外还有Linux的&#x2F;bin&#x2F;bash文件，Windows的*.exe文件\n&#x3D;&#x3D;共享目标文件(Shared Object File)&#x3D;&#x3D;它的定义比较难理解，我们直接举例，MDK生成的*.lib文件就属于共享目标文件，它可以继续参与链接，加入到可执行文件之中。另外，Linux的.so，如&#x2F;lib&#x2F; glibc-2.5.so，Windows的DLL都属于这一类\no 文件与axf文件的关系\n根据上面的分类，我们了解到，*.axf文件是由多个*.o文件链接而成的，而*.o文件由相应的源文件编译而成，一个源文件对应一个*.o文件。它们的关系如下：\n\n图中的中间代表的是armlink链接器，在它的右侧是输入链接器的*.o文件，左侧是它输出的*axf文件\n可以看到，由于都使用ELF文件格式，*.o与*.axf文件的结构是类似的，它们包含ELF文件头、程序头、节区(section)以及节区头部表。各个部分的功能说明如下：\nELF文件头用来描述整个文件的组织，例如数据的大小端格式，程序头、节区头在文件中的位置等\n程序头告诉系统如何加载程序，例如程序主体存储在本文件的哪个位置，程序的大小，程序要加载到内存什么地址等等。MDK的可重定位文件*.o不包含这部分内容，因为它还不是可执行文件，而armlink输出的*axf文件就包含该内容了\n节区是*.o文件的独立数据区域，它包含提供给链接视图使用的大量信息，如指令(Code)、数据(RO、RW、ZI-data)、符号表(函数、变量名等)、重定位信息等，例如每个由C语言定义的函数在*.o文件中都会有一个独立的节区\n存储在最后的节区头则包含了本文件节区的信息，如节区名称、大小等等\n总的来说，链接器把各个*.o文件的节区归类、排列，根据目标器件的情况编排地址生成输出，汇总到*.axf文件\n例如：“wifi主机”工程中在“bsp_led.c”文件中有一个LED_GPIO_Config函数，而它内部调用了“stm32f10x_gpio.c”的GPIO_Init函数，经过armcc编译后，LED_GPIO_Config及GPIO_Iint函数都成了指令代码，分别存储在bsp_led.o及stm32f10x_gpio.o文件中，这些指令在*.o文件都没有指定地址，仅包含了内容、大小以及调用的链接信息，而经过链接器后，链接器给它们都分配了特定的地址，并且把地址根据调用指向链接起来。\n\nELF 文件头\n\n\n\n\n\n\n\n\n接下来可以看看具体文件的内容，使用fromelf文件可以查看*.o、*.axf及*.lib文件的ELF信息。使用命令行，切换到文件所在的目录，输入“fromelf –text –vbsp_led.o”命令，可控制输出bsp_led.o的详细信息，利用“-c、-z”等选项还可输出反汇编指令文件、代码及数据文件等信息，可亲手尝试一下\n5集向后重新二级标题三级标题四级标题五级标题六级标题","slug":"wifi主机/wifi主机第九部分  宗师一方","date":"2020-08-15T10:49:36.000Z","categories_index":"单片机","tags_index":"STM32,主机","author_index":"虫子"},{"id":"9408b3862e11e4a86797ea35062d7f6a","title":"WIFI主机-轻量内核","content":"WIFI主机\n\n\n\n\n\n\n\n\n这篇是自己写的轻量级内核移植，之前的我都是裸机开发，不咋地，现在被内核深深的吸引。\n为什么要学习程序架构1.提高程序的稳定性\n\n\n\n\n\n\n\n\n我们在做产品就像建房子，一定要把”地基”打好，当然地基包括软件和硬件部分，硬件没问题的情况下，一个好的程序架构就是一个好的”地基”\n在好的架构基础上，我们能轻松地实现那些让人很头痛的功能，不然程序一复杂，你会发现有很多功能上的冲突，最后导致代码重写，非常蛋疼\n2.轻松解决产品开发当中常见痛点\n\n\n\n\n\n\n\n\n比如说有几个按键、需要实现短按、短按释放、长按、长按释放功能。比如说有几个LED灯，要实现多种闪烁效果，比如说隔2秒闪1次，隔5秒闪3次等等。比如说有大量串口数据收发，如何实现不丢一个字节？\n\n\n\n\n\n\n\n\n\n总之一句话：写复杂的产品程序，一定要有好的程序架构做支撑！就像用ucos，rtos系统，其实就是解决你程序架构的问题。\n内核移植\n\n\n\n\n\n\n\n\n移植流程\n\n拷贝OS_System.c和OS_Sysem.h文件到工程目录并添加到keil工程里\n把void OS_ClockInterruptHandle(void)放在stm32的systick 10ms秒中断函数里，为系统提供一个时钟节拍基准。\n调用OS_CPUInterruptCBSRegister(CPUInterrupt_CallBack_t pCPUInterruptCtrlCBS)函数，传入开关stm32总中断控制函数。\n\n\n\n上面唯一需要注意的是就是要注意编写单片机总中断函数\n开关中断在操作系统里一般称为&#x3D;&#x3D;临界&#x3D;&#x3D;，作用就是防止操作数据的时候，数据被意外改变导致不可预知的BUG,我们单片机程序在跑的时候，可能会被中断打断，然后先去执行中断里的程序。在执行中断里的程序的时候又可能会被优先级更高的中断打断，这个时候又去执行优先级更高的中断程序了。如果这3个地方都有对同一个指针或者变量进行操作，就很有可能出现不可预知的问题。而程序大了以后，这种情况又是难免的。\n创建任务，测试移植是否成功\n\n\n\n\n\n\n\n\n计算机永远第一步是打印hello world,而我们嵌入式永远的第一步就是点灯\n我们这里测试的是每2秒LED_WIFI反转一下\n那么我们就需要创建任务了\n\n系统执行流程\n\n系统任务结构体OS_TaskTypeDef\n任务初始化函数OS_TaskInit\n任务创建函数OS_CreatTask\n任务调度函数OS_ClockInterruptHandle\n开始任务函数OS_Start\n\n\n\n\n\n\n\n\n\n\n我们通过板子小灯已经发现我们移植成功了\n这个程序架构内核最大的作用：\n\n\n\n\n\n\n\n\n1.能为每个任务分配单独的执行频率，一般都是10ms，最小也是10ms，当然可根据需要改成1ms。这样的话一些不需要经常执行的任务，就可以把调度时间调长一点，释放CPU的资源。这里的任务指的就是函数，比如说Led处理函数，按键处理函数，RFD解码函数等等。\n2.提供了产品开发当中常用的算法：队列。\n内核队列队列的作用\n\n\n\n\n\n\n\n\n队列简单来说就是开辟一个数组(内存空间)，然后有一个队列头指针pHead和一个队列尾指针pTail。\n杭哥是链表讲队列的，我们这边用数组\n为什么一个数组存储要搞这么复杂？目的是为了设定一个数据存储和读取规则，数据在这个数组里面遵循先进先出的规则，不能插队。\n这样做最大的好处就是，数据不会丢失\n比如说我们做串口通讯的时候，通常是一帧数据过来，然后在串口中断里接收数据，同时在while(1)循环里解析和处理数据\n这种方式可能会出现一个问题，就是while(1)循环里的串口数据还没解析完，又有一帧新的数据过来，那老的数据就会被覆盖掉(这就是”插队”)，这个时候队列就发挥作用了。\n串口中断直接把接收的字节数据都丢进队列里，while(1)不断从队列里取数据，只要队列够大，基本不存在丢包和插队的问题。\n队列清空函数\n\n\n\n\n\n\n\n\n\n/********************************************************************************************************\n*  @函数名   S_QueueEmpty\n*  @描述     清空一个队列\n*  @参数     Head-队列头地址,  Tail-队列尾地址,   HBuff-队列缓存数组首地址\n*  @返回值   无\n*  @注意    无\n********************************************************************************************************/\nvoid S_QueueEmpty(unsigned char** Head, unsigned char** Tail, unsigned char* HBuff)\n&#123;\n\t*Head = HBuff;\n\t*Tail = HBuff;\n&#125;\n\n入队函数\n\n\n\n\n\n\n\n\n\n/********************************************************************************************************\n*  @函数名   S_QueueDataIn\n*  @描述     输入一个字节数据进队列\n*  @参数     Head-队列头地址,  Tail-队列尾地址,   HBuff-队列缓存数组首地址  Size-对列大小\n*            HData-入队的数据首地址      DataSize-入队数据的大小\n*  @返回值   无\n*  @注意     无\n********************************************************************************************************/\nvoid S_QueueDataPush(unsigned char** Head, unsigned char** Tail, unsigned char* HBuff, unsigned short Size, unsigned char* HData, unsigned short DataSize)\n&#123;\n\tunsigned short num;\n\tunsigned char IptStatus;\t\n\tfor (num = 0; num &lt; DataSize; num++, HData++)\n\t&#123;\n\t\t**Tail = *HData;\n\t\t(*Tail)++;\n\t\tif (*Tail == HBuff + Size)\n\t\t\t*Tail = HBuff;\n\t\tif (*Tail == *Head)\n\t\t&#123;\n\t\t\tif (++(*Head) == HBuff + Size)\n\t\t\t\t*Head = HBuff;\n\t\t&#125;\n\t&#125;\n&#125;\n\n出队函数\n\n\n\n\n\n\n\n\n\n/********************************************************************************************************\n*  @函数名   S_QueueDataPop\n*  @描述     从队列里取出一个数据\n*  @参数     Head-队列头地址,  Tail-队列尾地址,   HBuff-队列缓存   Size-对列大小   Data-出队数据指针\n*  @返回值   取出的数据\n*  @注意     无\n********************************************************************************************************/\nunsigned char S_QueueDataPop(unsigned char** Head, unsigned char** Tail, unsigned char* HBuff, unsigned short Size, unsigned char* Data)\n&#123;\n\tunsigned char back = 0;\n\tunsigned char IptStatus;\n\t\n\t*Data = 0;\n\tif (*Tail != *Head)\n\t&#123;\n\t\t*Data = **Head;\n\t\tback = 1;\n\t\tif (++(*Head) == HBuff + Size)\n\t\t\t*Head = HBuff;\n\t&#125;\n    \n\treturn back;\n&#125;\n\n队长函数\n\n\n\n\n\n\n\n\n\n/********************************************************************************************************\n*  @函数名   S_QueueDataSize\n*  @描述     判断队列里数据的长度\n*  @参数     Head-队列头地址,  Tail-队列尾地址,   Size-对列长度\n*  @返回值   队列里有数据个数\n*  @注意     无\n********************************************************************************************************/\nunsigned short S_QueueDataSize(unsigned char** Head, unsigned char** Tail, unsigned short Size)\n&#123;\n\tif (*Tail > *Head)\n\t\treturn *Tail - *Head;\n\tif (*Tail &lt; *Head)\n\t\treturn *Tail + Size - *Head;\n\treturn 0;\n&#125;\n\n宏函数\n\n\n\n\n\n\n\n\n\n#define QueueEmpty(x)\t         S_QueueEmpty((unsigned char**)&amp;(x).Head,(unsigned char**)&amp;(x).Tail,(unsigned char*)(x).Buff) \n#define QueueDataPush(x,y,z)     S_QueueDataPush((unsigned char**)&amp;(x).Head,(unsigned char**)&amp;(x).Tail,(unsigned char*)(x).Buff,sizeof((x).Buff),(y),(z))\n#define QueueDataPop(x,y)        S_QueueDataPop((unsigned char**)&amp;(x).Head,(unsigned char**)&amp;(x).Tail,(unsigned char*)(x).Buff,sizeof((x).Buff),(y)) \n#define QueueDataSize(x)\t     S_QueueDataSize((unsigned char**)&amp;(x).Head,(unsigned char**)&amp;(x).Tail,sizeof((x).Buff))  \n\n\n现在在keil里面测试\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n到现在就可以结束了，这个内核仅仅只有百分之10的功能，灵活度也不怎么高，以后试试内存管理，要是这个添加进去了就会有量的改变。好期待呀。\n二级标题三级标题四级标题五级标题六级标题","slug":"wifi主机/wifi主机第二部分  自建轻量内核","date":"2020-08-15T10:49:36.000Z","categories_index":"单片机","tags_index":"STM32,主机","author_index":"虫子"},{"id":"bc733f0dd5782bf3825c926b0df036f7","title":"WIFI主机-波形创建","content":"WIFI主机报警电路原理分析\n\n\n\n\n\n\n\n\n\nPA0引脚为普通IO口功能，输出低电平芯片工作，输出高电平，芯片不工作。(输出低电平三极管截止，那么CTRL就会被拉高)PB4作为复用功能，用于PWM输出从而驱动喇叭发出声音。\nPB4对应定时器3的CH1(通道1)。\n\n可以看出TIM3_CH1是重定义功能\n什么是PWM？单片机怎么输出PWM？\n\n\n\n\n\n\n\n\nPWM就是输出脉宽（即占空比）可调的方波信号。\n\n有些单片机内部的定时器有PWM输出功能，只需简单配置就能让相应的IO口输出不同频率的PWM。\n想输出一个PWM，必须知道几个关键参数：\n\n周期ARR\n占空比CCR\n计数器CNT\n\n当CNT的值小于CCR的时候，引脚输出高电平。当CNT的值大于CCR的时候，引脚输出低电平。当CNT的值等于ARR的时候，CNT重新初始化为0\n\n喇叭工作原理\n\n\n\n\n\n\n\n\n喇叭这个东西算是一个行业，所以对于开发者使用来说，正确的做法是只需要知道无源的喇叭一般是通过PWM来控制它发出声音就可以了，频率一般在2-4KHZ，不同的频率发出不同的音调。\n而报警声就是在不同的时间控制不同的频率，实现音调快速不断地切换来发出不同的声音组合，而什么样的音调组合能够发出制定的音乐又是一个新的行业。\nSTM32用定时器3实现频率可调PWM输出\n\n\n\n\n\n\n\n\nTIMx-&gt;ARR\n定时周期，也就是我们PWM的频率或者周期。\nTIMx-&gt;PSC\n预分频器，时钟源经该预分频器才是定时器计数时钟 CK_CNT，它设定 PSC 寄存器的值。计算公式为：计数器时钟频率 (fCK_CNT) 等于 fCK_PSC &#x2F; (PSC[15:0] + 1)，可实现 1 至 65536 分频。如果我们系统时钟是72M，那把PSC设置成71，最终计数器时钟就是1M，也就是1us。\nTIMx-&gt;CCR1\n脉冲宽度，用来调节PWM占空比用的，计数器CNT会与这个寄存器的值进行对比，然后控制引脚输出高电平或者低电平来实现PWM功能\n代码Beep配置\n\n\n\n\n\n\n\n\n\n//BEEP定时器和普通口配置\nstatic void hal_BEEP_TIM_Config(void)\n&#123;\n\tGPIO_InitTypeDef GPIO_InitStructure;\n\n    //输出比较通道 GPIO 初始化\n\t//先开时钟\n\tRCC_APB2PeriphClockCmd(BEEP_TIM_CH1_GPIO_CLK | RCC_APB2Periph_AFIO, ENABLE);\n    //调试复位口引脚重映射配置  把这个功能关掉\n\tGPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE);\n\t\n\tGPIO_InitStructure.GPIO_Pin =  BEEP_TIM_CH1_PIN;\n\t//复用推挽  CH1的PWM脉冲波形\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n    GPIO_Init(BEEP_TIM_CH1_PORT, &amp;GPIO_InitStructure);\n\n    //beep控制口初始化\n\t//先开时钟\n\tBEEP_EN_APBxClock_FUN(BEEP_EN_GPIO_CLK, ENABLE);\n\t\n\tGPIO_InitStructure.GPIO_Pin =  BEEP_EN_PIN;\n\t//开漏\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n    GPIO_Init(BEEP_EN_PORT, &amp;GPIO_InitStructure);\n\t\n\t/*--------------------时基结构体初始化-------------------------*/\n    // 开启定时器时钟,我们这里内部时钟CK_INT=72M\n    BEEP_TIM_APBxClock_FUN(BEEP_TIM_CLK,ENABLE);\n\t//Timer3部分重映射  TIM3_CH1->PB4 把这个开下来\n\tGPIO_PinRemapConfig(GPIO_PartialRemap_TIM3, ENABLE); \n\t//决定时钟频率\n\tTIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;\n\t// 自动重装载寄存器的值，累计TIM_Period+1个频率后产生一个更新或者中断\n\t//配置自动重装载寄存器arr，决定的是信号的周期,计多少个数\n\tTIM_TimeBaseStructure.TIM_Period=BEEP_TIM_PERIOD;\t\n\t// 驱动CNT计数器的时钟 = Fck_int/(psc+1)\n\t//分频器决定的是计数器记一次的时间\n\tTIM_TimeBaseStructure.TIM_Prescaler= BEEP_TIM_PSC;\t\n\t// 时钟分频因子 ，配置死区时间时需要用到，我们这边不是控制电机，默认0\n\tTIM_TimeBaseStructure.TIM_ClockDivision=TIM_CKD_DIV1;\t\t\n\t// 计数器计数模式，设置为向上计数\n\tTIM_TimeBaseStructure.TIM_CounterMode=TIM_CounterMode_Up;\t\t\n\t// 重复计数器的值，没用到不用管  高级定时器才有，我们这里实际上没用到\n\tTIM_TimeBaseStructure.TIM_RepetitionCounter=0;\t\n\t// 初始化定时器\n\tTIM_TimeBaseInit(BEEP_TIM, &amp;TIM_TimeBaseStructure);\n\t\n\t/*--------------------输出比较结构体初始化-------------------*/\t\t\n    //决定占空比\n\tTIM_OCInitTypeDef  TIM_OCInitStructure;\n\t// 配置为PWM模式1 选择定时器模式:TIM脉冲宽度调制模式2\n\tTIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;\n\t// 输出使能\n\tTIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;\n\t// 互补输出使能  只有高级定时器才有，我们这里关闭即可\n\tTIM_OCInitStructure.TIM_OutputNState = TIM_OutputNState_Disable; \n\t// 设置占空比大小\n\tTIM_OCInitStructure.TIM_Pulse = BEEP_TIM_PULSE;\n\t// 输出通道电平极性配置，通道是否有效是通过极性配置的\n\tTIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;\n\t// 互补输出通道电平极性配置  没有互补通道这里无所谓\n\tTIM_OCInitStructure.TIM_OCNPolarity = TIM_OCNPolarity_High;\n\t// 输出通道空闲电平状态配置\n\tTIM_OCInitStructure.TIM_OCIdleState = TIM_OCIdleState_Set;\n\t// 互补输出通道空闲电平状态配置  这个只有高级定时器有  我们这无所谓\n\tTIM_OCInitStructure.TIM_OCNIdleState = TIM_OCNIdleState_Reset;\n\t//根据T指定的参数初始化外设TIM3 OC1\n\tTIM_OC1Init(BEEP_TIM, &amp;TIM_OCInitStructure);\n\t//使能TIM3在CCR1上的预装载寄存器\n\tTIM_OC1PreloadConfig(BEEP_TIM, TIM_OCPreload_Enable);\n\t\n\t\n\t//使能TIM3\n\tTIM_Cmd(BEEP_TIM, ENABLE);  \n&#125;\n\nhal_BeepPwmCtrl  喇叭pwm控制函数\n\n\n\n\n\n\n\n\n\n//喇叭PWM控制\nvoid hal_BeepPwmCtrl(uint8_t cmd)\n&#123; \n\t//1把控制脚拉低就会工作，0把控制脚拉高就会不工作\n\tcmd ? GPIO_ResetBits(BEEP_EN_PORT,BEEP_EN_PIN)\n\t    : GPIO_SetBits(BEEP_EN_PORT,BEEP_EN_PIN);\n&#125;\n\nhal_BeepPwmHandle  喇叭pwm中断函数\n\n\n\n\n\n\n\n\n\n//喇叭中断函数\nstatic void hal_BeepPwmHandle(void)\n&#123;\n\tstatic uint8_t i=0;\n\t//hal_SetBeepFreq(NoteFreqAry[i]);\n\t//改变ARR的值来改变周期\n\tTIM_SetAutoreload(TIM3,NoteFreqAry[i]);\n\t//改变CRR的值来改变占空比(我们这里一直都用周期的一半)\n\tTIM_SetCompare1(TIM3,NoteFreqAry[i]/2);\n\t//计数器清零\n\tTIM_SetCounter(TIM3,0);\n\t//6ms换一个频率\n\ti++;\n\tif(i>BP_num)\n\t&#123;\n\t\ti=0;\n\t&#125;\n\t//不要忘了重启定时器\n\thal_ResetTimer(T_BEEP,T_STA_START);\n&#125;   \n\nhal_BeepInit  喇叭初始化函数\n\n\n\n\n\n\n\n\n\n//喇叭初始化\nvoid hal_BeepInit(void)\n&#123;\n\thal_BEEP_TIM_Config();\n\t//创建一个喇叭定时器 50us*120=6ms\n\thal_CreatTimer(T_BEEP,hal_BeepPwmHandle,120,T_STA_START);\n\t//让喇叭芯片可以工作\n\thal_BeepPwmCtrl(1);\n&#125;\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n二级标题三级标题四级标题五级标题六级标题","slug":"wifi主机/wifi主机第八部分  波形创建者","date":"2020-08-15T10:49:36.000Z","categories_index":"单片机","tags_index":"STM32,主机","author_index":"虫子"},{"id":"f9f001f09edb1b9283e01c9882734988","title":"WIFI主机-高级","content":"WIFI主机\n\n\n\n\n\n\n\n\n我们c8t6有三个串口，但是用就用到了1,2\n\n通信的基本概念\n\n\n\n\n\n\n\n\n在计算机的设备与设备之间或集成电路之间常常需要进行数据传输\n并行与串行\n\n\n\n\n\n\n\n\n\n \n全双工、半双工和单工\n\n\n\n\n\n\n\n\n\n同步与异步\n\n\n\n\n\n\n\n\n\n有时钟线的基本都是同步\n\n没时钟线的基本都是异步\n在同步通讯中，数据信号所传输的内容绝大部分就是有效数据，而异步通讯中会包含有帧的各种标识符，所以同步通讯的效率更高，但是同步通讯双方的时钟允许误差较小，而异步通讯不需要时钟。\n通信的速率\n\n\n\n\n\n\n\n\nBitrate—比特率每秒钟传输的二进制位数，单位为比特每秒(bit&#x2F;s)\nBaudrate—波特率表示每秒钟传输的码元个数\n&#x3D;&#x3D;一个二进制位表示一个码元&#x3D;&#x3D;\n\n0V    ——   0 \n3.3V  ——    1\n\n&#x3D;&#x3D;两个二进制位表示一个码元&#x3D;&#x3D;\n\n0V  ——  00 \n2V  ——  01\n4V  ——  10\n6V  ——  11\n\n串口通信协议简介\n\n\n\n\n\n\n\n\n物理层规定通讯系统中具有机械、电子功能部分的特性，确保原始数据在物理媒体的传输。其实就是硬件部分。\n协议层协议层主要规定通讯逻辑，统一收发双方的数据打包、解包标准。其实就是软件部分。\n\n简单来说物理层规定我们用嘴巴还是用肢体来交流，\n协议层则规定我们用中文还是英文来交流。\n\n物理层3个串口通信的常用标准\n\n\n\n\n\n\n\n\n\nRS232标准\nUSB转串口  TTL标准\n原生的串口到串口  TTL-&gt;TTL\n\nRS-232 与 TTL 电平区别\n\n\n\n\n\n\n\n\n\n我们通常说的TTL电平是从单片机或芯片里面出来的\nRS232标准串口通讯结构图\n\n\n\n\n\n\n\n\n\n\nRS232标准串口主要用于工业设备直接通信\n电平转换芯片一般有MAX3232，SP3232\n\n\nDB9 标准的公头及母头接法\nUSB转串口通讯结构图\n\n\n\n\n\n\n\n\n\n\nUSB转串口主要用于设备跟电脑通信\n电平转换芯片一般有CH340、PL2303、CP2102、FT232\n使用的时候电脑端需要安装电平转换芯片的驱动\n\n原生的串口到串口\n\n\n\n\n\n\n\n\n\n\n原生的串口通信主要是控制器跟串口的设备或者传感器通信，不需要经过电平转换芯片来转换电平，直接就用TTL电平通信\nGPS模块、GSM模块、串口转WIFI模块、HC04蓝牙模块\n\n串口数据包的基本组成\n\n\n\n\n\n\n\n\n\n起始位：由1个逻辑 0 的数据位表示\n结束位：由 0.5、 1、 1.5 或 2 个逻辑 1 的数据位表示\n有效数据：在起始位后紧接着的就是有效数据，有效数据的长度常被约定为 5、 6、 7 或 8 位长\n校验位：可选，为的是数据的抗干扰性。\n校验方法分为：\n\n奇校验(odd)\n偶校验(even) \n0 校验(space)\n校验(mark)\n无校验(noparity)\n\n奇校验(odd) ：有效数据和校验位中“ 1”的个数为奇数\n比如一个 8 位长的有效数据为： 01101001，此时总共有 4 个“ 1”，为达到奇校验效果，校验位为“ 1”，最后传输的数据将是 8 位的有效数据加上 1 位的校验位总共 9 位\n偶校验(even) ：有效数据和校验位中“ 1”的个数为偶数\n比如一个 8 位长的有效数据为： 01101001，此时总共有 4 个“ 1”，为达到偶校验效果，校验位为“ 0”，最后传输的数据将是 8 位的有效数据加上 1 位的校验位总共 9 位\n0 校验是不管有效数据中的内容是什么，校验位总为“ 0”。\n1 校验是校验位总为“ 1”。\n无校验就是数据包中不包含校验位\n串口功能框图\n\n\n\n\n\n\n\n\n\nTX：数据发送\nRX：是数据接收\nSCLK：时钟，仅同步通信时使用\nnRTS：请求发送(Request To Send)\nnCTS：允许发送(Clear To Send)\n数据寄存器—USART_DR：9位有效，包含一个发送数据寄存器TDR和一个接收数据寄存器RDR。一个地址对应了两个物理内存\n\nUSART_CR1：M，0：8bit，1：9bit\nUSART_CR2：STOP\nUSART_CR1：PCE、PS、PEIE\nUSART_SR ：PE\nUSART_CR1：UE、TE、RE\nUSART_SR：TXE，Transmit data register empty\nUSART_CR1：TXEIE\nUSART_SR：TC，Transmission complete\nUSART_CR1：TCIE\nUSART_SR：RXNE，Read data register not empty\nUSART_CR1：RXNEIE\n波特率—每秒钟要发送多少数据      这里的数据就是二进制位\nUSART_BRR：波特率寄存器\n\nUSARTDIV：无符号的定点数\nFCK：串口的时钟，注区分APB2和APB1两条总线\n主机两个串口的用法\n\n\n\n\n\n\n\n\nUSART1的作用\n总共用到2个串口，串口1是用于产品Debug功能，主要用来监控串口2和WiFi模块的通讯数据，方便调试，目前做物联网产品基本都是通过串口来接收和发送数据，而这种一般有一个复杂通讯协议，在调试过程中肯定会有很多问题，如果能把MCU和Wifi模组的交互数据通过别的串口打印出来，那将大大提高开发效率。\nUSART2的作用\n串口2我们是用来跟WiFi模块通讯，用来远程控制和数据交互。\n\nUSART和UART的区别\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;USART&#x3D;&#x3D;(universal synchronous asynchronous receiver and transmitte): 通用同步异步收发器&#x3D;&#x3D;UART&#x3D;&#x3D;(universal asynchronous receiver and transmitter): 通用异步收发器简单来说就是USART是UART的加强版，增加了同步功能，USART除了可以串口通讯以外，还能支持和ISO7816(用于接触式IC卡)、LIN总线(用于汽车CAN总线)、IrDA(红外通讯)协议接口通讯。而UART就只能单纯使用串口通讯协议。\n串口初始结构体讲解\n\n\n\n\n\n\n\n\n\ntypedef struct\n&#123;\n  uint32_t USART_BaudRate;      //波特率 BRR\n  uint16_t USART_WordLength;    //字长 CR1_M\n  uint16_t USART_StopBits;      //停止位 CR2_STOP\n  uint16_t USART_Parity;        //校验控制 CR1_PCE、CR1_PS\n  uint16_t USART_Mode;          //模式选择CR1_TE、CR1_RE\n  // 硬件流选择 CR3_CTSE、CR3_RTSE\n  uint16_t USART_HardwareFlowControl;\n&#125; USART_InitTypeDef;\ntypedef struct\n&#123;\n  uint16_t USART_Clock;      // 同步时钟 CR2_CLKEN\n  uint16_t USART_CPOL;       // 极性 CR2_CPOL\n  uint16_t USART_CPHA;       // 相位 CR2_CPHA\n  uint16_t USART_LastBit;    //最后一个位的时钟脉冲 CR2_LBC\n&#125; USART_ClockInitTypeDef;\n\n编程时需要用到的固件库函数\n\n\n\n\n\n\n\n\n\n//串口初始化函数\nvoid USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct);\n//中断配置函数\nvoid USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState);\n//串口使能函数\nvoid USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState);\n\n//数据发送函数\nvoid USART_SendData(USART_TypeDef* USARTx, uint16_t Data);\n//数据接收函数\nuint16_t USART_ReceiveData(USART_TypeDef* USARTx);\n//中断状态位获取函数\nITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT);    \n\n撸代码编程要点\n\n\n\n\n\n\n\n\n\n初始化串口需要用到的GPIO\n初始化串口，USART_InitTypeDef\n中断配置（接收中断，中断优先级）\n使能串口\n编写发送和接收函数\n编写中断服务函数\n\nUSART1是用于Debug，主要用来打印usart2接收和发送的数据，usart2接的是wifi模组，所以usart1的作用就是用来监控mcu和wifi模组之间的交互数据用的\n串口配置函数\n\n\n\n\n\n\n\n\n\n//usart配置\nstatic void hal_usart_Config(void)\n&#123;\n\tGPIO_InitTypeDef GPIO_InitStructure;\n\tUSART_InitTypeDef USART_InitStructure;\n\n\t// 打开串口GPIO的时钟\n\tDEBUG_USART_GPIO_APBxClkCmd(DEBUG_USART_GPIO_CLK, ENABLE);\n\t\n\t// 打开串口外设的时钟\n\tDEBUG_USART_APBxClkCmd(DEBUG_USART_CLK, ENABLE);\n\n\t// 将USART Tx->PA9 的GPIO配置为推挽复用模式\n\tGPIO_InitStructure.GPIO_Pin = DEBUG_USART_TX_GPIO_PIN;\t\n\t//推挽复用\n\tGPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;\n\tGPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n\tGPIO_Init(DEBUG_USART_TX_GPIO_PORT, &amp;GPIO_InitStructure);\n\n    // 将USART Rx->PA10 的GPIO配置为浮空输入模式\n\tGPIO_InitStructure.GPIO_Pin = DEBUG_USART_RX_GPIO_PIN;\n\t//浮空输入\n\tGPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;\n\tGPIO_Init(DEBUG_USART_RX_GPIO_PORT, &amp;GPIO_InitStructure);\n\t\n\t// 配置串口的工作参数\n\t// 配置波特率\n\tUSART_InitStructure.USART_BaudRate = DEBUG_USART_BAUDRATE;\n\t// 配置 针数据字长  8位\n\tUSART_InitStructure.USART_WordLength = USART_WordLength_8b;\n\t// 配置停止位\n\tUSART_InitStructure.USART_StopBits = USART_StopBits_1;\n\t// 配置校验位\n\tUSART_InitStructure.USART_Parity = USART_Parity_No ;\n\t// 配置硬件流控制\n\tUSART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;\n\t// 配置工作模式，收发一起\n\tUSART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;\n\t// 完成串口的初始化配置\n\tUSART_Init(DEBUG_USARTx, &amp;USART_InitStructure);\n\t\n\t// 串口中断优先级配置\n\tNVIC_Configuration();\n\t\n\t// 使能串口接收中断\n\tUSART_ITConfig(DEBUG_USARTx, USART_IT_RXNE, ENABLE);\t\n\t// 关闭发送中断\n\tUSART_ITConfig(DEBUG_USARTx, USART_IT_TXE, DISABLE);\t\n\n\t// 使能串口\n\tUSART_Cmd(DEBUG_USARTx, ENABLE);\t    \n&#125;\n\n中断外设配置\n\n\n\n\n\n\n\n\n\n//中断外设配置\nstatic void NVIC_Configuration(void)\n&#123;\n  NVIC_InitTypeDef NVIC_InitStructure;\n  \n  // 嵌套向量中断控制器组选择 \n  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);\n  \n  // 配置USART为中断源\n  NVIC_InitStructure.NVIC_IRQChannel = DEBUG_USART_IRQ;\n  // 抢断优先级\n  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 3;\n  // 子优先级 \n  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;\n  //  使能中断\n  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;\n  // 初始化配置NVIC\n  NVIC_Init(&amp;NVIC_InitStructure);\n&#125;\n\nDEBUG_USART_IRQHandler  串口中断函数\n\n\n\n\n\n\n\n\n\n//usart1中断\nvoid DEBUG_USART_IRQHandler()\n&#123;\n\tuint8_t dat;\n\tif(USART_GetITStatus(DEBUG_USART,USART_IT_RXNE) != RESET)\n\t&#123;\t\t\t\t\t\t\t\n\t\tdat = USART_ReceiveData(DEBUG_USART);\n\t//\thal_DebugSendByte(dat);\n\t\t//hal_SendByte(dat);\n\t\tUSART_ClearITPendingBit(DEBUG_USART,USART_IT_RXNE);\n\t\t\n\t&#125;\n\t\n\tif(USART_GetITStatus(DEBUG_USART,USART_IT_TXE) != RESET)\n\t&#123;\n\t\t USART_ClearITPendingBit(DEBUG_USART, USART_IT_TXE);\n\t\t USART_ITConfig(DEBUG_USART, USART_IT_TXE, DISABLE); \t \n\t&#125;\n&#125;\n\nhal_DebugSendByte  串口发送字节\n\n\n\n\n\n\n\n\n\n//串口发送字节\nstatic void hal_DebugSendByte(uint8_t Dat)\n&#123;\n\t//发送单一数据\n\tUSART_SendData(DEBUG_USART, Dat);\n\t//把串口发送中断打开   只有我们主动发数据才开发送中断\n\tUSART_ITConfig(DEBUG_USART, USART_IT_TXE, ENABLE); \t\t\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n然后把我们串口二再配置一下\n\n\n\n\n\n\n\n\n\nDMA  直接存储器访问\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;DMA&#x3D;&#x3D;： Direct Memory Access，直接存储器访问。主要功能是可以把数据从一个地方搬到另外一个地方，而且不占用CPU。\n&#x3D;&#x3D;DMA1&#x3D;&#x3D;： 有7个通道，可以实现 P-&gt;M，M-&gt;P，M-&gt;M\n&#x3D;&#x3D;DMA2&#x3D;&#x3D;： 有5个通道，可以实现 P-&gt;M，M-&gt;P，M-&gt;M\n\nDMA简单来说就是把数据从一个地方搬运到另一个地方。\n\n内存到内存，比如说Flash到Sram\n外设到内存，比如说读ADC外设的值存到数组或者变量里\n内存到外设，比如说把数组或者变量的值写到串口发送寄存器里\n\n当CPU初始化这个传输动作，传输动作本身是由DMA控制器来实现和完成的。DMA传输方式无需CPU直接控制传输，所以一定程度上节约了CPU资源\n所以DMA最主要的作用有2个\n\n.减轻CPU负担\n快速搬运数据，特别是大数据的频繁搬运。\n\nDMA1请求映射\n\n\n\n\n\n\n\n\n\nDMA2请求映射\n\n\n\n\n\n\n\n\n\nADC3&#x2F;SDIO&#x2F;TIM8 的DMA请求只有大容量的单片机才有\nDMA2 控制器及相关请求仅存在于大容量产品和互联型产品中,互联网型是105，大容量是Flash大于256K。所以我们c8t6只有DMA1\n多个DMA请求一起来，怎么办？\n\n\n\n\n\n\n\n\n假如DMA1的串口1,2的发送请求同时到来，该怎么办\n\n软件阶段，DMA_CCRx：PL[1:0]。\n硬件阶段，通道编号小的优先级大，DM1的优先级高于DMA2的优先级\n\n我们使用DMA的目的\n\n\n\n\n\n\n\n\n我们的串口1(USART1)是用来监控WiFi模块和MCU(USART2)交互的数据，也就是说单片机USART2接收到和发送出去的数据都要通过USART1发送出去，这块的数据量相对来说比较多，而且时时刻刻都会有，所以我们用DMA来减轻CPU的负担，从这个需求我们可以知道使用DMA的传输方式是从&#x3D;&#x3D;内存到外设&#x3D;&#x3D;。\nUSART1的发送对应的是DMA1的通道4，所以我们只能使用DMA1通道4。\n初始化结构体\n\n\n\n\n\n\n\n\n\ntypedef struct\n&#123;\n  uint32_t DMA_PeripheralBaseAddr;   // 外设地址\n  uint32_t DMA_MemoryBaseAddr;       // 存储器地址\n  uint32_t DMA_DIR;                  // 传输方向\n  uint32_t DMA_BufferSize;           // 传输数目\n  uint32_t DMA_PeripheralInc;        // 外设地址增量模式\n  uint32_t DMA_MemoryInc;            // 存储器地址增量模式\n  uint32_t DMA_PeripheralDataSize;   // 外设数据宽度\n  uint32_t DMA_MemoryDataSize;       // 存储器数据宽度\n  uint32_t DMA_Mode;                 // 模式选择\n  uint32_t DMA_Priority;             // 通道优先级\n  uint32_t DMA_M2M;                  // 存储器到存储器模式\n&#125;DMA_InitTypeDef;\n\nhal_DMA_Config  DMA配置函数\n\n\n\n\n\n\n\n\n\n// Memory -> P (USART->DR)\nstatic void hal_DMA_Config(void)\n&#123;\n\t//创建DMA结构体\n\tDMA_InitTypeDef DMA_InitStructure;\n\t//开DMA时钟\n\tRCC_AHBPeriphClockCmd(USART_TX_DMA_CLK, ENABLE);\n\t\n\t//外设地址\n\tDMA_InitStructure.DMA_PeripheralBaseAddr = (uint64_t)(&amp;DEBUG_USART->DR);\n\t//存储器地址\n\tDMA_InitStructure.DMA_MemoryBaseAddr = (uint64_t)DebugTxDMAMapBuff;\n\t//传输方向  外设是目标地址\t\n\tDMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;\n\t\n\t//传输的数目  就是发送DMA数组的大小\n\tDMA_InitStructure.DMA_BufferSize = DEBUG_TXBUFF_SIZE_MAX;\n\t//外设地址的增量模式->不需要增\n\tDMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;\n\t//存储器(内存)地址增量模式->需要增\n\tDMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;\n\t//外设数据宽度8位\n\tDMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;\t\n\t//内存数据宽度8位\n\tDMA_InitStructure.DMA_MemoryDataSize = DMA_PeripheralDataSize_Byte;\n\t\n\t//普通缓存模式\n\tDMA_InitStructure.DMA_Mode = DMA_Mode_Normal;\n\t//高优先级\n\tDMA_InitStructure.DMA_Priority = DMA_Priority_High;\n\t//禁止DMA两个内存相互访问\n\tDMA_InitStructure.DMA_M2M = DMA_M2M_Disable;\n\t//DMA初始化 把通道4初始化\n\tDMA_Init(USART_TX_DMA_CHANNEL, &amp;DMA_InitStructure);\n\t// DMA1C4中断优先级配置\n\tNVIC_DMA1C4_Configuration();\n\t//清除传输完成标志位 \n\tDMA_ClearFlag(USART_TX_DMA_FLAG_TC);\n\t//把DMA发送完成中断打开\n\tDMA_ITConfig(USART_TX_DMA_CHANNEL,DMA_IT_TC,ENABLE);\n    //把串口DMA开起来   这个很重要\n\tUSART_DMACmd(DEBUG_USART,USART_DMAReq_Tx,ENABLE);\n\t//不使能dma\n\t//DMA_Cmd(USART_TX_DMA_CHANNEL, DISABLE);\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n NVIC_DMA1C4_Configuration  DMA1 4通道中断外设配置\n\n\n\n\n\n\n\n\n\n//DMA1 4通道中断外设配置\nstatic void NVIC_DMA1C4_Configuration(void)\n&#123;\n  NVIC_InitTypeDef NVIC_InitStructure;\n  \n  // 嵌套向量中断控制器组选择 \n  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);\n  \n  // 配置DMA1C4为中断源\n  NVIC_InitStructure.NVIC_IRQChannel = DMA1C4_IRQ;\n  // 抢断优先级\n  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 3;\n  // 子优先级 \n  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;\n  //  使能中断\n  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;\n  // 初始化配置NVIC\n  NVIC_Init(&amp;NVIC_InitStructure);\n&#125;\n\n DMA1C4_IRQHandler   DMA1通道4中断函数\n\n\n\n\n\n\n\n\n\n//DMA1通道4发送完毕中断函数\nvoid DMA1C4_IRQHandler(void)\n&#123;\n\tif(DMA_GetITStatus(DMA1_IT_TC4) != RESET)\n\t&#123;\n\t\t//发送完毕进入中断清一下中断标志\n\t\tDMA_ClearITPendingBit(DMA1_IT_TC4);\t\n\t\t//禁止DMA1C4发送中断，用到的时候再打开\n\t\tDMA_Cmd(USART_TX_DMA_CHANNEL, DISABLE);\t\t\t\t \n\t\t//空闲\n\t\tDebugIsBusy = 0;\n\t&#125;\n&#125;\n\n DMA1C4_IRQHandler   DMA1通道4中断函数\n\n\n\n\n\n\n\n\n\n//串口初始化\nvoid hal_UsartInit(void)\n&#123;\n\t//首先配置一波\n\thal_usart_Config();\n\t//DMA配置一下\n\thal_DMA_Config();\n\t//初始化的时候先把串口二的接收发送数据队列清空\n\tQueueEmpty(DebugTxMsg);\n\t//debug空闲\n\tDebugIsBusy = 0;\n&#125;\n\nhal_debugProc   debug任务函数\n\n\n\n\n\n\n\n\n\n//debug任务函数\nstatic void hal_debugProc(void)\n&#123;\n\tunsigned char i,len;\n\t//如果忙就直接返回，空闲的时候才会\n\tif(DebugIsBusy)\n\t\treturn;\n\t//把队列的长度取出来\n\tlen = QueueDataSize(DebugTxMsg);\n\tfor(i=0; i&lt;len; i++)\n\t&#123;\n\t\t//if(!DebugIsBusy)\n\t\t//&#123;\n\t\t\t//把数据放到DMA发送数组里面\n\t\t\tQueueDataPop(DebugTxMsg,&amp;DebugTxDMAMapBuff[i]);\n\t\t//\tDebugIsBusy = 1;\n\t\t//\thal_DebugSendByte(temp);\n\t\t//&#125;\n\t&#125;\n\tif(len)\n\t&#123;\n\t\t//这个是我们自己写的一个DMA使能，是让他发送数据\n\t\thal_DMAC4_Enable(len);\n\t\t//debug忙\n\t\tDebugIsBusy = 1;\n\t&#125;\n&#125;\n//启动debug usart1的DMA发送函数,size-需要发送的数据大小\nstatic void hal_DMAC4_Enable(uint64_t size)\n&#123;\n\t//我们首先把DMA关掉\n\t DMA1_Channel4->CCR &amp;= ~(1&lt;&lt;0);\n\t //然后设置传送数据的大小\n\t DMA1_Channel4->CNDTR = size;\n\t //再打开DMA\n\t DMA1_Channel4->CCR |= 1&lt;&lt;0;\n&#125;\n\nSTM32之AHB与APB总线\n\n\n\n\n\n\n\n\nAHB是高速总线，是一种系统总线，它主要负责连接处理器、DMA等一些内部接口。AHB 系统由主模块、从模块和基础结构3部分组成，整个AHB总线上的传输都由主模块发出，由从模块负责回应。APB是低速总线，它主要负责连接外围设备，它又分为APB1和APB2，它的总线架构不像 AHB支持多个主模块，在APB里面唯一的主模块就是APB 桥。APB桥就是连接AHB和APB中间的玩意。APB1最大时钟频率为36MHzAPB2最大时钟频率为72MHz\n\n二级标题三级标题四级标题五级标题六级标题","slug":"wifi主机/wifi主机第六部分  向上突破","date":"2020-08-15T10:49:36.000Z","categories_index":"单片机","tags_index":"STM32,主机","author_index":"虫子"},{"id":"d2e5b9b985b90883587f83810ef48a2e","title":"WIFI主机-APP联调","content":"WIFI主机APP和主机联调\n\n\n\n\n\n\n\n\n打通了单片机和云平台的通讯以后，接下来就要和APP联调，把功能以更友好的形式展现给用户。\nAPP也是通过云平台的DP功能定义去控制和获取我们硬件端的数据的。\n实际上1个DP点不代表只有1个功能，在APP上也可能有2个甚至多功能，具体要看APP的功能怎么定义。\n功能定义\n\n\n\n\n\n\n\n\n数据上报\n数据方向：单片机-&gt;WiFi模块-&gt;云平台-&gt;APP\n主要用来更新app上面的数据显示\n单个DP点上报函数：mcu_dp_xxxx_updata()\n所有DP点上报函数：all_data_update()\n APP实时显示主机模式(通过DP1那个功能点实现)\n触发报警后把触发的探测器名称上报云端(通过DP45那个功能点实现)\n数据下发\n数据方向：APP-&gt;云平台-&gt;WiFi模块-&gt;单片机\n主要用来远程控制硬件。\n数据下发处理函数：dp_download_xxx_handle\n改变主机防盗报警模式(通过DP1那个功能点实现)\n设备功能（DP，Data Point）主要有 6 种数据类型\n\n\n\n\n\n\n\n\n\n\n\n类型\n说明\n\n\n\nbool\n通常为开关类的 DP，例如开关、ECO 和屏显。\n\n\nenum\n通常用作有多种状态的 DP，例如工作模式、风速和风摆位置。\n\n\nvalue\n通常用作数值类型的 DP，例如设定温度值、当前温度值和电量。\n\n\nfault\n通常用于故障的上报，数据常用 bitmap 格式显示。\n\n\nstring\n通常用作字符串类型的 DP。需要以字符串形式传输的 DP 可以使用此类型。部分不便于使用 bool、enum、value 或 fault 类型的 DP，也可用此类型。\n\n\nraw\n通常用作需要透传但对数据格式无要求（明文或者加密）的数据。发送端和接收端对数据的格式、组包和解析方式需要统一。\n\n\nmcu_all_dp_update   所有dp点上报\n\n\n\n\n\n\n\n\n\n//所有dp点上报\nvoid mcu_all_dp_update()\n&#123;\n  //枚举型数据上报;\n  mcu_dp_enum_update(DPID_MASTER_MODE,pStuSystemMode->ID,STR_GATEWAY_ITSELF_ID,my_strlen(STR_GATEWAY_ITSELF_ID)); \n  //STRING型数据上报;\n  mcu_dp_string_update(DPID_ALARM_ACTIVE,\" \",sizeof(\" \"),STR_GATEWAY_ITSELF_ID,my_strlen(STR_GATEWAY_ITSELF_ID)); \n\n&#125;\n\nAPP实时显示主机模式\n\n\n\n\n\n\n\n\n\n//系统防区模式切换\nstatic void SystemMode_Change(SYSTEMMODE_TYPEDEF sysMode)\n&#123;\n\tif(sysMode &lt; SYSTEM_MODE_SUM)\t//传入的形参(模式)是否正确\n\t&#123;\n\t\tpStuSystemMode = &amp;stu_Sysmode[sysMode];\n\t\tpStuSystemMode->refreshScreenCmd = SCREEN_CMD_RESET;\n\t\t//上报主机模式\n\t\tmcu_dp_enum_update(DPID_MASTER_MODE,\n\t\t                   sysMode,STR_GATEWAY_ITSELF_ID,\n\t\t                   my_strlen(STR_GATEWAY_ITSELF_ID)); \n\t&#125;\n&#125;\n\n触发报警后把触发的探测器名称上报云端\n\n\n\n\n\n\n\n\n \n数据下发\n\n\n\n\n\n\n\n\n\n主机联网指示\n\n\n\n\n\n\n\n\n在桌面菜单左上角显示wifi连接状态。\n“N”-进入配网状态\n“W”-WIFI配置成功但未连上路由器\n“R”- WIFI配置成功且连上路由器\n“S”- WIFI已经连接上云服务器\n\n\n\n\n\n\n\n\n\n开启protocol.h文件的宏定义#define  GET_WIFI_STATUS_ENABLE\n\n通过sdk的mcu_api.c文件的get_wifi_st()函数获得wifi状态。\n\n结果会通过回调函数protocol.c文件的wifi_status_result(unsigned char result)函数获得的\n\n联网指示灯指示\n\n\n\n\n\n\n\n\n“N”-进入配网状态，指示灯每200ms快闪一次。\n“W”-WIFI配置成功但未连上路由器，指示灯每600ms闪烁一次\n“R”- WIFI配置成功且连上路由器，指示灯每秒闪烁一次\n“S”- WIFI已经连接上云服务器，指示灯常亮\n实时时间显示\n\n\n\n\n\n\n\n\n在桌面菜单最下面一行显示实时时间，时间通过云服务器去更新,格式如下。\n年-月-日 时:分 星期\n开启protocol.h文件的宏定义#define  SUPPORT_MCU_RTC_CHECK\n\n调用mcu_api.c文件的mcu_get_system_time函数去获取服务器时间。\n\n通过protocol.c文件的mcu_write_rtctime()回调函数获得最终时间数据。\n\n报警110声    主机模式切换提示音\n\n\n\n\n\n\n\n\n离家布防&#x2F;在家布防：蜂鸣器滴一声\n撤防：蜂鸣器滴滴两声\n\n按键提示音   自动熄屏\n\n\n\n\n\n\n\n\n按下S1-S6按键的时候，蜂鸣器滴一声\n无任何操作情况下30秒自动熄屏，按任意按键、无线遥控器、APP控制可触发自动亮屏\n熄屏条件\n1、 主机没在报警模式\n2、 主机没在配网菜单\n3、 没有任何按键、切换模式动作下保持30秒\n自动亮屏条件\n\n按下S1-S6任意按键\n\n切换主机模式\n\n\n设置菜单超时自动退出\n在设置菜单下，如果没任何按键操作的话，自动返回桌面菜单\n\n主机没在配网菜单\n主机不在桌面菜单\n\napp任务控制息屏\n\n\n\n\n\n\n\n\n\nvoid AppProc(void)\n&#123;\n\t//mcu_api中的wifi串口服务\n    wifi_uart_service();\n\tpModeMenu->action();\t\n\tif((pModeMenu->menuPos!=DESKTOP_MENU_POS) \n\t\t&amp;&amp;(pModeMenu->menuPos!=STG_WIFI_MENU_POS))\n\t&#123;\n\t\tSetupMenuTimeOutCnt++;\n\t\tif(SetupMenuTimeOutCnt > SETUPMENU_TIMEOUT_PERIOD)\n\t\t&#123;\n\t\t\tSetupMenuTimeOutCnt = 0;\n\t\t\t//设置上电显示的菜单界面为桌面显示\n\t\t\tpModeMenu = &amp;generalModeMenu[GNL_MENU_DESKTOP];\t\n\t\t\t//更新刷新界面标志，进入界面后刷新全界面UI\n\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RESET;\t\n\n\t\t&#125;\n\t&#125;\t\t\t\t\n\tif((pStuSystemMode->ID!=SYSTEM_MODE_ALARM)\n\t&amp;&amp; (pModeMenu->menuPos!=STG_WIFI_MENU_POS))\n\t&#123;\n\t\tPutoutScreenTiemr++;\n\t\tif(PutoutScreenTiemr > PUTOUT_SCREEN_PERIOD)\n\t\t&#123;\n\t\t\tPutoutScreenTiemr = 0;\n\t\t\t\n\t\t\t//30秒没任何操作自动熄屏\n\t\t\tScreeControl(0);\t\t\t \n\t\t&#125;\n\t&#125;\t\n&#125;\n\n按键提示音\n\n\n\n\n\n\n\n\n\n//按键回调函数\nstatic void KeyEventHandle(KEY_VALUE_TYPEDEF keys)\n&#123;\t \t\n\tif(!ScreenState)\n\t&#123;\n\t\tScreeControl(1);\n\t&#125;else\n\t&#123;\n\t\tpModeMenu->keyVal = keys;\n\t\tif((pModeMenu->menuPos!=DESKTOP_MENU_POS) \n\t\t\t&amp;&amp;(pModeMenu->menuPos!=STG_WIFI_MENU_POS))\n\t\t\t&#123;\n\t\t\t\tSetupMenuTimeOutCnt = 0;\n\t\t\t&#125;\n\t\t\tPutoutScreenTiemr = 0;\n\t&#125;\t\n\tif((keys==KEY1_CLICK)\n\t|| (keys==KEY2_CLICK)\n\t|| (keys==KEY3_CLICK)\n\t|| (keys==KEY4_CLICK)\n\t|| (keys==KEY5_CLICK)\n\t|| (keys==KEY6_CLICK))\n\t&#123;\n\t\tLedMsgInput(BUZ,LED_LIGHT_100MS,0);\n\t&#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n二级标题三级标题四级标题五级标题六级标题","slug":"wifi主机/wifi主机第十三部分  APP联调","date":"2020-08-15T10:49:36.000Z","categories_index":"单片机","tags_index":"STM32,主机","author_index":"虫子"},{"id":"441f89b58030cc5cf4d20abd25001933","title":"WIFI主机-远程","content":"WIFI主机主机实现远程控制原理\n\n\n\n\n\n\n\n\n\n传统硬件\n\n\n\n\n\n\n\n\n报警主机、指纹锁、智能插座、冰箱、电风扇、空调等等。\n传统的智能硬件一般是带单片机的\n我们传统硬件的数据，比如说电量啊、温湿度值、报警探测器的名称啊这些数据就是通过串口传输给WiFi模块，然后WiFi模块再上传到云平台的。\n这样你在云平台的网页后台就能看到，网页后台给用户体验不好，所以实际产品一般也会做APP。\nAPP从云平台去获取数据，然后显示在APP上面，当然也可以发送控制的指令给云平台。\n云平台再发送给WiFi模块，WiFi模块通过串口传输到单片机这里，单片机解析命令后执行相应的控制，比如说控制继电器吸合&#x2F;断开，LED灯亮灭等等\nWiFi模块&#x2F;模组\n\n\n\n\n\n\n\n\nWRG1(涂鸦自主研发模块)、ESP8266(乐鑫科技)、LPB100、LPT120(汉枫)、上海庆科等等。 \nWifi模块一般是现成的模块，不会自己去研发，因为这种做这种模块的测试设备贵的要几百万，一般公司承担不起，只有专门做wifi模块的厂家才会去买。 \n有些WiFi模块一般会有提供类似于STM32的固件库，如汉枫的模块，你在他们库的基础上进行二次开发，一般厂家会提供开发教程和技术指导，这块不用过于担忧，其实就跟单片机开发差不多，比较简单。 \n而我们这个报警主机使用的是涂鸦云自己研发的模块，型号WRG1，用它们模块最大的好处就是，不用改wifi模块的代码，涂鸦云直接帮你做好，对接好他们平台。 \n除此以外，他们这个模块也会帮我们做好单片机这边的通讯，一般我们数据传输的时候是有一个通讯协议的，就是按照固定的数据格式进行通讯。 \n至于整个通讯协议的解析代码，他们会帮我们做好，并且提供sdk给我们下载，我们只需要调用他们函数就能把传统硬件轻松连上他们服务器。\n云平台\n\n\n\n\n\n\n\n\n市面上云平台很多，涂鸦云、机智云、云智易、阿里云、华为云、腾讯云、百度云等等。 \n每个云接入的难度不一样，目前来说最简单的应该是涂鸦云。 \n对初学者最友好，他们什么都帮你做好，你只需要按照他们教程，把他们的代码移植到我们单片机keil工程里就行了。 \n平台也支持在线生成app，但是比较鸡肋，调试用可以，用于产品就太垃圾了。\nAPP\n\n\n\n\n\n\n\n\n我们这个报警主机用的是涂鸦云在线生成的鸡肋版APP，这个也没办法，因为做APP的费用太昂贵了，APP分为苹果版本和安卓版本。 \n如果想做好一套APP，除了2个系统版本的APP以外，还涉及到UI的设计，所以整套下来估计将近20万甚至以上。 \n不过最核心的还是把传统硬件到云平台这边的数据打通，就是单片机能把数据正常上传到云平台，云平台也能把数据传输到单片机，链路打通了，剩下的就简单了。\nSDK移植移植须知\n\n\n\n\n\n\n\n\n\nMCU SDK,是涂鸦平台根据用户创建的DP点自动生成的MCU程序架构，我们可以在此基础上进行快速开发\nMCU硬件需求，MCU SDK包对MCU硬件资源需求Flash 4Kbyte，RAM与DP点数据长度有关几十字节左右(OTA功能需大于260byte)，函数嵌套级数9级，资源不足的用户，可自行对接协议\n\n\n\n\n\n\n\n\n\n\n\n先把我们的开发资料都下载下来\n\n文件结构\n\n\n\n\n\n\n\n\n然后将我们的mcu_sdk移植到自己的主机中\n\n\n确认 protocol.h 宏定义\n\n\n\n\n\n\n\n\n定义 PID。PRODUCT_KEY 为产品 PID 宏定义。PID 即产品 ID, 为每个产品的唯一标识，可在 IoT 平台 的产品详情页面查询。\n//pid信息，服务端自动插入\n#define PRODUCT_KEY \"aono1txwiafeacmx\"    //开发平台创建产品后生成的16位字符产品唯一标识\n\n\n\n\n\n\n\n\n\n\n这里需要注意一下，就是如果PRODUCT_KEY和产品PID不一致，需要重新下载SDK包，但是基本不会出现这种情况\n\n\n\n\n\n\n\n\n\n定义版本号。MCU_VER 为软件版本，默认为 1.0.0 。若 MCU 需要 OTA 功能，需要添加新的 MCU 版本号。\n#define MCU_VER \"1.0.0\"                    //用户的软件版本,用于MCU固件升级,MCU升级版本需修改\n\n\n\n\n\n\n\n\n\n\n定义 Wi-Fi 模组工作模式。CONFIG_MODE 为配网方式，支持默认模式（热点和快连互相切换）、安全模式、防误触模式。默认即可\n//配网方式选择,默认为CONFIG_MODE_DEFAULT,只能三选一\n#define CONFIG_MODE     CONFIG_MODE_DEFAULT               //默认配网方式\n//#define CONFIG_MODE     CONFIG_MODE_LOWPOWER            //低功耗配网方式\n//#define CONFIG_MODE     CONFIG_MODE_SPECIAL             //特殊配网方式\n\n\n\n\n\n\n\n\n\n\n定义收发缓存（可选）\n\n串口接收缓存：大小受到串口数据处理被调用的频率影响。如果 MCU 对串口数据的处理较快，串口接收缓存大小可适当减小。\n串口发送缓存：大小要大于数据最长的 DP 数据长度。\n串口数据处理缓存：大小需要大于数据最长的 DP 数据长度，还要根据是否需要 OTA 功能和是否需要天气服务、天气服务类型数量和天数来调整大小，需要大于最大数据量的大小。\n\n 3:定义收发缓存:\n                    用户根据实际情况定义收发缓存的大小\n******************************************************************************/\n#ifndef SUPPORT_MCU_FIRM_UPDATE\n#define WIFI_UART_RECV_BUF_LMT         128      //串口数据接收缓存区大小,如MCU的RAM不够,可缩小\n#define WIFI_DATA_PROCESS_LMT          128      //串口数据处理缓存区大小,根据用户DP数据大小量定,建议大于24\n#else\n#define WIFI_UART_RECV_BUF_LMT         128      //串口数据接收缓存区大小,如MCU的RAM不够,可缩小\n\n\n\n\n\n\n\n\n\n\n定义模组工作方式（必选）\n如果配网按键和 LED 接在 MCU 端，即选择 模组和 MCU 配合处理 工作模式（常用），保持 WIFI_CONTROL_SELF_MODE 宏定义处于被注释状态\n//#define         WIFI_CONTROL_SELF_MODE      //wifi自处理按键及LED指示灯;如为MCU外界按键/LED指示灯请关闭该宏\n\n\n\n\n\n\n\n\n\n\n如果配网指示灯和按键是接在 Wi-Fi 模组上的，即选择 模组自处理 工作模式，开启 WIFI_CONTROL_SELF_MODE 宏定义，然后根据实际的硬件连接，将指示灯和按键所连接的 GPIO 脚位填入下面两个宏定义\n//例如：PORT为2，pin为3则代表选择GPIO C_3\n#ifdef          WIFI_CONTROL_SELF_MODE                      //模块自处理\n  #define    WF_LED_PORT   0   //wifi状态指示灯的PORT（prot选择范围：0~3[依次代表A到D]），请根据实际GPIO管脚设置\n  #define    WF_LED_PIN    0   //wifi状态指示灯的PIN（prot选择范围：0~7），请根据实际GPIO管脚设置\n  #define    WF_RESERT_KEY_PORT   0  //重置按键的PORT（prot选择范围：0~3[依次代表A到D]），请根据实际GPIO管脚设置\n  #define    WF_RESERT_KEY_PIN    0  //重置按键的PIN（prot选择范围：0~7），请根据实际GPIO管脚设置\n#endif\n\n\n\n\n\n\n\n\n\n\n开启 Wi-Fi 产测功能（可选）\nWi-Fi 产测功能默认开启。为保证最终量产效率及品质，建议开启该功能\n#define         WIFI_TEST_ENABLE                      //开启WIFI产测功能（扫描指定路由）\n\n移植 protocol.c 文件及函数调用\n\n\n\n\n\n\n\n\n\n在 MCU 串口及其他外设初始化后，调用 mcu_api.c 文件中的 wifi_protocol_init() 函数。\n将 MCU 串口单字节发送函数填入 protocol.c 文件中的 uart_transmit_output 函数内，并删除 #error\n\n\n\n\n\n\n\n\n\n\n\n\n在串口接收中断服务函数里面调用 mcu_api.c 文件内的 uart_receive_input 函数，并将接收到的字符作为参数传入\n\n\n\n\n\n\n\n\n\n\n单片机进入 while(1) 循环后调用 mcu_api.c 文件内的 wifi_uart_service() 函数。main.c\n\nJSON\n\n\n\n\n\n\n\n\nJSON（JavaScript Object Notation）是一种轻量级的数据交换格式，可使人们很容易地进行阅读和编写，同时也方便了机器进行解析和生成。JSON适用于进行数据交互的场景，如网站前台与后台之间的数据交互。 \n比如说获取产品信息指令这种格式，有字符串，有数值，他可以很轻松转换成统一的格式。 \n使用JSON的时候，需要比较大的堆和栈，所以我们需要更改STM32启动文件的堆栈大小，我统一改成2K，否则通讯不正常，因为动态分配JSON对象的时候返回分配失败。 \n栈(stack)空间，用于局部变量，函数调时现场保护和返回地址，函数的形参等。堆(heap)空间，主要用于动态内存分配，也就是说用 malloc，calloc, realloc 等函数分配的变量空间。\n\n\n配网的目的\n\n\n\n\n\n\n\n\n配网就是让wifi模块连接我们家或者公司的wifi，只有连上wifi以后wifi模块才能通过ip和端口连上远程的服务器进行远程控制。 \n就跟我们手机没有连wifi，也没有4G信号的时候，就无法上网一样\n配网模式\n\n\n\n\n\n\n\n\n目前大多数wifi模块主流的配网就是2种\n1.   AP\n2.   Smartlink\nAP\n\n\n\n\n\n\n\n\n优点：就是连接Wifi模块的热点，然后进行配网，这种配网成功率几乎90%以上，wifi模块连网比较快。\n缺点：配网流程稍微麻烦一点\nSmartlink\n\n\n\n\n\n\n\n\n优点：就是通过广播的形式配网，配网流程非常简单。\n缺点：wifi模块连网时间也比较长，成功率比AP模式低\n配网代码完善\n\n\n\n\n\n\n\n\n我们采用AP这种方式配网，我们完善设置菜单stgMenu_WifiCBS函数\n我们调用mcu_api.c里面的函数就行\n\nstgMenu_WifiCBS  wifi配网菜单处理函数\n\n\n\n\n\n\n\n\n\n我们只需要用到4种连网状态\n\nAP_STATE：AP配置状态，文案显示” Enter ap mode.”\nWIFI_NOT_CONNECTED: WIFI配置成功但未连上路由器，文案显示” Connect to wifi ok.”\nWIFI_CONNECTED: WIFI配置成功且连上路由器，文案显示” Connect to router ok.”\nWIFI_CONN_CLOUD: WIFI已经连接上云服务器，文案显示” Connect to server ok.”和”Connect success!”\n\n//wifi配网菜单处理函数\nstatic void stgMenu_WifiCBS(void)\n&#123;\n\t//AP配网步骤\n\tstatic uint8_t APStep = 0;\n\t//连接成功标志\n\tstatic uint8_t ConnectSuccess = 0;\n\t//wifi工作状态\n\tuint8_t wifiWorkState = 0;\n\tstatic uint8_t stgMainMenuSelectedPos = 0;\n\tstatic uint16_t timer = 0;\n\tuint8_t keys;\n\tif(pModeMenu->refreshScreenCmd == SCREEN_CMD_RESET)\n\t&#123;\n\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_NULL;\t\n\t\thal_Oled_Clear();\t \n\t\thal_Oled_ShowString(52,0,\"Wifi\",12,1);\t\t \n\t\thal_Oled_ShowString(0,20,\"Are you sure to\",8,1); \n\t\thal_Oled_ShowString(0,30,\"enter ap mode?\",8,1);\t\t\n\t\t//yes   no\n\t\thal_Oled_ShowString(40,48,\"Yes\",12,1); \n\t\thal_Oled_ShowString(88,48,\"No\",12,0); \t\t\n\t\thal_Oled_Refresh();\t\t\n\t\tkeys = 0xFF;\n\t\ttimer = 0;\n\t\tstgMainMenuSelectedPos = 0;\n\t&#125;\t\n\tif(pModeMenu->keyVal != 0xff)\n\t&#123;\n\t\tkeys = pModeMenu->keyVal;\n\t\tpModeMenu->keyVal = 0xFF;\t//恢复菜单按键值\t\t\n\t\tif((keys == KEY3_CLICK_RELEASE) || (keys == KEY4_CLICK_RELEASE))\n\t\t&#123;\n\t\t\tif(stgMainMenuSelectedPos == 0)\t\t\n\t\t\t&#123;\n\t\t\t\tstgMainMenuSelectedPos = 1;\n\t\t\t\thal_Oled_ClearArea(40,48,88,16);\t\t//清屏\n\t\t\t\thal_Oled_ShowString(40,48,\"Yes\",12,0); \n\t\t\t\thal_Oled_ShowString(88,48,\"No\",12,1); \n\t\t\t\thal_Oled_Refresh();\n\t\t\t&#125;else if(stgMainMenuSelectedPos == 1)\n\t\t\t&#123;\n\t\t\t\tstgMainMenuSelectedPos = 0;\n\t\t\t\thal_Oled_ClearArea(40,48,88,16);\t\t//清屏\n\t\t\t\thal_Oled_ShowString(40,48,\"Yes\",12,1); \n\t\t\t\thal_Oled_ShowString(88,48,\"No\",12,0); \n\t\t\t\thal_Oled_Refresh(); \n\t\t\t&#125;\n\t\t&#125;else if(keys == KEY5_CLICK_RELEASE)\n\t\t&#123;\n\t\t\tpModeMenu = pModeMenu->pParent;\n\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RECOVER;\n\t\t&#125;else if(keys == KEY5_LONG_PRESS)\n\t\t&#123;\n\t\t\tpModeMenu = &amp;generalModeMenu[GNL_MENU_DESKTOP];;\n\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RESET;\n\t\t&#125;\t\n\t\telse if((keys == KEY6_CLICK_RELEASE)\n\t\t&amp;&amp; (!APStep)\n\t\t&amp;&amp; (!ConnectSuccess))\n\t\t&#123;\n\t\t\t//为1的时候就是选择yes\n\t\t\tif(stgMainMenuSelectedPos)\n\t\t\t&#123;\n\t\t\t\tAPStep = 1;\n\t\t\t\t//让wifi进入AP配网模式\n\t\t\t\tmcu_set_wifi_mode(1);\t\t\n\t\t\t\thal_Oled_ClearArea(0,20,128,44);\t\t//清屏\n\t\t\t\thal_Oled_ShowString(16,30,\"Please wait..\",8,1);\n\t\t\t\thal_Oled_Refresh();\t\n\t\t\t&#125;else\n\t\t\t&#123;\n\t\t\t\tpModeMenu = pModeMenu->pParent;\n\t\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RECOVER;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\tif(APStep)\n\t&#123;\n\t\twifiWorkState = mcu_get_wifi_work_state();\n\t&#125;\n\tif(APStep == 1)\n\t&#123;\n\t\tif(wifiWorkState == AP_STATE)\n\t\t&#123;\n\t\t\thal_Oled_ClearArea(0,20,128,44);\t\t//清屏\n\t\t\thal_Oled_ShowString(0,30,\"Enter ap mode.\",8,1);\n\t\t\thal_Oled_Refresh();\n\t\t\t//灯闪烁表示正在联网\n\t\t\tLedMsgInput(LED1,LED_BLINK1,1);\n\t\t\tAPStep = 2;\n\t\t&#125;\n\t&#125;else if(APStep == 2)\n\t&#123;\n\t\tif(wifiWorkState == WIFI_NOT_CONNECTED)\n\t\t&#123;\n\t\t\thal_Oled_ClearArea(0,20,128,44);\t\t//清屏\n\t\t\thal_Oled_ShowString(0,30,\"Connect to wifi ok.\",8,1);\n\t\t\thal_Oled_Refresh();\n\t\t\t//灯慢闪\n\t\t\tLedMsgInput(LED1,LED_BLINK3,1);\n\t\t\tAPStep = 3;\t\n\t\t&#125;\n\t&#125;else if(APStep == 3)\n\t&#123;\n\t\tif(wifiWorkState == WIFI_CONNECTED)\n\t\t&#123;\n\t\t\thal_Oled_ClearArea(0,20,128,44);\t\t//清屏\n\t\t\thal_Oled_ShowString(0,30,\"Connect to router ok.\",8,1);\n\t\t\thal_Oled_Refresh();\n\t\t\tLedMsgInput(LED1,LED_BLINK4,1);\n\t\t\tAPStep = 4;\n\t\t&#125;\n\t&#125;else if(APStep == 4)\n\t&#123;\n\t\tif(wifiWorkState == WIFI_CONN_CLOUD)\n\t\t&#123;\n\t\t\thal_Oled_ClearArea(0,20,128,44);\t\t//清屏\n\t\t\thal_Oled_ShowString(0,30,\"Connect to server ok.\",8,1);\n\t\t\thal_Oled_ShowString(0,40,\"Connect success!\",8,1);\n\t\t\thal_Oled_Refresh();\n\t\t\tLedMsgInput(LED1,LED_LIGHT,1);\n\t\t\tAPStep = 0;\n\t\t\tConnectSuccess = 1;\n\t\t\ttimer = 0;\n\t\t&#125;\n\t&#125;\n\tif(ConnectSuccess)\n\t&#123;\n\t\t//连接成功延时2s让用户看到成功的字样\n\t\ttimer++;\n\t\tif(timer >200)\n\t\t&#123;\n\t\t\ttimer = 0;\n\t\t\tConnectSuccess = 0;\n\t\t\t \n\t\t\tpModeMenu = pModeMenu->pParent;\n\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RECOVER;\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n二级标题三级标题四级标题五级标题六级标题","slug":"wifi主机/wifi主机第十二部分  远程小小侠","date":"2020-08-15T10:49:36.000Z","categories_index":"单片机","tags_index":"STM32,主机","author_index":"虫子"},{"id":"e83728f7bf48a49084af17022bba25d3","title":"WIFI主机-","content":"WIFI主机\n\n\n\n\n\n\n\n\n先看看我们需要完成的所有功能\n\n桌面菜单功能\n\n\n\n\n\n\n\n\n\n菜单头文件的结构体枚举\n\n\n\n\n\n\n\n\n\n菜单初始化\n\n\n\n\n\n\n\n\n\n//菜单初始化\nvoid menuInit(void)\n&#123;\n\t//设置上电显示的菜单界面为桌面显示\n\tpModeMenu = &amp;generalModeMenu[GNL_MENU_DESKTOP];\t\n\t//更新刷新界面标志，进入界面后刷新全界面UI\n\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RESET;\t\n&#125;\n\nshowSystemTime  系统时间显示\n\n\n\n\n\n\n\n\n\n//系统时间显示\nstatic void showSystemTime(void)\n&#123;\n\tsprintf(SystemtimeToStr, \"%04d-%02d-%02d %02d:%02d %s\",\n\t                         stuSystemtime.year,\n\t                         stuSystemtime.mon,\n\t                         stuSystemtime.day,\n\t                         stuSystemtime.hour,\n\t                         stuSystemtime.min,\n\t                         stuSystemtime.week);\n\thal_Oled_ShowString(4,54,SystemtimeToStr,8,1);\t\n\thal_Oled_Refresh();\n&#125;\n\ngnlMenu_DesktopCBS  普通菜单桌面回调函数\n\n\n\n\n\n\n\n\n\n//普通菜单桌面回调函数\n static void gnlMenu_DesktopCBS(void)\n&#123;\n\tif(pModeMenu->refreshScreenCmd == SCREEN_CMD_RESET)\n\t&#123;\n\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_NULL;\n\t\tpModeMenu->keyVal = 0xFF;\t\t \n\t\thal_Oled_Clear(); \n\t\thal_Oled_ShowString(0,0,\"N\",8,1);\t\t\n\t\thal_Oled_ShowString(16,20,\"Away arm\",24,1);\n\t\tshowSystemTime();\t\t\n\t\tQueueEmpty(RFDRcvMsg);\n\t\thal_Oled_Refresh();\t\t\n\t&#125;\t\n&#125;\n\nAppProc  App任务\n\n\n\n\n\n\n\n\n\nvoid AppProc(void)\n&#123;\n\tpModeMenu->action();\t\n&#125;\n\n上面是前戏，现在才是设置主菜单\n\n\n\n\n\n\n\n\n这个由产品功能决定，一般中大型产品都会有系统设置，不一定用菜单的形式做，主要用于设置比如说一些定时时间、温度报警阈值、系统时间等等。\n市面上也有很多类似于STM32标准库这样的UI库：\n\nTouchGFX Designer\n\nEmwin\n\n串口屏\n\n\n我自己认为UI设计师实际上没有什么技术含量，所以我想学酷炫的UI就调库就行了\n使用这些图形UI的优点是能够很轻松做出酷炫的LCD显示界面，缺点是这些库比较占用单片机资源，主要是RAM和ROM，还有一些是收费的，像串口屏这种直接是一个模块，单片机通过串口去控制屏显示的内容，虽然方便，但是价格比较贵。\n\n搭建设置菜单代码框架\n\n\n\n\n\n\n\n\n我这里强调一点，现在我们菜单变多就需要先搭框架\n先把每个菜单处理函数定义出来\n\n\n\n\n\n\n\n\n设置主菜单\nstatic void stgMenu_MainMenuCBS(void)\n&#123;\n&#125;\n\n\n\n\n\n\n\n\n\n\n 探测器配对菜单处理函数\nstatic void stgMenu_LearnSensorCBS(void)\n&#123;\n&#125;\n\n\n\n\n\n\n\n\n\n\n探测器列表菜单处理函数\nstatic void stgMenu_DTCListCBS(void)\n&#123;\n&#125;\n\n\n\n\n\n\n\n\n\n\n wifi配网菜单处理函数\nstatic void stgMenu_WifiCBS(void)\n&#123;\n&#125;\n\n\n\n\n\n\n\n\n\n\n 设备信息菜单处理函数\nstatic void stgMenu_MachineInfoCBS(void)\n&#123;\n&#125;\n\n\n\n\n\n\n\n\n\n\n 恢复出厂设置菜单处理函数\nstatic void stgMenu_FactorySettingsCBS(void)\n&#123;\n&#125;\n\n定义设置菜单结构体数组并初始化\n\n\n\n\n\n\n\n\n\nmenuInit  菜单初始化\n\n\n\n\n\n\n\n\n\n//菜单双链表初始化\nstu_mode_menu* MenuDoubleListInit(void)\n&#123;\n\t//把学习传感器菜单当做哨兵位节点\n\tstu_mode_menu* phead = &amp;settingModeMenu[STG_MENU_LEARNING_SENSOR];\n\tphead->pLast = phead;\n\tphead->pNext = phead;\n\t\n\treturn phead;\n&#125;\n//菜单链表尾插\nvoid MenuDoubleListPushBack(stu_mode_menu* phead,stu_mode_menu* node)\n&#123;\n\t//我们先找到链表尾\n\tstu_mode_menu* tail = phead->pLast;\n\ttail->pNext = node;\n\tnode->pLast = tail;\n\tnode->pNext = phead;\n\tphead->pLast = node;\n&#125;\n//菜单初始化\nvoid menuInit(void)\n&#123;\n\tuint8_t\ti;\n\tMenuDoubleListInit();\n\t//主设置菜单初始化,把菜单列表形成链表形式，方便调用\n\tfor(i=STG_MENU_LEARNING_SENSOR; i&lt;STG_MENU_SUM; ++i)\n\t&#123;\n\t\tMenuDoubleListPushBack(&amp;settingModeMenu[STG_MENU_LEARNING_SENSOR],&amp;settingModeMenu[i]);\n\t\tsettingModeMenu[i].pParent = &amp;settingModeMenu[STG_MENU_MAIN_SETTING];\n\t&#125;\t\n\tpModeMenu = &amp;generalModeMenu[GNL_MENU_DESKTOP];\t//设置上电显示的菜单界面为桌面显示\n\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RESET;\t//更新刷新界面标志，进入界面后刷新全界面UI\n&#125;\n\n完善设置主菜单UI和按键功能增加菜单按键功能\n\n\n\n\n\n\n\n\n我们要在桌面菜单下长按S6(确定&#x2F;菜单)键进入设置主菜单\n\n菜单显示\n\n\n\n\n\n\n\n\n选中某个菜单选项的时候，背景是蓝色。一页显示4个菜单。\n\n功能按键\n\n\n\n\n\n\n\n\n需要考虑的几种情况\n&#x3D;&#x3D;1.选中第一个菜单的时候&#x3D;&#x3D;\n\n如果短按S1”上”按键，就要做翻页功能\n如果短按S2”下”按键，那就不需要做翻页，也就是我们不需要把4个菜单界面都重新刷新\n\n&#x3D;&#x3D;2.选中第四个菜单的时候&#x3D;&#x3D;\n\n如果短按S1”上”按键，那就不需要做翻页，也就是我们不需要把4个菜单界面都重新刷新\n如果短按S2”下”按键，就要做翻页功能\n\n&#x3D;&#x3D;3.没有选中第一或者第四个菜单的时候&#x3D;&#x3D;\n\n上按键\n如果短按S1”上”按键，那就不需要做翻页，也就是我们不需要把4个菜单界面都重新刷新。\n下按键\n如果短按S2”下”按键，那就不需要做翻页，也就是我们不需要把4个菜单界面都重新刷新\n\n\n//设置主菜单\nstatic void stgMenu_MainMenuCBS(void)\n&#123;\n\tuint8_t keys;\n\tuint8_t i;\n\tuint8_t ClrScreenFlag;\n\tstatic stu_mode_menu *pMenu;\t\t            //用来保存当前选中的菜单\n\tstatic stu_mode_menu *bpMenu=0;\t\t            //用来备份上一次菜单选项，主要用于刷屏判断\n\tstatic unsigned char stgMainMenuSelectedPos=0;\t//用来记录当前选中菜单的位置\n\tstatic stu_mode_menu *MHead,*MTail;\t\t        //这两个结构体指针是为了上下切换菜单时做翻页处理\n\tif(pModeMenu->refreshScreenCmd == SCREEN_CMD_RESET)\n\t&#123;\n\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_NULL;\n\t\tpMenu = &amp;settingModeMenu[STG_MENU_MAIN_SETTING];\n\t\thal_Oled_Clear();\n\t\thal_Oled_ShowString(37,0,pMenu->pModeType,12,1);\n\t\thal_Oled_Refresh();\n\t\tpMenu = &amp;settingModeMenu[STG_MENU_LEARNING_SENSOR];\n\t\tMHead = pMenu;\t\t\t//记录当前显示菜单第一项\n\t\tMTail = pMenu+3;\t\t//记录当前显示菜单最后一项,一页显示4行\t\t\n\t\tbpMenu = 0;\n \t\tClrScreenFlag = 1;\n\t\tstgMainMenuSelectedPos = STG_MENU_LEARNING_SENSOR;\n\t\tkeys = 0xFF;\n \t&#125;\n\tif(pModeMenu->keyVal != 0xff)\n\t&#123;\n\t\tkeys = pModeMenu->keyVal;\n\t\tpModeMenu->keyVal = 0xFF;\t//恢复菜单按键值\n\t\tswitch(keys)\n\t\t&#123;\n\t\t\tcase KEY1_CLICK:\t\t//上\t\t\t\t\n\t\t\t\tif(stgMainMenuSelectedPos == 1)\n\t\t\t\t&#123;\n\t\t\t\t\tMHead = MHead->pLast;\n\t\t\t\t\tpMenu = pMenu->pLast;\n\t\t\t\t\tMTail = MTail->pLast;\n\t\t\t\t\tstgMainMenuSelectedPos = 1;\n\t\t\t\t\tClrScreenFlag = 1;\n\t\t\t\t&#125;else\n\t\t\t\t&#123;\n\t\t\t\t\t//取消选中本菜单显示\n\t\t\t\t\thal_Oled_ShowString(0,14*stgMainMenuSelectedPos,pMenu->pModeType,8,1);\t\t\n\t\t\t\t\thal_Oled_Refresh();\n\t\t\t\t\tpMenu = pMenu->pLast;\n\t\t\t\t\tstgMainMenuSelectedPos--;\n\t\t\t\t&#125;\n\t\t\tbreak;\n\t\t\tcase KEY2_CLICK:\t\t//下\n\t\t\t\tif(stgMainMenuSelectedPos == 4)\n\t\t\t\t&#123;\n\t\t\t\t\tMHead = MHead->pNext;\t\n\t\t\t\t\tpMenu = pMenu->pNext;\n\t\t\t\t\tMTail = pMenu;\n\t\t\t\t\tstgMainMenuSelectedPos = 4;\n\t\t\t\t\tClrScreenFlag = 1;\n\t\t\t\t&#125;else\n\t\t\t\t&#123;\n\t\t\t\t\t//取消选中本菜单显示\n\t\t\t\t\thal_Oled_ShowString(0,14*stgMainMenuSelectedPos,pMenu->pModeType,8,1);\t\t\n\t\t\t\t\thal_Oled_Refresh();\n\t\t\t\t\t//切换下一个选项\n\t\t\t\t\tpMenu = pMenu->pNext;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\tstgMainMenuSelectedPos++;\n\t\t\t\t&#125;\n\t\t\tbreak;\t\t\t\n\t\t\tcase KEY5_CLICK_RELEASE:\t//取消\n\t\t\t\tpModeMenu = &amp;generalModeMenu[GNL_MENU_DESKTOP];;\n\t\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RESET;\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n\tif(bpMenu != pMenu)\n\t&#123;\n\t\tbpMenu = pMenu;\n\t\tif(ClrScreenFlag)\n\t\t&#123;\t\t\t\n\t\t\tClrScreenFlag = 0;\n\t\t\tpMenu = MHead;\n\t\t\thal_Oled_ClearArea(0,14,128,50);\t\t//清屏\n\t\t\thal_Oled_Refresh();\n\t\t\tfor(i=1; i&lt;5; i++)\n\t\t\t&#123;\n\t\t\t\thal_Oled_ShowString(0,14*i,pMenu->pModeType,8,1);\n\t\t\t\thal_Oled_Refresh();\n\t\t\t\tpMenu = pMenu->pNext;\n\t\t\t&#125; \n\t\t\tpMenu = bpMenu;\n\t\t\thal_Oled_ShowString(0,14*stgMainMenuSelectedPos,pMenu->pModeType,8,0);\n\t\t\thal_Oled_Refresh();\n\t\t&#125;else\n\t\t&#123; \n\t\t\thal_Oled_ShowString(0,14*stgMainMenuSelectedPos,pMenu->pModeType,8,0);\t\n\t\t\thal_Oled_Refresh();\n\t\t&#125;\t\t\t\t\t \n\t&#125;\n&#125;\n\nSTM32驱动OLED实现探测器配对子菜单功能stgMenu_LearnSensorCBS   探测器配对菜单\n\n\n\n\n\n\n\n\n\n//探测器配对菜单处理函数\nstatic void stgMenu_LearnSensorCBS(void)\n&#123;\n\tuint8_t keys,dat,tBuff[3];\n\tstatic uint8_t PairingComplete = 0;\n\tstatic uint16_t Timer = 0;\n\t//用于设置探测器参数时初始化探测器信息\n\tStu_DTC stuTempDevice; \t\t\n\tif(pModeMenu->refreshScreenCmd == SCREEN_CMD_RESET)\n\t&#123;\n\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_NULL;\n\t\tQueueEmpty(RFDRcvMsg);\n\t\t//pMenu = &amp;settingModeMenu[0];\n\t\thal_Oled_Clear();\n\t\thal_Oled_ShowString(28,0,\"Learning DTC\",12,1);\n\t\thal_Oled_ShowString(43,28,\"Pairing...\",8,1);\n\t\thal_Oled_Refresh();\n\t\tkeys = 0xFF;\n\t\tPairingComplete = 0; \n\t\tTimer = 0;\n\t&#125;\n\tif(QueueDataSize(RFDRcvMsg) &amp;&amp; (!PairingComplete))\n\t&#123;\n\t\tQueueDataPop(RFDRcvMsg,&amp;dat);\n\t\tif(dat == '#')\n\t\t&#123;\n\t\t\tQueueDataPop(RFDRcvMsg,&amp;tBuff[2]);\n\t\t\tQueueDataPop(RFDRcvMsg,&amp;tBuff[1]);\n\t\t\tQueueDataPop(RFDRcvMsg,&amp;tBuff[0]);\n\t\t\thal_Oled_ClearArea(0,28,128,36);\t\t//清屏\n\t\t\tstuTempDevice.Code[2] = tBuff[2];\n\t\t\tstuTempDevice.Code[1] = tBuff[1];\n\t\t\tstuTempDevice.Code[0] = tBuff[0];\n\t\t\tif((stuTempDevice.Code[0]==SENSOR_CODE_DOOR_OPEN) ||\n\t\t\t  (stuTempDevice.Code[0]==SENSOR_CODE_DOOR_CLOSE) ||\n\t\t\t  (stuTempDevice.Code[0]==SENSOR_CODE_DOOR_TAMPER)||\n\t\t\t  (stuTempDevice.Code[0]==SENSOR_CODE_DOOR_LOWPWR))\n\t\t\t&#123;\n\t\t\t\t//是无线门磁码\n\t\t\t\tstuTempDevice.DTCType = DTC_DOOR;\n\t\t\t&#125;\n\t\t\telse if((stuTempDevice.Code[0]==SENSOR_CODE_REMOTE_ENARM) ||\n\t\t\t       (stuTempDevice.Code[0]==SENSOR_CODE_REMOTE_DISARM) ||\n\t\t\t      (stuTempDevice.Code[0]==SENSOR_CODE_REMOTE_HOMEARM) ||\n\t\t\t      (stuTempDevice.Code[0]==SENSOR_CODE_REMOTE_SOS))\n\t\t\t&#123;\n\t\t\t\t//无线遥控器码\n\t\t\t\tstuTempDevice.DTCType = DTC_REMOTE;\n\t\t\t&#125;\n\t\t\telse if((stuTempDevice.Code[0]==SENSOR_CODE_PIR)||\n\t\t\t (stuTempDevice.Code[0]==SENSOR_CODE_PIR_LOWPWR)|| \n\t\t\t(stuTempDevice.Code[0]==SENSOR_CODE_PIR_TAMPER))\n\t\t\t&#123;\n\t\t\t\t//无线红外码\n\t\t\t\tstuTempDevice.DTCType = DTC_PIR;\n\t\t\t&#125;\n\t\t\tstuTempDevice.ZoneType = ZONE_TYP_1ST;\n\t\t\tif(AddDtc(&amp;stuTempDevice) != 0xFF)\n\t\t\t&#123;\n\t\t\t\tswitch(stuTempDevice.DTCType)\n\t\t\t\t&#123;\n\t\t\t\t\tcase DTC_DOOR:\n\t\t\t\t\t\thal_Oled_ShowString(34,28,\"Success!\",8,1);\n\t\t\t\t\t\thal_Oled_ShowString(16,36,\"Added door dtc..\",8,1);\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase DTC_REMOTE:\n\t\t\t\t\t\thal_Oled_ShowString(34,28,\"Success!\",8,1);\n\t\t\t\t\t\thal_Oled_ShowString(7,36,\"Added remote dtc..\",8,1);\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase DTC_PIR:\n\t\t\t\t\t\thal_Oled_ShowString(34,28,\"Success!\",8,1);\n\t\t\t\t\t\thal_Oled_ShowString(19,36,\"Added pir dtc..\",8,1);\n\t\t\t\t\tbreak;\n\t\t\t\t&#125;\n\t\t\t\thal_Oled_Refresh();\n\t\t\t\tPairingComplete = 1;\t\t//配对完成标志\n\t\t\t\tTimer = 0;\t\t \n\t\t\t&#125;else\n\t\t\t&#123;\n\t\t\t\thal_Oled_ShowString(34,28,\"Fail...\",8,1);\n\t\t\t\thal_Oled_Refresh();\n\t\t\t&#125;\t\t\t\n\t\t&#125;\t\t\n\t&#125;\t\n\tif(pModeMenu->keyVal != 0xff)\n\t&#123;\n\t\tkeys = pModeMenu->keyVal;\n\t\tpModeMenu->keyVal = 0xFF;\t//恢复菜单按键值\n\t\tswitch(keys)\n\t\t&#123;\n\t\t\tcase KEY5_CLICK_RELEASE:\t//取消\n\t\t\t\tpModeMenu = pModeMenu->pParent;\n\t\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RECOVER;\n\t\t\tbreak;\n\t\t\tcase KEY5_LONG_PRESS:\t\t//返回桌面\n\t\t\t\tpModeMenu = &amp;generalModeMenu[GNL_MENU_DESKTOP];\n\t\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RESET;\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n\tif(PairingComplete)\n\t&#123;\n\t\tTimer++;\n\t\tif(Timer > 150)//+1=10ms,10*150=1500ms=1.5s\n\t\t&#123;\n\t\t\tTimer = 0;\n\t\t\tpModeMenu = pModeMenu->pParent;\t\t\t//1.5秒时间到，自动返回父级菜单\n\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RESET;\n\t\t&#125;\n\t&#125;\n&#125;\n\nSTM32驱动OLED实现探测器列表多级子菜单功能探测器列表的作用\n\n\n\n\n\n\n\n\n\n查看目前已经配对的探测器数量\n查看指定探测器的详细属性\n编辑指定探测器的属性\n删除指定探测器\n\n\n//探测器列表菜单处理函数\nstatic void stgMenu_DTCListCBS(void)\n&#123;\n\tuint8_t keys;\n\tuint8_t i,j;\n\tuint8_t ClrScreenFlag;\n\tStu_DTC tStuDtc;\t \n\t//static Stu_DTC StuDTCtemp[PARA_DTC_SUM];\n\tstatic char DtcNameBuff[PARA_DTC_SUM][16];//这个比上面那个节省空间\n\tstatic stu_mode_menu settingMode_DTCList_Sub_Menu[PARA_DTC_SUM];\n\tstatic stu_mode_menu* pMenu;\n\t//用来备份上一次菜单选项，主要用于刷屏判断\n\tstatic stu_mode_menu* bpMenu=0;\t\t\n\t//用来记录当前选中菜单的位置\n\tstatic uint8_t stgMainMenuSelectedPos=0;\t\n\t//这两个结构是为了上下切换菜单时做翻页处理\n\tstatic stu_mode_menu* MHead,*MTail;\t\t\n\t//用来动态指示菜单下标,最终这个就是已学习探测器的总数量\t\n\tstatic uint8_t pMenuIdx=0;\t\t\n\tif(pModeMenu->refreshScreenCmd == SCREEN_CMD_RESET)\n\t&#123;\n\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_NULL;\t\t\n\t\tpMenuIdx = 0;\n\t\tstgMainMenuSelectedPos = 1;\n\t\tbpMenu = 0;\n\t\tClrScreenFlag = 1;\t\t \n\t\tkeys = 0xFF;\t\t\n\t\tpMenu = settingMode_DTCList_Sub_Menu;\t\t\n\t\thal_Oled_Clear();\n\t\thal_Oled_ShowString(40,0,\"Dtc List\",12,1);\n\t\thal_Oled_Refresh();\t\t\n\t\t//逐个判断，把配对的探测器都找出来\n\t\tfor(i=0; i&lt;PARA_DTC_SUM; i++)\n\t\t&#123;\n\t\t\tif(CheckPresenceofDtc(i))\n\t\t\t&#123;\n\t\t\t\tGetDtcStu(&amp;tStuDtc,i);\n\t\t\t\t(pMenu+pMenuIdx)->ID = pMenuIdx;\n\t\t\t\t//(pMenu+0)->ID = 0;\t\t\t\t\n\t\t\t\t(pMenu+pMenuIdx)->menuPos = STG_SUB_3_MENU_POS;\n\t\t\t\t(pMenu+pMenuIdx)->reserved = tStuDtc.ID-1;\n\t\t\t\t//StuDTCtemp[pMenuIdx].ID = tStuDtc.ID;\n\t\t\t\tfor(j=0; j&lt;16; j++)\n\t\t\t\t&#123;\n\t\t\t\t\t//StuDTCtemp[pMenuIdx].Name[j] = tStuDtc.Name[j];\n\t\t\t\t\tDtcNameBuff[pMenuIdx][j] = tStuDtc.Name[j];\n\t\t\t\t&#125;\t\t\t \n\t\t\t\t//(pMenu+pMenuIdx)->pModeType = StuDTCtemp[pMenuIdx].Name;\t\t\t\t\n\t\t\t\t(pMenu+pMenuIdx)->pModeType = DtcNameBuff[pMenuIdx];\n\t\t\t\tpMenuIdx++;\n\t\t\t&#125;\n\t\t&#125;\t\t\n\t\tif(pMenuIdx != 0)\n\t\t&#123;\n\t\t\t//有探测器存在的情况\n\t\t\tMenuDoubleListInit(&amp;settingMode_DTCList_Sub_Menu[0]);\t\t\t\n\t\t\tfor(i = 1;i &lt; pMenuIdx;++i)\n\t\t\t&#123;\n\t\t\t\tMenuDoubleListPushBack(&amp;settingMode_DTCList_Sub_Menu[0],\n\t\t\t\t                       &amp;settingMode_DTCList_Sub_Menu[i]);\n\t\t\t\tsettingMode_DTCList_Sub_Menu[i-1].pParent \n\t\t\t =  &amp;settingModeMenu[STG_MENU_MAIN_SETTING];\n\t\t\t&#125;\n\t\t&#125;else\n\t\t&#123;\n\t\t\t//没有探测器\n\t\t\tbpMenu = pMenu;\n\t\t\thal_Oled_ShowString(0,14,\" No detectors.\",8,1);\n\t\t\thal_Oled_Refresh();\n\t\t&#125;\n\t\tMHead = pMenu;\t\t\t//记录当前显示菜单第一项\n\t\tpMenuIdx &lt; 5 ? MTail = pMenu->pLast\n\t\t             : (MTail = pMenu+3);\t\t//记录当前显示菜单最后一项,一页显示4行\t\t\n\t&#125;\n\telse if(pModeMenu->refreshScreenCmd==SCREEN_CMD_RECOVER)\n\t&#123;\t\n\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_NULL;\n\t\t//恢复之前的选择位置显示\n\t\thal_Oled_Clear();\n\t\thal_Oled_ShowString(40,0,\"Dtc List\",12,1);\n\t\thal_Oled_Refresh();\n\t\tkeys = 0xFF;\n\t\tClrScreenFlag = 1;\n\t\tbpMenu = 0;\t\t\n\t&#125;\n\t\n\tif(pModeMenu->keyVal != 0xff)\n\t&#123;\n\t\tkeys = pModeMenu->keyVal;\n\t\tpModeMenu->keyVal = 0xFF;\t//恢复菜单按键值\n\t\tswitch(keys)\n\t\t&#123;\n\t\t\tcase KEY1_CLICK_RELEASE:\t\t//上\n\t\t\t\tif(pMenuIdx&lt;2)\n\t\t\t\t&#123;\n\t\t\t\t\t//只有一个菜单不做处理\n\t\t\t\t&#125;\n\t\t\t\telse if(pMenuIdx &lt; 5)\n\t\t\t\t&#123;\n\t\t\t\t\t//不清屏，直接刷新局部显示,只有一页，也就是4个探测器的时候\n\t\t\t\t\t//取消选中本菜单显示\n\t\t\t\t\thal_Oled_ShowString(0,14*stgMainMenuSelectedPos,pMenu->pModeType,8,1);\t\t\n\t\t\t\t\thal_Oled_Refresh();\n\t\t\t\t\tpMenu = pMenu->pLast;\t\t\t\t\t\n\t\t\t\t\tstgMainMenuSelectedPos ==1\t//判断是否选中的是第一行\t\n\t\t\t\t\t//头尾指针不变，只把当前菜单指向上一个\n\t\t\t\t\t?stgMainMenuSelectedPos = pMenuIdx\t\t\t\t\t\t\n\t\t\t\t\t:stgMainMenuSelectedPos--;\t\t\t\t\t\n\t\t\t\t&#125;else if(pMenuIdx > 4)\t//当前探测器超过4个\n\t\t\t\t&#123;\n\t\t\t\t\tif(stgMainMenuSelectedPos ==1)\t//判断是否选中的是第一行\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tMHead = MHead->pLast;\n\t\t\t\t\t\tpMenu = pMenu->pLast;\n\t\t\t\t\t\tMTail = MTail->pLast;\n\t\t\t\t\t\tstgMainMenuSelectedPos = 1;\n\t\t\t\t\t\tClrScreenFlag = 1;\n\t\t\t\t\t&#125;else\n\t\t\t\t\t&#123;\n\t\t\t\t\t\t//取消选中本菜单显示\n\t\t\t\t\t\thal_Oled_ShowString(0,14*stgMainMenuSelectedPos,pMenu->pModeType,8,1);\t\t\n\t\t\t\t\t\thal_Oled_Refresh();\n\t\t\t\t\t\t//切换上一个选项\n\t\t\t\t\t\tpMenu = pMenu->pLast;\n\t\t\t\t\t\tstgMainMenuSelectedPos--;\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\tbreak;\t\t\t\n\t\t\tcase KEY2_CLICK_RELEASE:\t\t//下 \n\t\t\t\tif(pMenuIdx&lt;2)\n\t\t\t\t&#123;\n\t\t\t\t\t//只有一个菜单不做处理\n\t\t\t\t&#125;\n\t\t\t\telse if(pMenuIdx &lt; 5)\n\t\t\t\t&#123;\n\t\t\t\t\t//不清屏，直接刷新局部显示,只有一页，也就是不超过4个探测器的时候\n\t\t\t\t\t//取消选中本菜单显示\n\t\t\t\t\thal_Oled_ShowString(0,14*stgMainMenuSelectedPos,pMenu->pModeType,8,1);\t\t\n\t\t\t\t\thal_Oled_Refresh();\t\t\t\t\t\n\t\t\t\t\tpMenu = pMenu->pNext;\n\t\t\t\t\tstgMainMenuSelectedPos ==pMenuIdx\t//判断是否选中的是第4行\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t?stgMainMenuSelectedPos = 1\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//切换下一个选项\n\t\t\t\t\t:stgMainMenuSelectedPos++;\t\t\t\t\t\n\t\t\t\t&#125;else if(pMenuIdx > 4)\t//当前探测器超过4个\n\t\t\t\t&#123;\n\t\t\t\t\tif(stgMainMenuSelectedPos ==4)\t//判断是否选中的是第一行\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tMHead = MHead->pNext;\t\n\t\t\t\t\t\tpMenu = pMenu->pNext;\n\t\t\t\t\t\tMTail = pMenu;\n\t\t\t\t\t\tstgMainMenuSelectedPos = 4;\n\t\t\t\t\t\tClrScreenFlag = 1;\n\t\t\t\t\t&#125;else\n\t\t\t\t\t&#123;\n\t\t\t\t\t\t//取消选中本菜单显示\n\t\t\t\t\t\thal_Oled_ShowString(0,14*stgMainMenuSelectedPos,pMenu->pModeType,8,1);\t\t\n\t\t\t\t\t\thal_Oled_Refresh();\n\t\t\t\t\t\t//切换下一个选项\n\t\t\t\t\t\tpMenu = pMenu->pNext;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tstgMainMenuSelectedPos++;\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\tbreak;\t\t\t\n\t\t\tcase KEY6_CLICK_RELEASE:\t\t\t//确定\n\t\t\t\tif(pMenuIdx>0)\n\t\t\t\t&#123;\n\t\t\t\t\tpModeMenu = &amp;DL_ZX_Review[STG_MENU_DL_ZX_REVIEW_MAIN]; \n\t\t\t\t\tpModeMenu->reserved = pMenu->reserved;\t//这里用于传递后面要查看、修改、删除探测器的ID号\n\t\t\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RESET;\n\t\t\t\t&#125;\n\t\t\tbreak;\t\t\t\n\t\t\tcase KEY5_CLICK_RELEASE:\t//取消\n\t\t\t\tpModeMenu = pModeMenu->pParent;\n\t\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RECOVER;\n\t\t\tbreak;\n\t\t\tcase KEY5_LONG_PRESS:\t\t//返回桌面\n\t\t\t\tpModeMenu = &amp;generalModeMenu[GNL_MENU_DESKTOP];;\n\t\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RESET;\n\t\t\tbreak;\t\t\t\n\t\t&#125;\n\t&#125;\t\n\tif(bpMenu != pMenu)\n\t&#123;\n\t\tbpMenu = pMenu;\n\t\tif(ClrScreenFlag)\n\t\t&#123;\n\t\t\tClrScreenFlag = 0;\n\t\t\tpMenu = MHead;\n\t\t\thal_Oled_ClearArea(0,14,128,50);\t\t//清屏\n\t\t\thal_Oled_Refresh();\n\t\t\tif(pMenuIdx &lt;4)\n\t\t\t&#123;\n\t\t\t\tfor(i=0; i&lt;pMenuIdx; i++)\n\t\t\t\t&#123;\n\t\t\t\t\thal_Oled_ShowString(0,14*(i+1),pMenu->pModeType,8,1);\n\t\t\t\t\thal_Oled_Refresh();\n\t\t\t\t\tpMenu = pMenu->pNext;\n\t\t\t\t&#125;\n\t\t\t&#125;else\n\t\t\t&#123;\n\t\t\t\tfor(i=1; i&lt;5; i++)\n\t\t\t\t&#123;\n\t\t\t\t\thal_Oled_ShowString(0,14*i,pMenu->pModeType,8,1);\n\t\t\t\t\thal_Oled_Refresh();\n\t\t\t\t\tpMenu = pMenu->pNext;\n\t\t\t\t&#125; \n\t\t\t&#125;\n\t\t\tpMenu = bpMenu;\n\t\t\thal_Oled_ShowString(0,14*stgMainMenuSelectedPos,pMenu->pModeType,8,0);\n\t\t\thal_Oled_Refresh();\n\t\t\t \n\t\t&#125;else\n\t\t&#123; \n\t\t\thal_Oled_ShowString(0,14*stgMainMenuSelectedPos,pMenu->pModeType,8,0);\t\n\t\t\thal_Oled_Refresh();\n\t\t\t\n\t\t&#125;\t\n\t&#125; \n&#125;\n\n探测器列表信息主菜单\n\n\n\n\n\n\n\n\n\n//探测器列表信息主菜单\nstatic void stgMenu_dl_ReviewMainCBS(void)\n&#123;\n\tuint8_t keys = 0xFF;\n\tuint8_t i,ClrScreenFlag=0;\n\tStu_DTC tStuDtc;\n\tstatic stu_mode_menu *MHead;\t\t//这两个结构用来方便显示，页面的头跟尾\n\tstatic stu_mode_menu *pMenu,*bpMenu=0;\t//用来记录当前选中的菜单\n\tstatic uint8_t stgMainMenuSelectedPos=0;\t\t\t\t \n\tif(pModeMenu->refreshScreenCmd == SCREEN_CMD_RESET)\n\t&#123;\t//执行页面切换时屏幕刷新显示 \n\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_NULL;\n\t\tif(CheckPresenceofDtc(pModeMenu->reserved))\n\t\t&#123;\n\t\t\tGetDtcStu(&amp;tStuDtc,pModeMenu->reserved);\t//读取探测器信息\n\t\t&#125;\n\t\thal_Oled_Clear();\n\t\thal_Oled_ShowString(40,0,tStuDtc.Name,12,1);\n\t\thal_Oled_Refresh();\n\t\tpMenu = &amp;DL_ZX_Review[1];\n\t\tstgMainMenuSelectedPos = 1;\n\t\tMHead = pMenu;\t\t\t//记录当前显示菜单第一项\n\t\tClrScreenFlag = 1;\n\t\tbpMenu = 0;\n\t\tkeys = 0xFF;\n\t&#125;else if(pModeMenu->refreshScreenCmd==SCREEN_CMD_RECOVER)\n\t&#123;\n\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_NULL;\n\t\t//恢复之前的选择位置显示\n\t\tif(CheckPresenceofDtc(pModeMenu->reserved))\n\t\t&#123;\n\t\t\tGetDtcStu(&amp;tStuDtc,pModeMenu->reserved);\t//读取探测器信息\n\t\t&#125;\n\t\thal_Oled_Clear();\n\t\thal_Oled_ShowString(40,0,tStuDtc.Name,12,1);\n\t\thal_Oled_Refresh();\n\t\tkeys = 0xFF;\n\t\tClrScreenFlag = 1;\n\t\tbpMenu = 0;\n\t&#125;\n\tif(pModeMenu->keyVal != 0xff)\n\t&#123;\n\t\tkeys = pModeMenu->keyVal;\n\t\tpModeMenu->keyVal = 0xFF;\t//恢复菜单按键值\n\t\tswitch(keys)\n\t\t&#123;\n\t\t\tcase KEY1_CLICK:\t\t//上\n\t\t\t\tif(stgMainMenuSelectedPos ==1)\n\t\t\t\t&#123;\n\t\t\t\t\tpMenu = pMenu->pLast;\n\t\t\t\t\tstgMainMenuSelectedPos = 3;\n\t\t\t\t\tClrScreenFlag = 1;\n\t\t\t\t&#125;else\n\t\t\t\t&#123;//取消选中本菜单显示\n\t\t\t\t\thal_Oled_ShowString(0,14*stgMainMenuSelectedPos,pMenu->pModeType,8,1);\t\t\n\t\t\t\t\thal_Oled_Refresh();\n\t\t\t\t\tpMenu = pMenu->pLast;\n\t\t\t\t\tstgMainMenuSelectedPos--;\n\t\t\t\t&#125;\n\t\t\tbreak;\n\t\t\tcase KEY2_CLICK:\t\t//下\n\t\t\t\tif(stgMainMenuSelectedPos ==3)\n\t\t\t\t&#123;\n\t\t\t\t\tpMenu = pMenu->pNext;\n\t\t\t\t\tstgMainMenuSelectedPos = 1;\n\t\t\t\t\tClrScreenFlag = 1;\n\t\t\t\t&#125;else\n\t\t\t\t&#123;//取消选中本菜单显示\n\t\t\t\t\thal_Oled_ShowString(0,14*stgMainMenuSelectedPos,pMenu->pModeType,8,1);\t\t\n\t\t\t\t\thal_Oled_Refresh();\n\t\t\t\t\tpMenu = pMenu->pNext;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\tstgMainMenuSelectedPos++;\n\t\t\t\t&#125;\n\t\t\tbreak;\n\t\t\tcase KEY6_CLICK_RELEASE:\n\t\t\t    //继续把指定探测器结构体数组下标传递下去\n\t\t\t\tpMenu->reserved = pModeMenu->reserved;\t\n\t\t\t\tpModeMenu = pMenu;\n\t\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RESET;\n\t\t\tbreak;\n\t\t\tcase KEY5_CLICK_RELEASE:\n\t\t\t    //这里不能直接返回父级，因为探测器个数是动态的，父级没初始化\n\t\t\t\tpModeMenu = &amp;settingModeMenu[STG_MENU_DTC_LIST];\t\n\t\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RECOVER;\n\t\t\tbreak;\n\t\t\tcase KEY5_LONG_PRESS:\n\t\t\t\tpModeMenu = &amp;generalModeMenu[GNL_MENU_DESKTOP];;\n\t\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RESET;\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n\tif(bpMenu != pMenu)\n\t&#123;\n\t\tbpMenu = pMenu;\n\t\tif(ClrScreenFlag)\n\t\t&#123;\n\t\t\tClrScreenFlag = 0;\n\t\t\tpMenu = MHead;\n\t\t\thal_Oled_ClearArea(0,14,128,50);\t\t//清屏\n\t\t\thal_Oled_Refresh();\n\t\t\tfor(i=0; i&lt;3; i++)\n\t\t\t&#123;\n\t\t\t\thal_Oled_ShowString(0,14*(i+1),pMenu->pModeType,8,1);\n\t\t\t\thal_Oled_Refresh();\n\t\t\t\tpMenu = pMenu->pNext;\n\t\t\t&#125; \n\t\t\tpMenu = bpMenu;\n\t\t\thal_Oled_ShowString(0,14*stgMainMenuSelectedPos,pMenu->pModeType,8,0);\n\t\t\thal_Oled_Refresh();\n\t\t\t \n\t\t&#125;else\n\t\t&#123; \n\t\t\thal_Oled_ShowString(0,14*stgMainMenuSelectedPos,pMenu->pModeType,8,0);\t\n\t\t\thal_Oled_Refresh();\n\t\t&#125;\t\t \n\t&#125;\n&#125;\n\n探测器列表信息查看\n\n\n\n\n\n\n\n\n\n //探测器列表信息查看\nstatic void stgMenu_dl_ReviewCBS(void)\n&#123;\n\tunsigned char keys = 0xFF;\n\tStu_DTC tStuDtc;\n\tunsigned char temp[6];\n\tif(pModeMenu->refreshScreenCmd == SCREEN_CMD_RESET)\n\t&#123;\t//执行页面切换时屏幕刷新显示 \n\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_NULL;\n\t\tif(CheckPresenceofDtc(pModeMenu->reserved))\n\t\t&#123;\n\t\t\tGetDtcStu(&amp;tStuDtc,pModeMenu->reserved);\n\t\t&#125;\n\t\thal_Oled_Clear();\n\t\thal_Oled_ShowString(40,0,pModeMenu->pModeType,12,1);\n\t\thal_Oled_ShowString(0,16,\"&lt;Name>: \",8,1); \n\t\t//&lt;Name>: 8个字符，8*6=48\n\t\thal_Oled_ShowString(48,16,tStuDtc.Name,8,1);\n\t\thal_Oled_ShowString(0,28,\"&lt;Type>: \",8,1);\n\t\tif(tStuDtc.DTCType == DTC_DOOR)\n\t\t&#123;\n\t\t\thal_Oled_ShowString(48,28,\"door dtc\",8,1);\n\t\t&#125;else if(tStuDtc.DTCType == DTC_PIR)\n\t\t&#123;\n\t\t\thal_Oled_ShowString(48,28,\"pir dtc\",8,1);\n\t\t&#125;else if(tStuDtc.DTCType == DTC_REMOTE)\n\t\t&#123;\n\t\t\thal_Oled_ShowString(48,28,\"remote\",8,1);\n\t\t&#125;\n\t\thal_Oled_ShowString(0,40,\"&lt;ZoneType>: \",8,1);\n\t\tif(tStuDtc.ZoneType == ZONE_TYP_24HOURS)\n\t\t&#123;\n\t\t\thal_Oled_ShowString(72,40,\"24 hrs\",8,1);\n\t\t&#125;else if(tStuDtc.ZoneType == ZONE_TYP_1ST)\n\t\t&#123;\n\t\t\thal_Oled_ShowString(72,40,\"1ST\",8,1);\n\t\t&#125;else if(tStuDtc.ZoneType == ZONE_TYP_2ND)\n\t\t&#123;\n\t\t\thal_Oled_ShowString(72,40,\"2ND\",8,1);\n\t\t&#125;\n\t\thal_Oled_ShowString(0,52,\"&lt;RFCode>: \",8,1);\n\t\tHexToAscii(tStuDtc.Code,temp,3);\n\t\thal_Oled_ShowChar(60,52,temp[4],8,1);\n\t\thal_Oled_ShowChar(66,52,temp[5],8,1);\n\t\thal_Oled_ShowChar(72,52,' ',8,1);\n\t\thal_Oled_ShowChar(80,52,temp[2],8,1);\n\t\thal_Oled_ShowChar(86,52,temp[3],8,1);\n\t\thal_Oled_Refresh();\n\t&#125;\n\tif(pModeMenu->keyVal != 0xff)\n\t&#123;\n\t\tkeys = pModeMenu->keyVal;\n\t\tpModeMenu->keyVal = 0xFF;\t//恢复菜单按键值\n\t\tswitch(keys)\n\t\t&#123;\n\t\t\tcase KEY5_CLICK_RELEASE:\n\t\t\t\tpModeMenu = &amp;DL_ZX_Review[STG_MENU_DL_ZX_REVIEW_MAIN];\n\t\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RECOVER;\n\t\t\tbreak;\n\t\t\tcase KEY6_CLICK_RELEASE:\n\t\t\t\tpModeMenu = &amp;DL_ZX_Review[STG_MENU_DL_ZX_REVIEW_MAIN];\n\t\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RECOVER;\n\t\t\tbreak;\n\t\t\tcase KEY5_LONG_PRESS:\n\t\t\t\tpModeMenu = &amp;generalModeMenu[GNL_MENU_DESKTOP];\n\t\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RESET;\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n&#125;\n\n探测器编辑\n\n\n\n\n\n\n\n\n\n\n//探测器编辑\nstatic void stgMenu_dl_EditCBS(void)\n&#123;\n\tuint8_t keys = 0xFF;\n\tstatic Stu_DTC tStuDtc;\n\tstatic uint16_t timer = 0;\n\tstatic uint8_t editComplete = 0;\n\tstatic uint8_t* pDL_ZX_Edit_DTCType_Val[DTC_TYP_SUM] =\n\t&#123;\n\t\t\"door dtc\",\n\t\t\"pir dtc\",\n\t\t\"remote\",\n\t&#125;;\n\tstatic uint8_t* pDL_ZX_Edit_ZoneType_Val[STG_DEV_AT_SUM] =\n\t&#123;\n\t\t\"24 hrs\",\n\t\t\"1ST\",\n\t\t\"2ND\",\n\t&#125;;\n\tstatic uint8_t stgMainMenuSelectedPos=0;\n\tstatic uint8_t setValue = DTC_DOOR;\n\tstu_mode_menu* updateMenu;//一个临时更新菜单界面\n\tif(pModeMenu->refreshScreenCmd == SCREEN_CMD_RESET)\n\t&#123;\t//执行页面切换时屏幕刷新显示 \n\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_NULL;\n\t\tstgMainMenuSelectedPos = 0; \n\t\tif(CheckPresenceofDtc(pModeMenu->reserved))\n\t\t&#123;\n\t\t\tGetDtcStu(&amp;tStuDtc,pModeMenu->reserved);\n\t\t&#125;\n\t\tstgMainMenuSelectedPos = 0;\n\t\tsetValue = tStuDtc.DTCType;\n\t\thal_Oled_Clear();\n\t\thal_Oled_ShowString(40,0,pModeMenu->pModeType,12,1);\n\t\thal_Oled_Refresh();\n\t\thal_Oled_ShowString(0,16,\"&lt;Name>: \",8,1); \n\t\thal_Oled_ShowString(48,16,tStuDtc.Name,8,1);\n\t\thal_Oled_ShowString(0,28,\"&lt;Type>: \",8,1);\n\t\thal_Oled_Refresh();\n\t\tif(tStuDtc.DTCType == DTC_DOOR)\n\t\t&#123;\n\t\t\thal_Oled_ShowString(48,28,\"door dtc\",8,0);\n\t\t&#125;else if(tStuDtc.DTCType == DTC_PIR)\n\t\t&#123;\n\t\t\thal_Oled_ShowString(48,28,\"pir dtc\",8,0);\n\t\t&#125;else if(tStuDtc.DTCType == DTC_REMOTE)\n\t\t&#123;\n\t\t\thal_Oled_ShowString(48,28,\"remote\",8,0);\n\t\t&#125;\n\t\thal_Oled_Refresh();\n\t\thal_Oled_ShowString(0,40,\"&lt;ZoneType>: \",8,1);\n\t\thal_Oled_Refresh();\n\t\tif(tStuDtc.ZoneType == ZONE_TYP_24HOURS)\n\t\t&#123;\n\t\t\thal_Oled_ShowString(72,40,\"24 hrs\",8,1);\n\t\t&#125;else if(tStuDtc.ZoneType == ZONE_TYP_1ST)\n\t\t&#123;\n\t\t\thal_Oled_ShowString(72,40,\"1ST\",8,1);\n\t\t&#125;else if(tStuDtc.ZoneType == ZONE_TYP_2ND)\n\t\t&#123;\n\t\t\thal_Oled_ShowString(72,40,\"2ND\",8,1);\n\t\t&#125;\n\t\thal_Oled_Refresh();\n\t\teditComplete = 0;\n\t\ttimer = 0;\n\t&#125;\n\tif(pModeMenu->keyVal != 0xff)\n\t&#123;\n\t\tkeys = pModeMenu->keyVal;\n\t\tpModeMenu->keyVal = 0xFF;\t//恢复菜单按键值\n\t\tif(keys == KEY3_CLICK_RELEASE)\n\t\t&#123;\n\t\t\tif(stgMainMenuSelectedPos == 0)\t\t\n\t\t\t&#123;\n\t\t\t\t//设置Type\n\t\t\t\tif(setValue == DTC_DOOR)\n\t\t\t\t&#123;\n\t\t\t\t\tsetValue = DTC_TYP_SUM-1;\n\t\t\t\t&#125;else\n\t\t\t\t&#123;\n\t\t\t\t\tsetValue--;\n\t\t\t\t&#125;\n\t\t\t\t//更新探测器参数\n\t\t\t\ttStuDtc.DTCType = (DTC_TYPE_TYPEDEF)setValue;\t\t\t\n\t\t\t\thal_Oled_ClearArea(48,28,80,8);\t\t//清屏\n\t\t\t\thal_Oled_ShowString(48,28,pDL_ZX_Edit_DTCType_Val[setValue],8,0);\n\t\t\t\thal_Oled_Refresh();\n\t\t\t&#125;else if(stgMainMenuSelectedPos == 1)\n\t\t\t&#123;\n\t\t\t\t//设置Zone type\n\t\t\t\tif(setValue == ZONE_TYP_24HOURS)\n\t\t\t\t&#123;\n\t\t\t\t\tsetValue = STG_DEV_AT_SUM-1;\n\t\t\t\t&#125;else\n\t\t\t\t&#123;\n\t\t\t\t\tsetValue--;\n\t\t\t\t&#125;\n\t\t\t\t//更新探测器参数\n\t\t\t\ttStuDtc.ZoneType = (ZONE_TYPED_TYPEDEF)setValue;\t\t\t\n\t\t\t\thal_Oled_ClearArea(72,40,56,8);\t\t//清屏\n\t\t\t\thal_Oled_ShowString(72,40,pDL_ZX_Edit_ZoneType_Val[setValue],8,0);\n\t\t\t\thal_Oled_Refresh();\n\t\t\t&#125;\n\t\t&#125;else if(keys == KEY4_CLICK_RELEASE)\n\t\t&#123;\n\t\t\tif(stgMainMenuSelectedPos == 0)\n\t\t\t&#123;\n\t\t\t\t//设置Type\n\t\t\t\tif(setValue == (DTC_TYP_SUM-1))\n\t\t\t\t&#123;\n\t\t\t\t\tsetValue = 0;\n\t\t\t\t&#125;else\n\t\t\t\t&#123;\n\t\t\t\t\tsetValue++;\n\t\t\t\t&#125;\n\t\t\t\t//更新探测器参数\n\t\t\t\ttStuDtc.DTCType = (DTC_TYPE_TYPEDEF)setValue;\t\t\t\n\t\t\t\thal_Oled_ClearArea(48,28,80,8);\t\t//清屏\n\t\t\t\thal_Oled_ShowString(48,28,pDL_ZX_Edit_DTCType_Val[setValue],8,0);\n\t\t\t\thal_Oled_Refresh();\n\t\t\t&#125;else if(stgMainMenuSelectedPos == 1)\n\t\t\t&#123;\n\t\t\t\t//设置Zone type\n\t\t\t\tif(setValue == (STG_DEV_AT_SUM-1))\n\t\t\t\t&#123;\n\t\t\t\t\tsetValue = 0;\n\t\t\t\t&#125;else\n\t\t\t\t&#123;\n\t\t\t\t\tsetValue++;\n\t\t\t\t&#125;\n\t\t\t\t//更新探测器参数\n\t\t\t\ttStuDtc.ZoneType = (ZONE_TYPED_TYPEDEF)setValue;\t\t\t\n\t\t\t\thal_Oled_ClearArea(72,40,56,8);\t\t//清屏\n\t\t\t\thal_Oled_ShowString(72,40,pDL_ZX_Edit_ZoneType_Val[setValue],8,0);\n\t\t\t\thal_Oled_Refresh();\n\t\t\t&#125;\n\t\t&#125;else if((keys==KEY1_CLICK_RELEASE) || (keys==KEY2_CLICK_RELEASE))\n\t\t&#123;\n\t\t\tif(stgMainMenuSelectedPos == 0)\n\t\t\t&#123;\n\t\t\t\tstgMainMenuSelectedPos = 1;\n\t\t\t\tsetValue = tStuDtc.ZoneType;\n\t\t\t\thal_Oled_ClearArea(48,28,80,8);\t\t//清屏\n\t\t\t\t//恢复探测器类型未选中显示\n\t\t\t\thal_Oled_ShowString(48,28,pDL_ZX_Edit_DTCType_Val[tStuDtc.DTCType],8,1);\t\n\n\t\t\t\thal_Oled_ClearArea(72,40,56,8);\t\t//清屏\n\t\t\t\t//切换选中菜单到防区类型\n\t\t\t\thal_Oled_ShowString(72,40,pDL_ZX_Edit_ZoneType_Val[setValue],8,0);\t\t\t\n\t\t\t\thal_Oled_Refresh();\n\t\t\t&#125;else\n\t\t\t&#123;\n\t\t\t\tstgMainMenuSelectedPos = 0;\n\t\t\t\tsetValue = tStuDtc.DTCType;\n\t\t\t\thal_Oled_ClearArea(48,28,80,8);\t\t//清屏\n\t\t\t\t//切换选中菜单到探测器类型\n\t\t\t\thal_Oled_ShowString(48,28,pDL_ZX_Edit_DTCType_Val[setValue],8,0);\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\thal_Oled_ClearArea(72,40,56,8);\t\t//清屏\n\t\t\t\t//恢复探测器防区类型未选中显示\n\t\t\t\thal_Oled_ShowString(72,40,pDL_ZX_Edit_ZoneType_Val[tStuDtc.ZoneType],8,1);\t\n\t\t\t\t\n\t\t\t\thal_Oled_Refresh();\n\t\t\t&#125;\n\t\t&#125;else if(keys == KEY5_CLICK_RELEASE)\n\t\t&#123;\n\t\t\tpModeMenu = &amp;DL_ZX_Review[STG_MENU_DL_ZX_REVIEW_MAIN];\n\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RECOVER;\n\t\t\t\t \n\t\t&#125;else if(keys == KEY6_CLICK_RELEASE)\n\t\t&#123;\n\t\t\ttimer = 0;\n\t\t\t//更新探测器属性，带写入EEPROM功能\n\t\t\tSetDtcAbt(tStuDtc.ID-1,&amp;tStuDtc);\t\t\n\t\t\teditComplete = 1;\n\t\t\thal_Oled_Clear();\n\t\t\thal_Oled_ShowString(16,20,\"UPDATE..\",24,1);\n\t\t\thal_Oled_Refresh();\t \n\t\t&#125;else if(keys == KEY5_LONG_PRESS)\n\t\t&#123;\n\t\t\tpModeMenu = &amp;generalModeMenu[GNL_MENU_DESKTOP];\n\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RESET;\n\t\t&#125;\n\t&#125;\n\tif(editComplete)\n\t&#123;\n\t\ttimer++;\n\t\tif(timer > 150)\t\t//1.5秒自动退出\n\t\t&#123;\n\t\t\ttimer = 0;\n\t\t\teditComplete = 0;\n\t\t\tpModeMenu = &amp;DL_ZX_Review[STG_MENU_DL_ZX_REVIEW_MAIN];\n\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RECOVER;\n\t\t&#125;\n\t&#125;\n&#125;\n\n探测器删除\n\n\n\n\n\n\n\n\n\n//探测器删除\nstatic void stgMenu_dl_DeleteCBS(void)\n&#123;\n\tunsigned char keys = 0xFF;\n\tstatic Stu_DTC tStuDtc;\n\tstatic unsigned short timer = 0;\n\tstatic unsigned char DelComplete = 0;\n\tstatic unsigned char stgMainMenuSelectedPos=0;\n\tif(pModeMenu->refreshScreenCmd == SCREEN_CMD_RESET)\n\t&#123;\t//执行页面切换时屏幕刷新显示 \n\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_NULL;\n\t\tstgMainMenuSelectedPos = 0; \n\t\tif(CheckPresenceofDtc(pModeMenu->reserved))\n\t\t&#123;\n\t\t\tGetDtcStu(&amp;tStuDtc,pModeMenu->reserved);\n\t\t&#125;\n\t\tstgMainMenuSelectedPos = 0;\n\t\thal_Oled_Clear();\n\t\thal_Oled_ShowString(46,0,pModeMenu->pModeType,12,1);\n\t\t//del zone-001\n\t\thal_Oled_ShowString(28,14,\"Del \",12,1); \n\t\thal_Oled_ShowString(52,14,tStuDtc.Name,12,1); \n\t\thal_Oled_ShowString(25,28,\"Are you sure?\",12,1); \n\t\t//yes   no\n\t\thal_Oled_ShowString(40,48,\"Yes\",12,1); \n\t\thal_Oled_ShowString(88,48,\"No\",12,0); \n\t\thal_Oled_Refresh();\n\t\tDelComplete = 0;\n\t\ttimer = 0;\n\t&#125;\n\tif(pModeMenu->keyVal != 0xff)\n\t&#123;\n\t\tkeys = pModeMenu->keyVal;\n\t\tpModeMenu->keyVal = 0xFF;\t//恢复菜单按键值\n\t\tif((keys == KEY3_CLICK_RELEASE) || (keys == KEY4_CLICK_RELEASE))\n\t\t&#123;\n\t\t\tif(stgMainMenuSelectedPos == 0)\t\t\n\t\t\t&#123;\n\t\t\t\tstgMainMenuSelectedPos = 1;\n\t\t\t\thal_Oled_ClearArea(40,48,88,16);\t\t//清屏\n\t\t\t\thal_Oled_ShowString(40,48,\"Yes\",12,0); \n\t\t\t\thal_Oled_ShowString(88,48,\"No\",12,1); \n\t\t\t\thal_Oled_Refresh();\n\t\t\t&#125;else if(stgMainMenuSelectedPos == 1)\n\t\t\t&#123;\n\t\t\t\tstgMainMenuSelectedPos = 0;\n\t\t\t\thal_Oled_ClearArea(40,48,88,16);\t\t//清屏\n\t\t\t\thal_Oled_ShowString(40,48,\"Yes\",12,1); \n\t\t\t\thal_Oled_ShowString(88,48,\"No\",12,0); \n\t\t\t\thal_Oled_Refresh();\n\t\t\t&#125;\n\t\t&#125;else if(keys == KEY6_CLICK_RELEASE)\n\t\t&#123;\n\t\t\tif(stgMainMenuSelectedPos)\n\t\t\t&#123;\n\t\t\t\t//确认删除\n\t\t\t\tDelComplete = 1;\n\t\t\t\ttimer = 0;\n\t\t\t\ttStuDtc.Mark = 0;\n\t\t\t\tSetDtcAbt(tStuDtc.ID-1,&amp;tStuDtc);\t\t//更新探测器属性，带写入EEPROM功能\n\t\t\t\t\n\t\t\t\thal_Oled_Clear();\n\t\t\t\thal_Oled_ShowString(16,20,\"Update..\",24,1);\n\t\t\t\thal_Oled_Refresh();\t\n\t\t\t&#125;else\n\t\t\t&#123;\n\t\t\t\tpModeMenu = pModeMenu->pParent;\n\t\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RECOVER; \n\t\t\t&#125;\n\t\t&#125;else if(keys == KEY5_CLICK_RELEASE)\n\t\t&#123;\n\t\t\tpModeMenu = &amp;DL_ZX_Review[STG_MENU_DL_ZX_REVIEW_MAIN];\n\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RECOVER;\n\t\t&#125;else if(keys == KEY5_LONG_PRESS)\n\t\t&#123;\n\t\t\tpModeMenu = &amp;generalModeMenu[GNL_MENU_DESKTOP];;\n\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RESET;\n\t\t&#125;\n\t&#125;\n\tif(DelComplete)\n\t&#123;\n\t\ttimer++;\n\t\tif(timer > 150)\t\t//1.5秒自动退出\n\t\t&#123;\n\t\t\ttimer = 0;\n\t\t\tDelComplete = 0;\n\t\t\tpModeMenu = &amp;settingModeMenu[STG_MENU_DTC_LIST];\n\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RESET;\n\t\t&#125;\n\t&#125;\n&#125;\n\n\nSTM32驱动OLED实现Wifi配网子菜单wifi配网菜单处理函数\n\n\n\n\n\n\n\n\n\n//wifi配网菜单处理函数\nstatic void stgMenu_WifiCBS(void)\n&#123;\n\tstatic uint8_t stgMainMenuSelectedPos = 0;\n\tstatic uint16_t timer = 0;\n\tuint8_t keys;\n\tif(pModeMenu->refreshScreenCmd == SCREEN_CMD_RESET)\n\t&#123;\n\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_NULL;\t\n\t\thal_Oled_Clear();\t \n\t\thal_Oled_ShowString(52,0,\"Wifi\",12,1);\t\t \n\t\thal_Oled_ShowString(0,20,\"Are you sure to\",8,1); \n\t\thal_Oled_ShowString(0,30,\"enter ap mode?\",8,1);\t\t\n\t\t//yes   no\n\t\thal_Oled_ShowString(40,48,\"Yes\",12,1); \n\t\thal_Oled_ShowString(88,48,\"No\",12,0); \t\t\n\t\thal_Oled_Refresh();\t\t\n\t\tkeys = 0xFF;\n\t\ttimer = 0;\n\t\tstgMainMenuSelectedPos = 0;\n\t&#125;\t\n\tif(pModeMenu->keyVal != 0xff)\n\t&#123;\n\t\tkeys = pModeMenu->keyVal;\n\t\tpModeMenu->keyVal = 0xFF;\t//恢复菜单按键值\t\t\n\t\tif((keys == KEY3_CLICK_RELEASE) || (keys == KEY4_CLICK_RELEASE))\n\t\t&#123;\n\t\t\tif(stgMainMenuSelectedPos == 0)\t\t\n\t\t\t&#123;\n\t\t\t\tstgMainMenuSelectedPos = 1;\n\t\t\t\thal_Oled_ClearArea(40,48,88,16);\t\t//清屏\n\t\t\t\thal_Oled_ShowString(40,48,\"Yes\",12,0); \n\t\t\t\thal_Oled_ShowString(88,48,\"No\",12,1); \n\t\t\t\thal_Oled_Refresh();\n\t\t\t&#125;else if(stgMainMenuSelectedPos == 1)\n\t\t\t&#123;\n\t\t\t\tstgMainMenuSelectedPos = 0;\n\t\t\t\thal_Oled_ClearArea(40,48,88,16);\t\t//清屏\n\t\t\t\thal_Oled_ShowString(40,48,\"Yes\",12,1); \n\t\t\t\thal_Oled_ShowString(88,48,\"No\",12,0); \n\t\t\t\thal_Oled_Refresh(); \n\t\t\t&#125;\n\t\t&#125;else if(keys == KEY5_CLICK_RELEASE)\n\t\t&#123;\n\t\t\tpModeMenu = pModeMenu->pParent;\n\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RECOVER;\n\t\t&#125;else if(keys == KEY5_LONG_PRESS)\n\t\t&#123;\n\t\t\tpModeMenu = &amp;generalModeMenu[GNL_MENU_DESKTOP];;\n\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RESET;\n\t\t&#125;\t\t \n\t&#125;\n&#125;\n\nSTM32驱动OLED实现设备信息子菜单功能设备信息菜单处理函数\n\n\n\n\n\n\n\n\n设备信息子菜单的作用\n看程序版本号\n 看硬件版本号\n方便后期对产品的维护，比如说产品出问题了，我们可以通过硬件和程序版本号来定位批次。 \n还有就是有些产品是可以在线升级的，升级以后通过程序版本号来看有没有升级成功\n\n//设备信息菜单处理函数\nstatic void stgMenu_MachineInfoCBS(void)\n&#123;\n\tuint8_t keys; \n\tif(pModeMenu->refreshScreenCmd == SCREEN_CMD_RESET)\n\t&#123;\n\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_NULL;\n\t\n\t\thal_Oled_Clear();\t //mac info\n\t\thal_Oled_ShowString(40,0,\"Mac info\",12,1);\t\n\t\thal_Oled_ShowString(0,16,\"&lt;mcu ver>: \",12,1);\n\t\thal_Oled_ShowString(66,16,pMcuVersions,12,1);\t\t\n\t\thal_Oled_ShowString(0,32,\"&lt;hard ver>: \",12,1);\n\t\thal_Oled_ShowString(72,32,pHardVersions,12,1);\n\t\thal_Oled_Refresh();\t\t\n\t\tkeys = 0xFF;\t\t \n\t&#125;\t\n\tif(pModeMenu->keyVal != 0xff)\n\t&#123;\n\t\tkeys = pModeMenu->keyVal;\n\t\tpModeMenu->keyVal = 0xFF;\t//恢复菜单按键值\n\t\tif(keys == KEY5_CLICK_RELEASE)\n\t\t&#123;\n\t\t\tpModeMenu = pModeMenu->pParent;\n\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RECOVER;\n\t\t&#125;else if(keys == KEY5_LONG_PRESS)\n\t\t&#123;\n\t\t\tpModeMenu = &amp;generalModeMenu[GNL_MENU_DESKTOP];\n\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RESET;\n\t\t&#125;\n\t&#125;\n&#125;\n\nSTM32驱动OLED实现恢复出厂设置子菜单功能恢复出厂设置菜单处理函数\n\n\n\n\n\n\n\n\n\n//恢复出厂设置菜单处理函数\nstatic void stgMenu_FactorySettingsCBS(void)\n&#123;\n\tuint8_t keys = 0xFF;\n\tstatic uint16_t timer = 0;\n\tstatic uint8_t Complete = 0;\t\n\tstatic uint8_t stgMainMenuSelectedPos=0;\n\tif(pModeMenu->refreshScreenCmd == SCREEN_CMD_RESET)\n\t&#123;\t//执行页面切换时屏幕刷新显示 \n\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_NULL;\n\t\tstgMainMenuSelectedPos = 0; \t\n\t\thal_Oled_Clear();\n\t\thal_Oled_ShowString(19,0,\"Default setting\",12,1);\t\t\n\t\thal_Oled_ShowString(25,28,\"Are you sure?\",12,1); \n\t\t//yes   no\n\t\thal_Oled_ShowString(40,48,\"Yes\",12,1); \n\t\thal_Oled_ShowString(88,48,\"No\",12,0); \t\t\n\t\thal_Oled_Refresh();\t\t \n\t\tComplete = 0;\n\t\ttimer = 0;\n\t&#125;\t\n\tif(pModeMenu->keyVal != 0xff)\n\t&#123;\n\t\tkeys = pModeMenu->keyVal;\n\t\tpModeMenu->keyVal = 0xFF;\t//恢复菜单按键值\n\t\tif(!Complete)\n\t\t&#123;\n\t\t\tif((keys == KEY3_CLICK_RELEASE) || (keys == KEY4_CLICK_RELEASE))\n\t\t\t&#123;\n\t\t\t\tif(stgMainMenuSelectedPos == 0)\t\t\n\t\t\t\t&#123;\n\t\t\t\t\tstgMainMenuSelectedPos = 1;\n\t\t\t\t\thal_Oled_ClearArea(40,48,88,16);\t\t//清屏\n\t\t\t\t\thal_Oled_ShowString(40,48,\"Yes\",12,0); \n\t\t\t\t\thal_Oled_ShowString(88,48,\"No\",12,1); \n\t\t\t\t\thal_Oled_Refresh();\n\t\t\t\t&#125;else if(stgMainMenuSelectedPos == 1)\n\t\t\t\t&#123;\n\t\t\t\t\tstgMainMenuSelectedPos = 0;\n\t\t\t\t\thal_Oled_ClearArea(40,48,88,16);\t\t//清屏\n\t\t\t\t\thal_Oled_ShowString(40,48,\"Yes\",12,1); \n\t\t\t\t\thal_Oled_ShowString(88,48,\"No\",12,0); \n\t\t\t\t\thal_Oled_Refresh();\n\t \n\t\t\t\t&#125;\n\t\t\t&#125;else if(keys == KEY6_CLICK_RELEASE)\n\t\t\t&#123;\n\t\t\t\tif(stgMainMenuSelectedPos)\n\t\t\t\t&#123;\n\t\t\t\t\t//确认 \n\t\t\t\t\tComplete = 1;\n\t\t\t\t\ttimer = 0;\n\t\t\t\t\tFactoryReset();\t\t//调用复位EEPROM数据函数\n\t\t\t\t\thal_Oled_Clear();\n\t\t\t\t\thal_Oled_ShowString(16,20,\"Update..\",24,1);\n\t\t\t\t\thal_Oled_Refresh();\t\n\t\t\t\t&#125;else\n\t\t\t\t&#123;\n\t\t\t\t\tpModeMenu = pModeMenu->pParent;\n\t\t\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RECOVER; \n\t\t\t\t&#125;\n\t\t\t&#125;else if(keys == KEY5_CLICK_RELEASE)\n\t\t\t&#123;\n\t\t\t\tpModeMenu = pModeMenu->pParent;\n\t\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RECOVER; \n\t\t\t&#125;else if(keys == KEY5_LONG_PRESS)\n\t\t\t&#123;\n\t\t\t\tpModeMenu = &amp;generalModeMenu[GNL_MENU_DESKTOP];;\n\t\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RESET;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\tif(Complete)\n\t&#123;\n\t\ttimer++;\n\t\tif(timer > 150)\t\t//1.5秒自动退出\n\t\t&#123;\n\t\t\ttimer = 0;\n\t\t\tComplete = 0;\n\t\t\tpModeMenu = pModeMenu->pParent;\n\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RECOVER;\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n\n\n\n\n\n二级标题三级标题四级标题五级标题六级标题","slug":"wifi主机/wifi主机第十部分  UI设计师","date":"2020-08-15T10:49:36.000Z","categories_index":"单片机","tags_index":"STM32,主机","author_index":"虫子"},{"id":"6cb2617339080555db592d1de52b021d","title":"WIFI主机-精确打击","content":"WIFI主机按键检测\n\n\n\n\n\n\n\n\n到了这里了我们用的肯定是高级的按键写法，那些低端的代码我们可以抛弃了\n但是一些原理还是要讲讲的，大多数按键都是物理开关，当机械开关触点闭合、断开的时候不会马上就会接通或者断开，而是断断续续高平的闭合、断开，最后才稳定下来。\n\n上图是一个按键按下的波形图，假设按键按下是连接着GND，那按下就是低电平。按下瞬间会有T1个周期时间是电平不稳定的状态，松开的时候会有T2个周期时间是电平不稳定状态。这个不稳定的状态就叫抖动。\n那我们消抖其实就是通过软件延时，把T1和T2这个时间过滤掉，一般是各延时10ms就行了。当然也有硬件消抖，通过电容来进行交通直隔来消抖，但是加大了硬件成本不可取。\n\n首先这种垃圾代码就不要写了，没有意思，但是很多高校比较喜欢这种写法，且是那种屡试不爽的那种，我们是要面向产品的，所以我们用工程级别的写法\n多按键多功能检测代码实战\n\n\n\n\n\n\n\n\n\n编写按键对应的gpio初始化程序。\n编写读取每个按键IO口状态程序。\n编写多按键检测功能代码。\n解决程序可移植性\n\n根据模块化编程的思维，按键检测属于硬件层的一个驱动，属于一种信号输入到单片机，我们硬件层驱动程序处理好信号，确定是一个有效按键按下信号后，把这个按键的值(短按、短按释放、长按、长按释放)传递给应用层，就是我们的产品功能程序。\n传递的方式有很多种，比如说最简单粗暴的就是用全局变量，分别在不同的.c文件判断，这种可移植性极差。\n那这里其实就可以用我们的回调函数了,xdm回调函数屡试不爽，大家也看到了我非常喜欢回调函数\nKEY_GPIO_Config  按键GPIO配置\n\n\n\n\n\n\n\n\n由于按键1-6基本一样，一样的部分就不放图了\n\nstatic void KEY_GPIO_Config(void)\n&#123;\n\tGPIO_InitTypeDef  GPIO_InitStruct;\n\t//先开时钟,按键都在GPIOB口上，复用口时钟也开起来\n\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB|RCC_APB2Periph_AFIO, ENABLE);\n\t//再更改指定管脚的映射\n\tGPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable,ENABLE);\n\t\n\t//键1\n\tGPIO_InitStruct.GPIO_Pin = KEY1_GPIO_PIN;\n    //模式配置成上拉\n\tGPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;\n\t//然后初始化，把结构体里面的成员加载到寄存器里面\n\tGPIO_Init(KEY1_GPIO_PORT, &amp;GPIO_InitStruct);\t\n\t\n\t//键2\n\tGPIO_InitStruct.GPIO_Pin = KEY2_GPIO_PIN;\n    //模式配置成上拉\n\tGPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;\n\t//然后初始化，把结构体里面的成员加载到寄存器里面\n\tGPIO_Init(KEY2_GPIO_PORT, &amp;GPIO_InitStruct);\t\n\t\n\t//键3\n\tGPIO_InitStruct.GPIO_Pin = KEY3_GPIO_PIN;\n    //模式配置成上拉\n\tGPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;\n\t//然后初始化，把结构体里面的成员加载到寄存器里面\n\tGPIO_Init(KEY3_GPIO_PORT, &amp;GPIO_InitStruct);\t\n\t\n\t//键4\n\tGPIO_InitStruct.GPIO_Pin = KEY4_GPIO_PIN;\n    //模式配置成上拉\n\tGPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;\n\t//然后初始化，把结构体里面的成员加载到寄存器里面\n\tGPIO_Init(KEY4_GPIO_PORT, &amp;GPIO_InitStruct);\t\n\t\n\t//键5\n\tGPIO_InitStruct.GPIO_Pin = KEY5_GPIO_PIN;\n    //模式配置成上拉\n\tGPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;\n\t//然后初始化，把结构体里面的成员加载到寄存器里面\n\tGPIO_Init(KEY5_GPIO_PORT, &amp;GPIO_InitStruct);\t\n\t\n\t//键6\n\tGPIO_InitStruct.GPIO_Pin = KEY6_GPIO_PIN;\n    //模式配置成上拉\n\tGPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;\n\t//然后初始化，把结构体里面的成员加载到寄存器里面\n\tGPIO_Init(KEY6_GPIO_PORT, &amp;GPIO_InitStruct);\t\n&#125;\n\n读取每个按键IO口状态\n\n\n\n\n\n\n\n\n\n//得到键1状态\nstatic uint8_t hal_getKey1Sta()\n&#123;\n\t//实际上按键按下是接地的也就是得到的是0，但是为了符合习惯我们取反表示按下为1\n\treturn (!GPIO_ReadInputDataBit(KEY1_GPIO_PORT,KEY1_GPIO_PIN));\n&#125;\n//得到键2状态\nstatic uint8_t hal_getKey2Sta()\n&#123;\n\t//实际上按键按下是接地的也就是得到的是0，但是为了符合习惯我们取反表示按下为1\n\treturn (!GPIO_ReadInputDataBit(KEY2_GPIO_PORT,KEY2_GPIO_PIN));\n&#125;\n//得到键3状态\nstatic uint8_t hal_getKey3Sta()\n&#123;\n\t//实际上按键按下是接地的也就是得到的是0，但是为了符合习惯我们取反表示按下为1\n\treturn (!GPIO_ReadInputDataBit(KEY3_GPIO_PORT,KEY3_GPIO_PIN));\n&#125;\n//得到键4状态\nstatic uint8_t hal_getKey4Sta()\n&#123;\n\t//实际上按键按下是接地的也就是得到的是0，但是为了符合习惯我们取反表示按下为1\n\treturn (!GPIO_ReadInputDataBit(KEY4_GPIO_PORT,KEY4_GPIO_PIN));\n&#125;\n//得到键5状态\nstatic uint8_t hal_getKey5Sta()\n&#123;\n\t//实际上按键按下是接地的也就是得到的是0，但是为了符合习惯我们取反表示按下为1\n\treturn (!GPIO_ReadInputDataBit(KEY5_GPIO_PORT,KEY5_GPIO_PIN));\n&#125;\n//得到键6状态\nstatic uint8_t hal_getKey6Sta()\n&#123;\n\t//实际上按键按下是接地的也就是得到的是0，但是为了符合习惯我们取反表示按下为1\n\treturn (!GPIO_ReadInputDataBit(KEY6_GPIO_PORT,KEY6_GPIO_PIN));\n&#125;\n\n按键任务函数\n\n\n\n\n\n\n\n\n\n//按键任务函数\nvoid hal_KeyProc(void)\n&#123;\n\tunsigned char i,KeyState[KEY_SUM];\n\tfor(i=0; i&lt;KEY_SUM; i++)\n\t&#123;\t\n\t\tkeys = 0; \n \n\t\tKeyState[i] = getKeysState[i]();\n\t\tswitch(KeyStep[i])\n\t\t&#123;\n\t\t\tcase KEY_STEP_WAIT:\t\t//等待按键\n\t\t\t\tif(KeyState[i])\n\t\t\t\t&#123;\n\t\t\t\t\tKeyStep[i] = KEY_STEP_CLICK;\t\n\t\t\t\t&#125;\n\t\t\tbreak;\n\t\t\tcase KEY_STEP_CLICK:\t\t\t\t//按键单击按下\n\t\t\t\tif(KeyState[i])\n\t\t\t\t&#123;\n\t\t\t\t\tif(!(--KeyScanTime[i]))\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tKeyScanTime[i] = KEY_SCANTIME;\n\t\t\t\t\t\tKeyStep[i] = KEY_STEP_LONG_PRESS;\n\t\t\t\t\t\t//keys = i+1;\t\t\t\t\t\t\t\t\t\t//记录按键ID号\n\t\t\t\t\t\t//state = KEY_CLICK;\t\t\t\t\t\t\t\t//按键单击按下\n\t\t\t\t\t\tkeys = (i*5)+1;\t\t\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;else\n\t\t\t\t&#123;\n\t\t\t\t\tKeyScanTime[i] = KEY_SCANTIME;\n\t\t\t\t\tKeyStep[i] = KEY_STEP_WAIT;\n\t\t\t\t&#125;\n\t\t\tbreak;\n\t\t\tcase KEY_STEP_LONG_PRESS:\t\t\t//按键长按\n\t\t\t\tif(KeyState[i])\n\t\t\t\t&#123;\t\n\t\t\t\t\tif(!(--KeyPressLongTimer[i]))\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tKeyPressLongTimer[i] = KEY_PRESS_LONG_TIME;\n\t\t\t\t\t\tKeyStep[i] = KEY_STEP_CONTINUOUS_PRESS;\n\t\t\t\t\t\tkeys = (i*5)+3;\t\t\t\t\t\t\t\t//长按确认\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;else\n\t\t\t\t&#123;\n\t\t\t\t\tKeyPressLongTimer[i] = KEY_PRESS_LONG_TIME;\n\t\t\t\t\tKeyStep[i] = KEY_STEP_WAIT;\n\t\t\t\t\tkeys = (i*5)+2;\t\t\t\t\t\t\t\t\t\t//单击释放\n\t\t\t\t&#125;\n\t\t\tbreak;\n\t\t\tcase KEY_STEP_CONTINUOUS_PRESS:\n\t\t\t\tif(KeyState[i])\n\t\t\t\t&#123;\n\t\t\t\t\tif(!(--KeyContPressTimer[i]))\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tKeyContPressTimer[i] = KEY_PRESS_CONTINUE_TIME;\n\t\t\t\t\t\tkeys = (i*5)+4;\t\t\t\t\t//持续长按\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;else\n\t\t\t\t&#123;\n\t\t\t\t\tKeyStep[i] = KEY_STEP_WAIT;\n\t\t\t\t\tKeyContPressTimer[i] = KEY_PRESS_CONTINUE_TIME;\n\t\t\t\t\tkeys = (i*5)+5;\t\t\t\t\t\t\t\t//长按释放\n\t\t\t\t&#125;\n\t\t\tbreak;\n\t\t&#125;\n\t\tif(keys)\n\t\t&#123;\n\t\t\tif(KeyScanCBS)\n\t\t\t&#123;\t \n\t\t\t\tKeyScanCBS((KEY_VALUE_TYPEDEF)keys);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\n按键扫描回调注册函数\n\n\n\n\n\n\n\n\n\n/********************************************************************************************************\n*  @函数名   hal_KeyScanCBSRegister\t\t\t\t\t                                                           \n*  @描述     按键扫描回调注册函数\t\t\t\t\t\t\t\t                                     \n*  @参数     pCBS-应用层的函数指针，让我们的按键扫描函数指针指向应用层，就可以执行应用层代码实现应用层和硬件层的分离\n*  @返回值   无   \n*  @注意        无\n********************************************************************************************************/\nvoid hal_KeyScanCBSRegister(KeyEvent_CallBack_t pCBS)\n&#123;\n\tif(KeyScanCBS == 0)\n\t&#123;\n\t\t\tKeyScanCBS = pCBS;\n\t&#125;\n&#125;\n\n按键初始化函数\n\n\n\n\n\n\n\n\n\nvoid hal_KeyInit(void)\n&#123;\n\tunsigned char i;\n\tKeyScanCBS = 0;\n\thal_keyConfig();\n \n\tfor(i=0; i&lt;KEYNUM; i++)\n\t&#123;\n\t\tKeyStep[i] = KEY_STEP_WAIT;\n\t\tKeyScanTime[i] = KEY_SCANTIME;\n\t\tKeyPressLongTimer[i] = KEY_PRESS_LONG_TIME;\n\t\tKeyContPressTimer[i] = KEY_PRESS_CONTINUE_TIME;\n\t&#125;\n&#125;\n\nApp应用层代码\n\n\n\n\n\n\n\n\n\nvoid AppInit(void)\n&#123;\n\thal_KeyScanCBSRegister(KeyEventHandle);\n&#125;\n//按键回调函数\nstatic void KeyEventHandle(KEY_VALUE_TYPEDEF keys)\n&#123;\n\t\n\t \n\tif((keys==KEY1_CLICK)\n\t|| (keys==KEY2_CLICK)\n\t|| (keys==KEY3_CLICK)\n\t|| (keys==KEY4_CLICK)\n\t|| (keys==KEY5_CLICK)\n\t|| (keys==KEY6_CLICK))\n\t&#123;\n\t\tLedMsgInput(LED1,LED_LIGHT,1);\n\t&#125;else if((keys==KEY1_CLICK_RELEASE)\n\t|| (keys==KEY2_CLICK_RELEASE)\n\t|| (keys==KEY3_CLICK_RELEASE)\n\t|| (keys==KEY4_CLICK_RELEASE)\n\t|| (keys==KEY5_CLICK_RELEASE)\n\t|| (keys==KEY6_CLICK_RELEASE))\n\t&#123;\n\t\tLedMsgInput(LED1,LED_BLINK4,1);\n\t&#125;else if((keys==KEY1_LONG_PRESS)\n\t|| (keys==KEY2_LONG_PRESS)\n\t|| (keys==KEY3_LONG_PRESS)\n\t|| (keys==KEY4_LONG_PRESS)\n\t|| (keys==KEY5_LONG_PRESS)\n\t|| (keys==KEY6_LONG_PRESS))\n\t&#123;\n\t\tLedMsgInput(LED1,LED_DARK,1);\n\t&#125;\n&#125;\n\n思路\n\n\n\n\n\n\n\n\n\nSPI驱动OLEDOLED模块简介\n\n\n\n\n\n\n\n\nOLED，即有机发光二极管（Organic Light-Emitting Diode），又称为有机电激光显示（OrganicElectroluminesence Display， OELD）。 OLED 由于同时具备自发光，不需背光源、对比度高、厚度薄、视角广、反应速度快、可用于挠曲性面板、使用温度范围广、构造及制程较简单等优异之特性，被认为是下一代的平面显示器新兴应用技术。\n模块特点\n\n没有背光，需要通过写入指令来开启显示\n尺寸小：0.96寸，分辨率高：128*64\n提供多种通信接口：6800、8080、3线&#x2F;4线SPI、IIC\n供电3.3V\n驱动芯片：SSD1306\n\n\n引脚定义：我们使用的OLED模组是3线SPI通讯方式\n\n\n\n\n\n\n\n\n\nSSD1306驱动显示原理\n\n\n\n\n\n\n\n\n在OLED上显示图像，图像的数据就存储在显存GRAM中，SSD1306的分辨率是128*64像素点，简单理解就是128*64个LED灯，有128行(x轴)，64(y轴)列组成的LED矩阵。\n\n如图，OLED12864 由&#x3D;&#x3D;128 列 *64行&#x3D;&#x3D;组成。&#x3D;&#x3D;D0D7 这8行是一个字节的 PAGE 单元&#x3D;&#x3D; ，也就是把 COM0COM 64行划分成 8 个页单元PAGE0PAGE7 。&#x3D;&#x3D;写入的数据不能按位操作&#x3D;&#x3D;，只能&#x3D;&#x3D;D0D7 这8个点一个字节写入&#x3D;&#x3D;，每个 PAGE  是128个SEG 列\n我们把16个 SEG 作为一个 SEG16单元格 。整个面板就是&#x3D;&#x3D;8个PAGE和8个SEG16&#x3D;&#x3D;划分出来的&#x3D;&#x3D;64个单元格&#x3D;&#x3D;。上下两个单元格就是16*16  点，能够显示一个汉字 、两个大号英文、四个小号英文\n\n我们框架式编程方式，不是直接发送图像 。先把图像暂时保存在单片机的外部RAM 空间，单片机空闲的时候， 再把 外部 RAM  里面的图像 ，通过 IIC  协议 发送到 SSD1306  芯片的 GDDRAM  里面。SSD1306芯片自动完成循环扫描，把GDDRAM  里面的 图像投影到玻璃面板 LED 阵列。通过修改 SSD1306  循环扫描的顺序，就可以&#x3D;&#x3D;左右镜面 、上下镜面 、 隔行扫描、 逐行扫描、逐列扫描、反白显示 等多种方式灵活使用。&#x3D;&#x3D; 我们开发板就是需要 OLED  显示位置旋转  180 °\nOLED图像显示位置的寻址寄存器\n\n\n\n\n\n\n\n\n\nOLED的硬件配置寄存器\n\n\n\n\n\n\n\n\n\n上面是之前的文章上面的\n\n\n\n\n\n\n\n\n\n每个LED对应显存GRAM中的一位，那用二维数组来表示这个显存就是&#x3D;&#x3D;GRAM[128][8]&#x3D;&#x3D;；\n为什么是GRAM[128][8]而不是GRAM[128][64]？\n因为行(即x轴)公共端(分阴极和阳极，跟数码管类似)，而列(即y轴)是数据端，LED灯只需要0或者1就可以代表亮和灭，所以为了节约内存，直接用一个Bit来表示灯的状态即可，所以用8个字节就能表示列的64个Bit。\n&#x3D;&#x3D;那怎么显示一个图片或者字符呢？&#x3D;&#x3D;\n原理就是同时控制不同的灯点亮形成一个图案或者字符。\n这个就需要用到取模软件，把整个字符或者图片导入进去，然后帮你生成对应的数组形式的数据，这样就能很方便地在OLED上显示你要的东西了。\n软件和取模教程OLED厂家都有提供。\nOLED的扫描方式：\n我们前面说把0x04写入到GRAM[0][0]位置的显存里就能点亮坐标x&#x3D;0，y&#x3D;3那个灯。\n那这个0x04数据是怎么来的呢？这个跟取模走向有关，我们取模走向是逆向，就是低位在前，高位在后，从左到右，从上到下的方式(用软件演示)\n\nSPI通讯原理及模式选择\n\n\n\n\n\n\n\n\n起源\nSPI是由摩托罗拉公司提出的通讯协议，用于两个设备之间的&#x3D;&#x3D;高速全双工&#x3D;&#x3D;数据传输。它被广泛地使用在ADC、LCD等设备与MCU间，要求通讯速率较高的场合。&#x3D;&#x3D;全双工&#x3D;&#x3D;的意思就是在&#x3D;&#x3D;同时可以进行数据写和数据读&#x3D;&#x3D;的操作，因为读和写是单独的两根线嘛。\n通讯引脚\n&#x3D;&#x3D;MOSI&#x3D;&#x3D;：Master Output Slave Input，顾名思义，即主设备输出&#x2F;从设备输入。数据从主机输出到从机，主机是主设备输出\n&#x3D;&#x3D;MISO&#x3D;&#x3D;：Master Iutput Slave Onput，主设备输入&#x2F;从设备输出，数据由从机输出到主机，主机接收数据。\n&#x3D;&#x3D;SCK&#x3D;&#x3D;：即时钟信号线，用于通讯同步。该信号由主机产生，其支持的最高通讯速率为fpclk&#x2F;2，即所挂载总线速率的一半。如SPI2挂载在APB1总线上，则其最高速率为36MHz &#x2F; 2 &#x3D; 18MHz。两个设备之间通讯时，通讯速率受限于较低速的设备。\n&#x3D;&#x3D;NSS&#x3D;&#x3D;：即片选信号线，用于选择通讯的从设备，也可用CS表示。每个从设备都有一条独立的NSS信号线，主机通过将某个设备的NSS线置低电平来选择与之通讯的从设备。所以SPI通讯以NSS线电平置&#x3D;&#x3D;低为起始信号&#x3D;&#x3D;，以NSS线电平被&#x3D;&#x3D;拉高为停止信号&#x3D;&#x3D;\nSPI物理层的特点\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n每个从设备都有独立的这一条SS信号线，本信号线独占主机的一个引脚，即有多少个从设备，就有多少条片选信号线。I2C协议中通过设备地址来寻址、选中总线上的某个设备并与其进行通讯；而SPI协议中没有设备地址，它使用SS信号线来寻址，当主机要选择从设备时，把该从设备的SS信号线设置为低电平，该从设备即被选中，即片选有效，接着主机开始与被选中的从设备进行SPI通讯。所以SPI通讯以SS线置低电平为开始信号，以SS线被拉高作为结束信号。\nstm32的spi有好几种\n\nSPI的协议层\n\n\n\n\n\n\n\n\nSPI协议定义了通讯的起始和停止信号、数据有效性、时钟同步等环节。\nSPI基本通讯过程\n\n\n\n\n\n\n\n\n\n\n标号处，NSS信号线由高变低，是SPI通讯的起始信号。NSS是每个从机各自独占的信号线，当从机检在自己的NSS线检测到起始信号后，就知道自己被主机选中了，开始准备与主机通讯。\n在图中的标号处，NSS信号由低变高，是SPI通讯的停止信号，表示本次通讯结束，从机的选中状态被取消\nSPI使用MOSI及MISO信号线来传输数据，使用SCK信号线进行数据同步。MOSI及MISO数据线在SCK的每个时钟周期传输一位数据，且数据输入输出是同时进行的\n\nCPOL&#x2F;CPHA 及通讯模式\n\n\n\n\n\n\n\n\n\n\n时钟极性CPOL是指SPI通讯设备处于空闲状态时，SCK信号线的电平信号(即SPI通讯开始前、 NSS线为高电平时SCK的状态)。CPOL&#x3D;0时， SCK在空闲状态时为低电平，CPOL&#x3D;1时，则相反\n时钟相位CPHA是指数据的采样的时刻，当CPHA=0时，MOSI或MISO数据线上的信号将会在SCK时钟线的“奇数边沿”被采样。当CPHA=1时，数据线在SCK的“偶数边沿”采样。\n\nCPOL&#x2F;CPHAA 及通讯模式\n\n\n\n\n\n\n\n\n由CPOL及CPHA的不同状态，SPI分成了四种模式，主机与从机需要工作在相同的模式下才可以正常通讯，实际中采用较多的是&#x3D;&#x3D;“模式0”与“模式3”&#x3D;&#x3D;\n\n\nSTM32的SPI特性及架构STM32的SPI外设简介\n\n\n\n\n\n\n\n\nSTM32的SPI外设可用作通讯的主机及从机，支持最高的SCK时钟频率为f pclk &#x2F;2 (STM32F10x型号的芯片默认f pclk1 为72MHz，f pclk2 为36MHz)，完全支持SPI协议的4种模式，数据帧长度可设置为8位或16位，可设置数据MSB先行或LSB先行。它还支持双线全双工(前面小节说明的都是这种模式)、双线单向以及单线模式。\nSTM32的SPI架构剖析\n\n\n\n\n\n\n\n\n\n一般情况下我们是不会选择硬件spi的，我们会用软件模拟spi信号\n时钟控制逻辑\n\n\n\n\n\n\n\n\nSCK线的时钟信号，由波特率发生器根据“控制寄存器CR1”中的BR[0:2]位控制，该位是对f pclk 时钟的分频因子，对f pclk 的分频结果就是SCK引脚的输出时钟频率\n\n数据控制逻辑\n\n\n\n\n\n\n\n\nSPI的MOSI及MISO都连接到数据移位寄存器上，数据移位寄存器的数据来源来源于接收缓冲区及发送缓冲区\n\n通过写SPI的“数据寄存器DR”把数据填充到发送缓冲区中。\n通过读“数据寄存器DR”，可以获取接收缓冲区中的内容。\n其中数据帧长度可以通过“控制寄存器CR1”的“DFF位”配置成8位及16位模式；配置“LSBFIRST位”可选择MSB先行还是LSB先行\n\n整体控制逻辑\n\n\n\n\n\n\n\n\n\n整体控制逻辑负责协调整个SPI外设，控制逻辑的工作模式根据“控制寄存器(CR1&#x2F;CR2)”的参数而改变，基本的控制参数包括前面提到的SPI模式、波特率、LSB先行、主从模式、单双向模式等等\n在外设工作时，控制逻辑会根据外设的工作状态修改“状态寄存器(SR)”，只要读取状态寄存器相关的寄存器位，就可以了解SPI的工作状态了。除此之外，控制逻辑还根据要求，负责控制产生SPI中断信号、DMA请求及控制NSS信号线。\n实际应用中，一般不使用STM32 SPI外设的标准NSS信号线，而是更简单地使用普通的GPIO，软件控制它的电平输出，从而产生通讯起始和停止信号。\n\n通讯过程\n\n\n\n\n\n\n\n\n\n\n控制NSS信号线，产生起始信号(图中没有画出)；\n把要发送的数据写入到“数据寄存器DR”中，该数据会被存储到发送缓冲区\n通讯开始，SCK时钟开始运行。MOSI把发送缓冲区中的数据一位一位地传输出去；MISO则把数据一位一位地存储进接收缓冲区中\n当发送完一帧数据的时候，“状态寄存器SR”中的“TXE标志位”会被置1，表示传输完一帧，发送缓冲区已空；类似地，当接收完一帧数据的时候，“RXNE标志位”会被置1，表示传输完一帧，接收缓冲区非空；\n等待到“TXE标志位”为1时，若还要继续发送数据，则再次往“数据寄存器DR”写入数据即可；等待到“RXNE标志位”为1时，通过读取“数据寄存器DR”可以获取接收缓冲区中的内容\n\n假如使能了TXE或RXNE中断，TXE或RXNE置1时会产生SPI中断信号，进入同一个中断服务函数，到SPI中断服务程序后，可通过检查寄存器位来了解是哪一个事件，再分别进行处理。也可以使用DMA方式来收发“数据寄存器DR”中的数据\nSPI初始化结构体详解\n\n\n\n\n\n\n\n\n跟其它外设一样，STM32标准库提供了SPI初始化结构体及初始化函数来配置SPI外设。初始化结构体及函数定义在库文件“stm32f10x_spi.h”及“stm32f10x_spi.c”中，编程时我们可以结合这两个文件内的注释使用或参考库帮助文档。\n\n配置完这些结构体成员后，要调用SPI_Init函数把这些参数写入到寄存器中，实现SPI的初始化，然后调用SPI_Cmd来使能SPI外设。\ntypedef struct\n&#123;\n  uint16_t SPI_Direction;              //设置spi的单双向模式 \n  uint16_t SPI_Mode;                   //设置spi的主/从机模式\n  uint16_t SPI_DataSize;               //设置spi的数据帧长度，可选8/16位\n  uint16_t SPI_CPOL;                   //设置时钟极性CPOL，可选高低电平\n  uint16_t SPI_CPHA;                   //设置时钟相位，可选奇/偶边沿采样\n  uint16_t SPI_NSS;                    //设置NSS引脚由spi是硬件控制还是软件控制\n  uint16_t SPI_BaudRatePrescaler;      //设置时钟分频因子，fpclk/分频数=fsck\n  uint16_t SPI_FirstBit;               // 设置MSB/LSB先行\n  uint16_t SPI_CRCPolynomial;          //设置CRC校验的表达式\n&#125;SPI_InitTypeDef;                      //spi初始化结构体\n\nOLED驱动移植\n\n\n\n\n\n\n\n\n这种屏驱动程序99.9%都不需要你写，大家后面如果有类似开发需要用到屏，直接找原厂要驱动源码就行了。自己写并不能学到很东西，同时浪费很多时间，简称走弯路。\n我们这个OLED模组原厂提供的是模拟SPI的驱动程序，只需要更改IO口就可以使用，然后我基于他们的程序把一些函数名改了下，前面增加了hal_增加程序可读性\n还增加了一个清屏指定区域的函数，核心的函数没去动他们的\n首先进行一波官方源码分析\n\n移植流程\n\n\n\n\n\n\n\n\n\n不需要自己重写OLED驱动函数，直接用我提供的（对原厂稍作优化）。\n熟悉STM32外设SPI的使用。\n学会看SPI通讯时序图，及4种模式。\n移植OLED驱动并成功显示任意字符\n\n以我们的风格改一下官方源码\n\n\n\n\n\n\n\n\n\n\n//oled配置\nstatic void hal_OledConfig(void)\n&#123;\n\t//创建两个结构体  spi和gpio的\n\tSPI_InitTypeDef  SPI_InitStructure;\n\tGPIO_InitTypeDef GPIO_InitStructure;\n\t\n\t//开三个时钟spi1，gpioa和复用口\n\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1\n\t                      |RCC_APB2Periph_GPIOA\n\t                      |RCC_APB2Periph_AFIO, ENABLE);\n\t//复用管脚重映射\n\tGPIO_PinRemapConfig(GPIO_Remap_SPI1, ENABLE);\n\t\n\t//配置spi1的结构体   sck时钟线，DO数据线就可以控制我们OLED了\n\tGPIO_InitStructure.GPIO_Pin =  OLED_SLK_PIN |OLED_DO_PIN;\n\tGPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n\t//复用推挽输出意味着是模拟spi\n\tGPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;\n\t//初始化把配置的成员加载进寄存器\n\tGPIO_Init(OLED_PORT, &amp;GPIO_InitStructure);\n\t\n\t//OLED复位引脚\n\tGPIO_InitStructure.GPIO_Pin = OLED_RES_PIN;\n\tGPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n\t//推挽输出，因为这边复位只需要把他拉低就行了，所以我们就用普通io功能，不需要AF\n\tGPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;\n\tGPIO_Init(OLED_PORT, &amp;GPIO_InitStructure);\n\t//先拉高\n\tGPIO_SetBits(OLED_PORT,OLED_RES_PIN);\n\t\n\t//OLED命令/数据控制引脚\n\tGPIO_InitStructure.GPIO_Pin = OLED_CMD_PIN;\n\tGPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n\t//控制脚也用普通io方便控制\n\tGPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;\n\tGPIO_Init(OLED_PORT, &amp;GPIO_InitStructure);\n\tGPIO_SetBits(OLED_PORT,OLED_CMD_PIN);\n\t\n\t/* SPI1 configuration */ \n\t//只有DO数据线朝oled里面发送，不需要读\n\tSPI_InitStructure.SPI_Direction = SPI_Direction_1Line_Tx;            //SPI1设置为单线只发送\n\tSPI_InitStructure.SPI_Mode = SPI_Mode_Master;\t                     //设置SPI1为主模式  MCU主设备，oled从设备\n\tSPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;                    //SPI发送接收8位帧结构\n\tSPI_InitStructure.SPI_CPOL = SPI_CPOL_High;\t \t\t                 //串行时钟在不操作时，时钟为高电平\n\tSPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;\t\t                 //第二个时钟沿开始采样数据\n\tSPI_InitStructure.SPI_NSS = SPI_NSS_Soft;\t\t\t                 //NSS信号由软件（使用SSI位）管理，我们这是接地的，实时在线\n\tSPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_8;   //定义波特率预分频的值:波特率预分频值为8\n\tSPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;\t\t\t\t     //数据传输从MSB位开始\n\tSPI_InitStructure.SPI_CRCPolynomial = 7;\t\t\t\t\t\t     //CRC值计算的多项式\n\tSPI_Init(SPI1, &amp;SPI_InitStructure);\n\t//初始化把配置的成员加载进寄存器\n\tSPI_Cmd(SPI1, ENABLE); \t\t\t\t\t\t\t\t\t\t\t  //使能SPI1外设\n&#125;\n\noled端口定义\n\n\n\n\n\n\n\n\n\n//-----------------OLED端口定义---------------- \n\n#define OLED_SCL_Clr() GPIO_ResetBits(OLED_SLK_PORT,OLED_SLK_PIN)//SCL\n#define OLED_SCL_Set() GPIO_SetBits(OLED_SLK_PORT,OLED_SLK_PIN)\n\n#define OLED_SDA_Clr() GPIO_ResetBits(OLED_DO_PORT,OLED_DO_PIN)//SDA\n#define OLED_SDA_Set() GPIO_SetBits(OLED_DO_PORT,OLED_DO_PIN)\n\n#define OLED_RES_Clr() GPIO_ResetBits(OLED_RES_PORT,OLED_RES_PIN)//RES\n#define OLED_RES_Set() GPIO_SetBits(OLED_RES_PORT,OLED_RES_PIN)\n\n#define OLED_DC_Clr()  GPIO_ResetBits(OLED_CMD_PORT,OLED_CMD_PIN)//DC\n#define OLED_DC_Set()  GPIO_SetBits(OLED_CMD_PORT,OLED_CMD_PIN)\n/*片选接地了，所以源码这个屏蔽一下\t\t     \n#define OLED_CS_Clr()  GPIO_ResetBits(GPIOA,GPIO_Pin_4)//CS\n#define OLED_CS_Set()  GPIO_SetBits(GPIOA,GPIO_Pin_4)\n*/\n\n原厂字库const unsigned char asc2_0806[][6] =\n&#123;\n&#123;0x00, 0x00, 0x00, 0x00, 0x00, 0x00&#125;,// sp\n&#123;0x00, 0x00, 0x00, 0x2f, 0x00, 0x00&#125;,// !\n&#123;0x00, 0x00, 0x07, 0x00, 0x07, 0x00&#125;,// \"\n&#123;0x00, 0x14, 0x7f, 0x14, 0x7f, 0x14&#125;,// #\n&#123;0x00, 0x24, 0x2a, 0x7f, 0x2a, 0x12&#125;,// $\n&#123;0x00, 0x62, 0x64, 0x08, 0x13, 0x23&#125;,// %\n&#123;0x00, 0x36, 0x49, 0x55, 0x22, 0x50&#125;,// &amp;\n&#123;0x00, 0x00, 0x05, 0x03, 0x00, 0x00&#125;,// '\n&#123;0x00, 0x00, 0x1c, 0x22, 0x41, 0x00&#125;,// (\n&#123;0x00, 0x00, 0x41, 0x22, 0x1c, 0x00&#125;,// )\n&#123;0x00, 0x14, 0x08, 0x3E, 0x08, 0x14&#125;,// *\n&#123;0x00, 0x08, 0x08, 0x3E, 0x08, 0x08&#125;,// +\n&#123;0x00, 0x00, 0x00, 0xA0, 0x60, 0x00&#125;,// ,\n&#123;0x00, 0x08, 0x08, 0x08, 0x08, 0x08&#125;,// -\n&#123;0x00, 0x00, 0x60, 0x60, 0x00, 0x00&#125;,// .\n&#123;0x00, 0x20, 0x10, 0x08, 0x04, 0x02&#125;,// /\n&#123;0x00, 0x3E, 0x51, 0x49, 0x45, 0x3E&#125;,// 0\n&#123;0x00, 0x00, 0x42, 0x7F, 0x40, 0x00&#125;,// 1\n&#123;0x00, 0x42, 0x61, 0x51, 0x49, 0x46&#125;,// 2\n&#123;0x00, 0x21, 0x41, 0x45, 0x4B, 0x31&#125;,// 3\n&#123;0x00, 0x18, 0x14, 0x12, 0x7F, 0x10&#125;,// 4\n&#123;0x00, 0x27, 0x45, 0x45, 0x45, 0x39&#125;,// 5\n&#123;0x00, 0x3C, 0x4A, 0x49, 0x49, 0x30&#125;,// 6\n&#123;0x00, 0x01, 0x71, 0x09, 0x05, 0x03&#125;,// 7\n&#123;0x00, 0x36, 0x49, 0x49, 0x49, 0x36&#125;,// 8\n&#123;0x00, 0x06, 0x49, 0x49, 0x29, 0x1E&#125;,// 9\n&#123;0x00, 0x00, 0x36, 0x36, 0x00, 0x00&#125;,// :\n&#123;0x00, 0x00, 0x56, 0x36, 0x00, 0x00&#125;,// ;\n&#123;0x00, 0x08, 0x14, 0x22, 0x41, 0x00&#125;,// &lt;\n&#123;0x00, 0x14, 0x14, 0x14, 0x14, 0x14&#125;,// =\n&#123;0x00, 0x00, 0x41, 0x22, 0x14, 0x08&#125;,// >\n&#123;0x00, 0x02, 0x01, 0x51, 0x09, 0x06&#125;,// ?\n&#123;0x00, 0x32, 0x49, 0x59, 0x51, 0x3E&#125;,// @\n&#123;0x00, 0x7C, 0x12, 0x11, 0x12, 0x7C&#125;,// A\n&#123;0x00, 0x7F, 0x49, 0x49, 0x49, 0x36&#125;,// B\n&#123;0x00, 0x3E, 0x41, 0x41, 0x41, 0x22&#125;,// C\n&#123;0x00, 0x7F, 0x41, 0x41, 0x22, 0x1C&#125;,// D\n&#123;0x00, 0x7F, 0x49, 0x49, 0x49, 0x41&#125;,// E\n&#123;0x00, 0x7F, 0x09, 0x09, 0x09, 0x01&#125;,// F\n&#123;0x00, 0x3E, 0x41, 0x49, 0x49, 0x7A&#125;,// G\n&#123;0x00, 0x7F, 0x08, 0x08, 0x08, 0x7F&#125;,// H\n&#123;0x00, 0x00, 0x41, 0x7F, 0x41, 0x00&#125;,// I\n&#123;0x00, 0x20, 0x40, 0x41, 0x3F, 0x01&#125;,// J\n&#123;0x00, 0x7F, 0x08, 0x14, 0x22, 0x41&#125;,// K\n&#123;0x00, 0x7F, 0x40, 0x40, 0x40, 0x40&#125;,// L\n&#123;0x00, 0x7F, 0x02, 0x0C, 0x02, 0x7F&#125;,// M\n&#123;0x00, 0x7F, 0x04, 0x08, 0x10, 0x7F&#125;,// N\n&#123;0x00, 0x3E, 0x41, 0x41, 0x41, 0x3E&#125;,// O\n&#123;0x00, 0x7F, 0x09, 0x09, 0x09, 0x06&#125;,// P\n&#123;0x00, 0x3E, 0x41, 0x51, 0x21, 0x5E&#125;,// Q\n&#123;0x00, 0x7F, 0x09, 0x19, 0x29, 0x46&#125;,// R\n&#123;0x00, 0x46, 0x49, 0x49, 0x49, 0x31&#125;,// S\n&#123;0x00, 0x01, 0x01, 0x7F, 0x01, 0x01&#125;,// T\n&#123;0x00, 0x3F, 0x40, 0x40, 0x40, 0x3F&#125;,// U\n&#123;0x00, 0x1F, 0x20, 0x40, 0x20, 0x1F&#125;,// V\n&#123;0x00, 0x3F, 0x40, 0x38, 0x40, 0x3F&#125;,// W\n&#123;0x00, 0x63, 0x14, 0x08, 0x14, 0x63&#125;,// X\n&#123;0x00, 0x07, 0x08, 0x70, 0x08, 0x07&#125;,// Y\n&#123;0x00, 0x61, 0x51, 0x49, 0x45, 0x43&#125;,// Z\n&#123;0x00, 0x00, 0x7F, 0x41, 0x41, 0x00&#125;,// [\n&#123;0x00, 0x55, 0x2A, 0x55, 0x2A, 0x55&#125;,// 55\n&#123;0x00, 0x00, 0x41, 0x41, 0x7F, 0x00&#125;,// ]\n&#123;0x00, 0x04, 0x02, 0x01, 0x02, 0x04&#125;,// ^\n&#123;0x00, 0x40, 0x40, 0x40, 0x40, 0x40&#125;,// _\n&#123;0x00, 0x00, 0x01, 0x02, 0x04, 0x00&#125;,// '\n&#123;0x00, 0x20, 0x54, 0x54, 0x54, 0x78&#125;,// a\n&#123;0x00, 0x7F, 0x48, 0x44, 0x44, 0x38&#125;,// b\n&#123;0x00, 0x38, 0x44, 0x44, 0x44, 0x20&#125;,// c\n&#123;0x00, 0x38, 0x44, 0x44, 0x48, 0x7F&#125;,// d\n&#123;0x00, 0x38, 0x54, 0x54, 0x54, 0x18&#125;,// e\n&#123;0x00, 0x08, 0x7E, 0x09, 0x01, 0x02&#125;,// f\n&#123;0x00, 0x18, 0xA4, 0xA4, 0xA4, 0x7C&#125;,// g\n&#123;0x00, 0x7F, 0x08, 0x04, 0x04, 0x78&#125;,// h\n&#123;0x00, 0x00, 0x44, 0x7D, 0x40, 0x00&#125;,// i\n&#123;0x00, 0x40, 0x80, 0x84, 0x7D, 0x00&#125;,// j\n&#123;0x00, 0x7F, 0x10, 0x28, 0x44, 0x00&#125;,// k\n&#123;0x00, 0x00, 0x41, 0x7F, 0x40, 0x00&#125;,// l\n&#123;0x00, 0x7C, 0x04, 0x18, 0x04, 0x78&#125;,// m\n&#123;0x00, 0x7C, 0x08, 0x04, 0x04, 0x78&#125;,// n\n&#123;0x00, 0x38, 0x44, 0x44, 0x44, 0x38&#125;,// o\n&#123;0x00, 0xFC, 0x24, 0x24, 0x24, 0x18&#125;,// p\n&#123;0x00, 0x18, 0x24, 0x24, 0x18, 0xFC&#125;,// q\n&#123;0x00, 0x7C, 0x08, 0x04, 0x04, 0x08&#125;,// r\n&#123;0x00, 0x48, 0x54, 0x54, 0x54, 0x20&#125;,// s\n&#123;0x00, 0x04, 0x3F, 0x44, 0x40, 0x20&#125;,// t\n&#123;0x00, 0x3C, 0x40, 0x40, 0x20, 0x7C&#125;,// u\n&#123;0x00, 0x1C, 0x20, 0x40, 0x20, 0x1C&#125;,// v\n&#123;0x00, 0x3C, 0x40, 0x30, 0x40, 0x3C&#125;,// w\n&#123;0x00, 0x44, 0x28, 0x10, 0x28, 0x44&#125;,// x\n&#123;0x00, 0x1C, 0xA0, 0xA0, 0xA0, 0x7C&#125;,// y\n&#123;0x00, 0x44, 0x64, 0x54, 0x4C, 0x44&#125;,// z\n&#123;0x14, 0x14, 0x14, 0x14, 0x14, 0x14&#125;,// horiz lines\n&#125;;\n//12*12 ASCII?????\nconst unsigned char asc2_1206[95][12]=&#123;\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\" \",0*/\n&#123;0x00,0x00,0xFC,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00&#125;,/*\"!\",1*/\n&#123;0x00,0x0C,0x02,0x0C,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\"\"\",2*/\n&#123;0x90,0xD0,0xBC,0xD0,0xBC,0x90,0x00,0x03,0x00,0x03,0x00,0x00&#125;,/*\"#\",3*/\n&#123;0x18,0x24,0xFE,0x44,0x8C,0x00,0x03,0x02,0x07,0x02,0x01,0x00&#125;,/*\"$\",4*/\n&#123;0x18,0x24,0xD8,0xB0,0x4C,0x80,0x00,0x03,0x00,0x01,0x02,0x01&#125;,/*\"%\",5*/\n&#123;0xC0,0x38,0xE4,0x38,0xE0,0x00,0x01,0x02,0x02,0x01,0x02,0x02&#125;,/*\"&amp;\",6*/\n&#123;0x08,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\"'\",7*/\n&#123;0x00,0x00,0x00,0xF8,0x04,0x02,0x00,0x00,0x00,0x01,0x02,0x04&#125;,/*\"(\",8*/\n&#123;0x00,0x02,0x04,0xF8,0x00,0x00,0x00,0x04,0x02,0x01,0x00,0x00&#125;,/*\")\",9*/\n&#123;0x90,0x60,0xF8,0x60,0x90,0x00,0x00,0x00,0x01,0x00,0x00,0x00&#125;,/*\"*\",10*/\n&#123;0x20,0x20,0xFC,0x20,0x20,0x00,0x00,0x00,0x01,0x00,0x00,0x00&#125;,/*\"+\",11*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x06,0x00,0x00,0x00,0x00&#125;,/*\",\",12*/\n&#123;0x20,0x20,0x20,0x20,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\"-\",13*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00&#125;,/*\".\",14*/\n&#123;0x00,0x80,0x60,0x1C,0x02,0x00,0x04,0x03,0x00,0x00,0x00,0x00&#125;,/*\"/\",15*/\n&#123;0xF8,0x04,0x04,0x04,0xF8,0x00,0x01,0x02,0x02,0x02,0x01,0x00&#125;,/*\"0\",16*/\n&#123;0x00,0x08,0xFC,0x00,0x00,0x00,0x00,0x02,0x03,0x02,0x00,0x00&#125;,/*\"1\",17*/\n&#123;0x18,0x84,0x44,0x24,0x18,0x00,0x03,0x02,0x02,0x02,0x02,0x00&#125;,/*\"2\",18*/\n&#123;0x08,0x04,0x24,0x24,0xD8,0x00,0x01,0x02,0x02,0x02,0x01,0x00&#125;,/*\"3\",19*/\n&#123;0x40,0xB0,0x88,0xFC,0x80,0x00,0x00,0x00,0x00,0x03,0x02,0x00&#125;,/*\"4\",20*/\n&#123;0x3C,0x24,0x24,0x24,0xC4,0x00,0x01,0x02,0x02,0x02,0x01,0x00&#125;,/*\"5\",21*/\n&#123;0xF8,0x24,0x24,0x2C,0xC0,0x00,0x01,0x02,0x02,0x02,0x01,0x00&#125;,/*\"6\",22*/\n&#123;0x0C,0x04,0xE4,0x1C,0x04,0x00,0x00,0x00,0x03,0x00,0x00,0x00&#125;,/*\"7\",23*/\n&#123;0xD8,0x24,0x24,0x24,0xD8,0x00,0x01,0x02,0x02,0x02,0x01,0x00&#125;,/*\"8\",24*/\n&#123;0x38,0x44,0x44,0x44,0xF8,0x00,0x00,0x03,0x02,0x02,0x01,0x00&#125;,/*\"9\",25*/\n&#123;0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00&#125;,/*\":\",26*/\n&#123;0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00&#125;,/*\";\",27*/\n&#123;0x00,0x20,0x50,0x88,0x04,0x02,0x00,0x00,0x00,0x00,0x01,0x02&#125;,/*\"&lt;\",28*/\n&#123;0x90,0x90,0x90,0x90,0x90,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\"=\",29*/\n&#123;0x00,0x02,0x04,0x88,0x50,0x20,0x00,0x02,0x01,0x00,0x00,0x00&#125;,/*\">\",30*/\n&#123;0x18,0x04,0xC4,0x24,0x18,0x00,0x00,0x00,0x02,0x00,0x00,0x00&#125;,/*\"?\",31*/\n&#123;0xF8,0x04,0xE4,0x94,0xF8,0x00,0x01,0x02,0x02,0x02,0x02,0x00&#125;,/*\"@\",32*/\n&#123;0x00,0xE0,0x9C,0xF0,0x80,0x00,0x02,0x03,0x00,0x00,0x03,0x02&#125;,/*\"A\",33*/\n&#123;0x04,0xFC,0x24,0x24,0xD8,0x00,0x02,0x03,0x02,0x02,0x01,0x00&#125;,/*\"B\",34*/\n&#123;0xF8,0x04,0x04,0x04,0x0C,0x00,0x01,0x02,0x02,0x02,0x01,0x00&#125;,/*\"C\",35*/\n&#123;0x04,0xFC,0x04,0x04,0xF8,0x00,0x02,0x03,0x02,0x02,0x01,0x00&#125;,/*\"D\",36*/\n&#123;0x04,0xFC,0x24,0x74,0x0C,0x00,0x02,0x03,0x02,0x02,0x03,0x00&#125;,/*\"E\",37*/\n&#123;0x04,0xFC,0x24,0x74,0x0C,0x00,0x02,0x03,0x02,0x00,0x00,0x00&#125;,/*\"F\",38*/\n&#123;0xF0,0x08,0x04,0x44,0xCC,0x40,0x00,0x01,0x02,0x02,0x01,0x00&#125;,/*\"G\",39*/\n&#123;0x04,0xFC,0x20,0x20,0xFC,0x04,0x02,0x03,0x00,0x00,0x03,0x02&#125;,/*\"H\",40*/\n&#123;0x04,0x04,0xFC,0x04,0x04,0x00,0x02,0x02,0x03,0x02,0x02,0x00&#125;,/*\"I\",41*/\n&#123;0x00,0x04,0x04,0xFC,0x04,0x04,0x06,0x04,0x04,0x03,0x00,0x00&#125;,/*\"J\",42*/\n&#123;0x04,0xFC,0x24,0xD0,0x0C,0x04,0x02,0x03,0x02,0x00,0x03,0x02&#125;,/*\"K\",43*/\n&#123;0x04,0xFC,0x04,0x00,0x00,0x00,0x02,0x03,0x02,0x02,0x02,0x03&#125;,/*\"L\",44*/\n&#123;0xFC,0x3C,0xC0,0x3C,0xFC,0x00,0x03,0x00,0x03,0x00,0x03,0x00&#125;,/*\"M\",45*/\n&#123;0x04,0xFC,0x30,0xC4,0xFC,0x04,0x02,0x03,0x02,0x00,0x03,0x00&#125;,/*\"N\",46*/\n&#123;0xF8,0x04,0x04,0x04,0xF8,0x00,0x01,0x02,0x02,0x02,0x01,0x00&#125;,/*\"O\",47*/\n&#123;0x04,0xFC,0x24,0x24,0x18,0x00,0x02,0x03,0x02,0x00,0x00,0x00&#125;,/*\"P\",48*/\n&#123;0xF8,0x84,0x84,0x04,0xF8,0x00,0x01,0x02,0x02,0x07,0x05,0x00&#125;,/*\"Q\",49*/\n&#123;0x04,0xFC,0x24,0x64,0x98,0x00,0x02,0x03,0x02,0x00,0x03,0x02&#125;,/*\"R\",50*/\n&#123;0x18,0x24,0x24,0x44,0x8C,0x00,0x03,0x02,0x02,0x02,0x01,0x00&#125;,/*\"S\",51*/\n&#123;0x0C,0x04,0xFC,0x04,0x0C,0x00,0x00,0x02,0x03,0x02,0x00,0x00&#125;,/*\"T\",52*/\n&#123;0x04,0xFC,0x00,0x00,0xFC,0x04,0x00,0x01,0x02,0x02,0x01,0x00&#125;,/*\"U\",53*/\n&#123;0x04,0x7C,0x80,0xE0,0x1C,0x04,0x00,0x00,0x03,0x00,0x00,0x00&#125;,/*\"V\",54*/\n&#123;0x1C,0xE0,0x3C,0xE0,0x1C,0x00,0x00,0x03,0x00,0x03,0x00,0x00&#125;,/*\"W\",55*/\n&#123;0x04,0x9C,0x60,0x9C,0x04,0x00,0x02,0x03,0x00,0x03,0x02,0x00&#125;,/*\"X\",56*/\n&#123;0x04,0x1C,0xE0,0x1C,0x04,0x00,0x00,0x02,0x03,0x02,0x00,0x00&#125;,/*\"Y\",57*/\n&#123;0x0C,0x84,0x64,0x1C,0x04,0x00,0x02,0x03,0x02,0x02,0x03,0x00&#125;,/*\"Z\",58*/\n&#123;0x00,0x00,0xFE,0x02,0x02,0x00,0x00,0x00,0x07,0x04,0x04,0x00&#125;,/*\"[\",59*/\n&#123;0x00,0x0E,0x30,0xC0,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x00&#125;,/*\"\\\",60*/\n&#123;0x00,0x02,0x02,0xFE,0x00,0x00,0x00,0x04,0x04,0x07,0x00,0x00&#125;,/*\"]\",61*/\n&#123;0x00,0x04,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\"^\",62*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x08,0x08,0x08,0x08,0x08&#125;,/*\"_\",63*/\n&#123;0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\"`\",64*/\n&#123;0x00,0x40,0xA0,0xA0,0xC0,0x00,0x00,0x01,0x02,0x02,0x03,0x02&#125;,/*\"a\",65*/\n&#123;0x04,0xFC,0x20,0x20,0xC0,0x00,0x00,0x03,0x02,0x02,0x01,0x00&#125;,/*\"b\",66*/\n&#123;0x00,0xC0,0x20,0x20,0x60,0x00,0x00,0x01,0x02,0x02,0x02,0x00&#125;,/*\"c\",67*/\n&#123;0x00,0xC0,0x20,0x24,0xFC,0x00,0x00,0x01,0x02,0x02,0x03,0x02&#125;,/*\"d\",68*/\n&#123;0x00,0xC0,0xA0,0xA0,0xC0,0x00,0x00,0x01,0x02,0x02,0x02,0x00&#125;,/*\"e\",69*/\n&#123;0x00,0x20,0xF8,0x24,0x24,0x04,0x00,0x02,0x03,0x02,0x02,0x00&#125;,/*\"f\",70*/\n&#123;0x00,0x40,0xA0,0xA0,0x60,0x20,0x00,0x07,0x0A,0x0A,0x0A,0x04&#125;,/*\"g\",71*/\n&#123;0x04,0xFC,0x20,0x20,0xC0,0x00,0x02,0x03,0x02,0x00,0x03,0x02&#125;,/*\"h\",72*/\n&#123;0x00,0x20,0xE4,0x00,0x00,0x00,0x00,0x02,0x03,0x02,0x00,0x00&#125;,/*\"i\",73*/\n&#123;0x00,0x00,0x20,0xE4,0x00,0x00,0x08,0x08,0x08,0x07,0x00,0x00&#125;,/*\"j\",74*/\n&#123;0x04,0xFC,0x80,0xE0,0x20,0x20,0x02,0x03,0x02,0x00,0x03,0x02&#125;,/*\"k\",75*/\n&#123;0x04,0x04,0xFC,0x00,0x00,0x00,0x02,0x02,0x03,0x02,0x02,0x00&#125;,/*\"l\",76*/\n&#123;0xE0,0x20,0xE0,0x20,0xC0,0x00,0x03,0x00,0x03,0x00,0x03,0x00&#125;,/*\"m\",77*/\n&#123;0x20,0xE0,0x20,0x20,0xC0,0x00,0x02,0x03,0x02,0x00,0x03,0x02&#125;,/*\"n\",78*/\n&#123;0x00,0xC0,0x20,0x20,0xC0,0x00,0x00,0x01,0x02,0x02,0x01,0x00&#125;,/*\"o\",79*/\n&#123;0x20,0xE0,0x20,0x20,0xC0,0x00,0x08,0x0F,0x0A,0x02,0x01,0x00&#125;,/*\"p\",80*/\n&#123;0x00,0xC0,0x20,0x20,0xE0,0x00,0x00,0x01,0x02,0x0A,0x0F,0x08&#125;,/*\"q\",81*/\n&#123;0x20,0xE0,0x40,0x20,0x20,0x00,0x02,0x03,0x02,0x00,0x00,0x00&#125;,/*\"r\",82*/\n&#123;0x00,0x60,0xA0,0xA0,0x20,0x00,0x00,0x02,0x02,0x02,0x03,0x00&#125;,/*\"s\",83*/\n&#123;0x00,0x20,0xF8,0x20,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x00&#125;,/*\"t\",84*/\n&#123;0x20,0xE0,0x00,0x20,0xE0,0x00,0x00,0x01,0x02,0x02,0x03,0x02&#125;,/*\"u\",85*/\n&#123;0x20,0xE0,0x20,0x80,0x60,0x20,0x00,0x00,0x03,0x01,0x00,0x00&#125;,/*\"v\",86*/\n&#123;0x60,0x80,0xE0,0x80,0x60,0x00,0x00,0x03,0x00,0x03,0x00,0x00&#125;,/*\"w\",87*/\n&#123;0x20,0x60,0x80,0x60,0x20,0x00,0x02,0x03,0x00,0x03,0x02,0x00&#125;,/*\"x\",88*/\n&#123;0x20,0xE0,0x20,0x80,0x60,0x20,0x08,0x08,0x07,0x01,0x00,0x00&#125;,/*\"y\",89*/\n&#123;0x00,0x20,0xA0,0x60,0x20,0x00,0x00,0x02,0x03,0x02,0x02,0x00&#125;,/*\"z\",90*/\n&#123;0x00,0x00,0x20,0xDE,0x02,0x00,0x00,0x00,0x00,0x07,0x04,0x00&#125;,/*\"&#123;\",91*/\n&#123;0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x0F,0x00,0x00&#125;,/*\"|\",92*/\n&#123;0x00,0x02,0xDE,0x20,0x00,0x00,0x00,0x04,0x07,0x00,0x00,0x00&#125;,/*\"&#125;\",93*/\n&#123;0x02,0x01,0x02,0x04,0x04,0x02,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\"~\",94*/\n&#125;;  \n//16*16 ASCII?????\nconst unsigned char asc2_1608[][16]=&#123;\t  \n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\" \",0*/\n&#123;0x00,0x00,0x00,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x33,0x30,0x00,0x00,0x00&#125;,/*\"!\",1*/\n&#123;0x00,0x10,0x0C,0x06,0x10,0x0C,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\"\"\",2*/\n&#123;0x40,0xC0,0x78,0x40,0xC0,0x78,0x40,0x00,0x04,0x3F,0x04,0x04,0x3F,0x04,0x04,0x00&#125;,/*\"#\",3*/\n&#123;0x00,0x70,0x88,0xFC,0x08,0x30,0x00,0x00,0x00,0x18,0x20,0xFF,0x21,0x1E,0x00,0x00&#125;,/*\"$\",4*/\n&#123;0xF0,0x08,0xF0,0x00,0xE0,0x18,0x00,0x00,0x00,0x21,0x1C,0x03,0x1E,0x21,0x1E,0x00&#125;,/*\"%\",5*/\n&#123;0x00,0xF0,0x08,0x88,0x70,0x00,0x00,0x00,0x1E,0x21,0x23,0x24,0x19,0x27,0x21,0x10&#125;,/*\"&amp;\",6*/\n&#123;0x10,0x16,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\"'\",7*/\n&#123;0x00,0x00,0x00,0xE0,0x18,0x04,0x02,0x00,0x00,0x00,0x00,0x07,0x18,0x20,0x40,0x00&#125;,/*\"(\",8*/\n&#123;0x00,0x02,0x04,0x18,0xE0,0x00,0x00,0x00,0x00,0x40,0x20,0x18,0x07,0x00,0x00,0x00&#125;,/*\")\",9*/\n&#123;0x40,0x40,0x80,0xF0,0x80,0x40,0x40,0x00,0x02,0x02,0x01,0x0F,0x01,0x02,0x02,0x00&#125;,/*\"*\",10*/\n&#123;0x00,0x00,0x00,0xF0,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x1F,0x01,0x01,0x01,0x00&#125;,/*\"+\",11*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xB0,0x70,0x00,0x00,0x00,0x00,0x00&#125;,/*\",\",12*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01&#125;,/*\"-\",13*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x00&#125;,/*\".\",14*/\n&#123;0x00,0x00,0x00,0x00,0x80,0x60,0x18,0x04,0x00,0x60,0x18,0x06,0x01,0x00,0x00,0x00&#125;,/*\"/\",15*/\n&#123;0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x0F,0x10,0x20,0x20,0x10,0x0F,0x00&#125;,/*\"0\",16*/\n&#123;0x00,0x10,0x10,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00&#125;,/*\"1\",17*/\n&#123;0x00,0x70,0x08,0x08,0x08,0x88,0x70,0x00,0x00,0x30,0x28,0x24,0x22,0x21,0x30,0x00&#125;,/*\"2\",18*/\n&#123;0x00,0x30,0x08,0x88,0x88,0x48,0x30,0x00,0x00,0x18,0x20,0x20,0x20,0x11,0x0E,0x00&#125;,/*\"3\",19*/\n&#123;0x00,0x00,0xC0,0x20,0x10,0xF8,0x00,0x00,0x00,0x07,0x04,0x24,0x24,0x3F,0x24,0x00&#125;,/*\"4\",20*/\n&#123;0x00,0xF8,0x08,0x88,0x88,0x08,0x08,0x00,0x00,0x19,0x21,0x20,0x20,0x11,0x0E,0x00&#125;,/*\"5\",21*/\n&#123;0x00,0xE0,0x10,0x88,0x88,0x18,0x00,0x00,0x00,0x0F,0x11,0x20,0x20,0x11,0x0E,0x00&#125;,/*\"6\",22*/\n&#123;0x00,0x38,0x08,0x08,0xC8,0x38,0x08,0x00,0x00,0x00,0x00,0x3F,0x00,0x00,0x00,0x00&#125;,/*\"7\",23*/\n&#123;0x00,0x70,0x88,0x08,0x08,0x88,0x70,0x00,0x00,0x1C,0x22,0x21,0x21,0x22,0x1C,0x00&#125;,/*\"8\",24*/\n&#123;0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x00,0x31,0x22,0x22,0x11,0x0F,0x00&#125;,/*\"9\",25*/\n&#123;0x00,0x00,0x00,0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00&#125;,/*\":\",26*/\n&#123;0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x60,0x00,0x00,0x00,0x00&#125;,/*\";\",27*/\n&#123;0x00,0x00,0x80,0x40,0x20,0x10,0x08,0x00,0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x00&#125;,/*\"&lt;\",28*/\n&#123;0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x00,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x00&#125;,/*\"=\",29*/\n&#123;0x00,0x08,0x10,0x20,0x40,0x80,0x00,0x00,0x00,0x20,0x10,0x08,0x04,0x02,0x01,0x00&#125;,/*\">\",30*/\n&#123;0x00,0x70,0x48,0x08,0x08,0x08,0xF0,0x00,0x00,0x00,0x00,0x30,0x36,0x01,0x00,0x00&#125;,/*\"?\",31*/\n&#123;0xC0,0x30,0xC8,0x28,0xE8,0x10,0xE0,0x00,0x07,0x18,0x27,0x24,0x23,0x14,0x0B,0x00&#125;,/*\"@\",32*/\n&#123;0x00,0x00,0xC0,0x38,0xE0,0x00,0x00,0x00,0x20,0x3C,0x23,0x02,0x02,0x27,0x38,0x20&#125;,/*\"A\",33*/\n&#123;0x08,0xF8,0x88,0x88,0x88,0x70,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x11,0x0E,0x00&#125;,/*\"B\",34*/\n&#123;0xC0,0x30,0x08,0x08,0x08,0x08,0x38,0x00,0x07,0x18,0x20,0x20,0x20,0x10,0x08,0x00&#125;,/*\"C\",35*/\n&#123;0x08,0xF8,0x08,0x08,0x08,0x10,0xE0,0x00,0x20,0x3F,0x20,0x20,0x20,0x10,0x0F,0x00&#125;,/*\"D\",36*/\n&#123;0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x20,0x23,0x20,0x18,0x00&#125;,/*\"E\",37*/\n&#123;0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x00,0x03,0x00,0x00,0x00&#125;,/*\"F\",38*/\n&#123;0xC0,0x30,0x08,0x08,0x08,0x38,0x00,0x00,0x07,0x18,0x20,0x20,0x22,0x1E,0x02,0x00&#125;,/*\"G\",39*/\n&#123;0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x20,0x3F,0x21,0x01,0x01,0x21,0x3F,0x20&#125;,/*\"H\",40*/\n&#123;0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00&#125;,/*\"I\",41*/\n&#123;0x00,0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,0x00&#125;,/*\"J\",42*/\n&#123;0x08,0xF8,0x88,0xC0,0x28,0x18,0x08,0x00,0x20,0x3F,0x20,0x01,0x26,0x38,0x20,0x00&#125;,/*\"K\",43*/\n&#123;0x08,0xF8,0x08,0x00,0x00,0x00,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x20,0x30,0x00&#125;,/*\"L\",44*/\n&#123;0x08,0xF8,0xF8,0x00,0xF8,0xF8,0x08,0x00,0x20,0x3F,0x00,0x3F,0x00,0x3F,0x20,0x00&#125;,/*\"M\",45*/\n&#123;0x08,0xF8,0x30,0xC0,0x00,0x08,0xF8,0x08,0x20,0x3F,0x20,0x00,0x07,0x18,0x3F,0x00&#125;,/*\"N\",46*/\n&#123;0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x10,0x20,0x20,0x20,0x10,0x0F,0x00&#125;,/*\"O\",47*/\n&#123;0x08,0xF8,0x08,0x08,0x08,0x08,0xF0,0x00,0x20,0x3F,0x21,0x01,0x01,0x01,0x00,0x00&#125;,/*\"P\",48*/\n&#123;0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x18,0x24,0x24,0x38,0x50,0x4F,0x00&#125;,/*\"Q\",49*/\n&#123;0x08,0xF8,0x88,0x88,0x88,0x88,0x70,0x00,0x20,0x3F,0x20,0x00,0x03,0x0C,0x30,0x20&#125;,/*\"R\",50*/\n&#123;0x00,0x70,0x88,0x08,0x08,0x08,0x38,0x00,0x00,0x38,0x20,0x21,0x21,0x22,0x1C,0x00&#125;,/*\"S\",51*/\n&#123;0x18,0x08,0x08,0xF8,0x08,0x08,0x18,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00&#125;,/*\"T\",52*/\n&#123;0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00&#125;,/*\"U\",53*/\n&#123;0x08,0x78,0x88,0x00,0x00,0xC8,0x38,0x08,0x00,0x00,0x07,0x38,0x0E,0x01,0x00,0x00&#125;,/*\"V\",54*/\n&#123;0xF8,0x08,0x00,0xF8,0x00,0x08,0xF8,0x00,0x03,0x3C,0x07,0x00,0x07,0x3C,0x03,0x00&#125;,/*\"W\",55*/\n&#123;0x08,0x18,0x68,0x80,0x80,0x68,0x18,0x08,0x20,0x30,0x2C,0x03,0x03,0x2C,0x30,0x20&#125;,/*\"X\",56*/\n&#123;0x08,0x38,0xC8,0x00,0xC8,0x38,0x08,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00&#125;,/*\"Y\",57*/\n&#123;0x10,0x08,0x08,0x08,0xC8,0x38,0x08,0x00,0x20,0x38,0x26,0x21,0x20,0x20,0x18,0x00&#125;,/*\"Z\",58*/\n&#123;0x00,0x00,0x00,0xFE,0x02,0x02,0x02,0x00,0x00,0x00,0x00,0x7F,0x40,0x40,0x40,0x00&#125;,/*\"[\",59*/\n&#123;0x00,0x0C,0x30,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x06,0x38,0xC0,0x00&#125;,/*\"\\\",60*/\n&#123;0x00,0x02,0x02,0x02,0xFE,0x00,0x00,0x00,0x00,0x40,0x40,0x40,0x7F,0x00,0x00,0x00&#125;,/*\"]\",61*/\n&#123;0x00,0x00,0x04,0x02,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\"^\",62*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80&#125;,/*\"_\",63*/\n&#123;0x00,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\"`\",64*/\n&#123;0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x19,0x24,0x22,0x22,0x22,0x3F,0x20&#125;,/*\"a\",65*/\n&#123;0x08,0xF8,0x00,0x80,0x80,0x00,0x00,0x00,0x00,0x3F,0x11,0x20,0x20,0x11,0x0E,0x00&#125;,/*\"b\",66*/\n&#123;0x00,0x00,0x00,0x80,0x80,0x80,0x00,0x00,0x00,0x0E,0x11,0x20,0x20,0x20,0x11,0x00&#125;,/*\"c\",67*/\n&#123;0x00,0x00,0x00,0x80,0x80,0x88,0xF8,0x00,0x00,0x0E,0x11,0x20,0x20,0x10,0x3F,0x20&#125;,/*\"d\",68*/\n&#123;0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x22,0x22,0x22,0x22,0x13,0x00&#125;,/*\"e\",69*/\n&#123;0x00,0x80,0x80,0xF0,0x88,0x88,0x88,0x18,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00&#125;,/*\"f\",70*/\n&#123;0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x6B,0x94,0x94,0x94,0x93,0x60,0x00&#125;,/*\"g\",71*/\n&#123;0x08,0xF8,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20&#125;,/*\"h\",72*/\n&#123;0x00,0x80,0x98,0x98,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00&#125;,/*\"i\",73*/\n&#123;0x00,0x00,0x00,0x80,0x98,0x98,0x00,0x00,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00&#125;,/*\"j\",74*/\n&#123;0x08,0xF8,0x00,0x00,0x80,0x80,0x80,0x00,0x20,0x3F,0x24,0x02,0x2D,0x30,0x20,0x00&#125;,/*\"k\",75*/\n&#123;0x00,0x08,0x08,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00&#125;,/*\"l\",76*/\n&#123;0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x20,0x3F,0x20,0x00,0x3F,0x20,0x00,0x3F&#125;,/*\"m\",77*/\n&#123;0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20&#125;,/*\"n\",78*/\n&#123;0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00&#125;,/*\"o\",79*/\n&#123;0x80,0x80,0x00,0x80,0x80,0x00,0x00,0x00,0x80,0xFF,0xA1,0x20,0x20,0x11,0x0E,0x00&#125;,/*\"p\",80*/\n&#123;0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x0E,0x11,0x20,0x20,0xA0,0xFF,0x80&#125;,/*\"q\",81*/\n&#123;0x80,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x20,0x20,0x3F,0x21,0x20,0x00,0x01,0x00&#125;,/*\"r\",82*/\n&#123;0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x33,0x24,0x24,0x24,0x24,0x19,0x00&#125;,/*\"s\",83*/\n&#123;0x00,0x80,0x80,0xE0,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x1F,0x20,0x20,0x00,0x00&#125;,/*\"t\",84*/\n&#123;0x80,0x80,0x00,0x00,0x00,0x80,0x80,0x00,0x00,0x1F,0x20,0x20,0x20,0x10,0x3F,0x20&#125;,/*\"u\",85*/\n&#123;0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x00,0x01,0x0E,0x30,0x08,0x06,0x01,0x00&#125;,/*\"v\",86*/\n&#123;0x80,0x80,0x00,0x80,0x00,0x80,0x80,0x80,0x0F,0x30,0x0C,0x03,0x0C,0x30,0x0F,0x00&#125;,/*\"w\",87*/\n&#123;0x00,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x31,0x2E,0x0E,0x31,0x20,0x00&#125;,/*\"x\",88*/\n&#123;0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x80,0x81,0x8E,0x70,0x18,0x06,0x01,0x00&#125;,/*\"y\",89*/\n&#123;0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x21,0x30,0x2C,0x22,0x21,0x30,0x00&#125;,/*\"z\",90*/\n&#123;0x00,0x00,0x00,0x00,0x80,0x7C,0x02,0x02,0x00,0x00,0x00,0x00,0x00,0x3F,0x40,0x40&#125;,/*\"&#123;\",91*/\n&#123;0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00&#125;,/*\"|\",92*/\n&#123;0x00,0x02,0x02,0x7C,0x80,0x00,0x00,0x00,0x00,0x40,0x40,0x3F,0x00,0x00,0x00,0x00&#125;,/*\"&#125;\",93*/\n&#123;0x00,0x06,0x01,0x01,0x02,0x02,0x04,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\"~\",94*/\n&#125;;  \n//24*24 ASICII?????\nconst unsigned char asc2_2412[][36]=&#123;\t  \n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\" \",0*/\n&#123;0x00,0x00,0x00,0x00,0x00,0xF0,0xF0,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x7F,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1C,0x1C,0x1C,0x00,0x00,0x00,0x00&#125;,/*\"!\",1*/\n&#123;0x00,0x00,0x80,0x60,0x30,0x1C,0x8C,0x60,0x30,0x1C,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\"\"\",2*/\n&#123;0x00,0x00,0x00,0xE0,0x00,0x00,0x00,0x00,0x00,0xE0,0x00,0x00,0x00,0x86,0xE6,0x9F,0x86,0x86,0x86,0x86,0xE6,0x9F,0x86,0x00,0x00,0x01,0x1F,0x01,0x01,0x01,0x01,0x01,0x1F,0x01,0x01,0x00&#125;,/*\"#\",3*/\n&#123;0x00,0x00,0x80,0xC0,0x60,0x20,0xF8,0x20,0xE0,0xC0,0x00,0x00,0x00,0x00,0x03,0x07,0x0C,0x18,0xFF,0x70,0xE1,0x81,0x00,0x00,0x00,0x00,0x07,0x0F,0x10,0x10,0x7F,0x10,0x0F,0x07,0x00,0x00&#125;,/*\"$\",4*/\n&#123;0x80,0x60,0x20,0x60,0x80,0x00,0x00,0x00,0xE0,0x20,0x00,0x00,0x0F,0x30,0x20,0x30,0x9F,0x70,0xDC,0x37,0x10,0x30,0xC0,0x00,0x00,0x00,0x10,0x0E,0x03,0x00,0x07,0x18,0x10,0x18,0x07,0x00&#125;,/*\"%\",5*/\n&#123;0x00,0x00,0xC0,0x20,0x20,0xE0,0xC0,0x00,0x00,0x00,0x00,0x00,0x80,0xE0,0x1F,0x38,0xE8,0x87,0x03,0xC4,0x3C,0x04,0x00,0x00,0x07,0x0F,0x18,0x10,0x10,0x0B,0x07,0x0D,0x10,0x10,0x08,0x00&#125;,/*\"&amp;\",6*/\n&#123;0x00,0x80,0x8C,0x4C,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\"'\",7*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xE0,0x30,0x08,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0xFF,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x0F,0x18,0x20,0x40,0x00&#125;,/*\"(\",8*/\n&#123;0x00,0x04,0x08,0x30,0xE0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x20,0x18,0x0F,0x03,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\")\",9*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x42,0x66,0x66,0x3C,0x18,0xFF,0x18,0x3C,0x66,0x66,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00&#125;,/*\"*\",10*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x10,0x10,0x10,0x10,0xFF,0x10,0x10,0x10,0x10,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00&#125;,/*\"+\",11*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x8C,0x4C,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\",\",12*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\"-\",13*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1C,0x1C,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\".\",14*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x38,0x0C,0x00,0x00,0x00,0x00,0x00,0x80,0x70,0x1C,0x03,0x00,0x00,0x00,0x00,0x00,0x60,0x38,0x0E,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\"/\",15*/\n&#123;0x00,0x00,0x80,0xC0,0x60,0x20,0x20,0x60,0xC0,0x80,0x00,0x00,0x00,0xFE,0xFF,0x01,0x00,0x00,0x00,0x00,0x01,0xFF,0xFE,0x00,0x00,0x01,0x07,0x0E,0x18,0x10,0x10,0x18,0x0E,0x07,0x01,0x00&#125;,/*\"0\",16*/\n&#123;0x00,0x00,0x80,0x80,0x80,0xC0,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x10,0x10,0x1F,0x1F,0x10,0x10,0x10,0x00,0x00&#125;,/*\"1\",17*/\n&#123;0x00,0x80,0x40,0x20,0x20,0x20,0x20,0x60,0xC0,0x80,0x00,0x00,0x00,0x03,0x03,0x00,0x80,0x40,0x20,0x38,0x1F,0x07,0x00,0x00,0x00,0x1C,0x1A,0x19,0x18,0x18,0x18,0x18,0x18,0x1F,0x00,0x00&#125;,/*\"2\",18*/\n&#123;0x00,0x80,0xC0,0x20,0x20,0x20,0x60,0xC0,0x80,0x00,0x00,0x00,0x00,0x03,0x03,0x00,0x10,0x10,0x18,0x2F,0xE7,0x80,0x00,0x00,0x00,0x07,0x0F,0x10,0x10,0x10,0x10,0x18,0x0F,0x07,0x00,0x00&#125;,/*\"3\",19*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0xE0,0xF0,0x00,0x00,0x00,0x00,0xC0,0xB0,0x88,0x86,0x81,0x80,0xFF,0xFF,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x10,0x1F,0x1F,0x10,0x10,0x00&#125;,/*\"4\",20*/\n&#123;0x00,0x00,0xE0,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x00,0x00,0x00,0x00,0x3F,0x10,0x08,0x08,0x08,0x18,0xF0,0xE0,0x00,0x00,0x00,0x07,0x0B,0x10,0x10,0x10,0x10,0x1C,0x0F,0x03,0x00,0x00&#125;,/*\"5\",21*/\n&#123;0x00,0x00,0x80,0xC0,0x40,0x20,0x20,0x20,0xE0,0xC0,0x00,0x00,0x00,0xFC,0xFF,0x21,0x10,0x08,0x08,0x08,0x18,0xF0,0xE0,0x00,0x00,0x01,0x07,0x0C,0x18,0x10,0x10,0x10,0x08,0x0F,0x03,0x00&#125;,/*\"6\",22*/\n&#123;0x00,0x00,0xC0,0xE0,0x60,0x60,0x60,0x60,0x60,0xE0,0x60,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0xE0,0x18,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0x1F,0x00,0x00,0x00,0x00,0x00&#125;,/*\"7\",23*/\n&#123;0x00,0x80,0xC0,0x60,0x20,0x20,0x20,0x20,0x60,0xC0,0x80,0x00,0x00,0x87,0xEF,0x2C,0x18,0x18,0x30,0x30,0x68,0xCF,0x83,0x00,0x00,0x07,0x0F,0x08,0x10,0x10,0x10,0x10,0x18,0x0F,0x07,0x00&#125;,/*\"8\",24*/\n&#123;0x00,0x00,0xC0,0xC0,0x20,0x20,0x20,0x20,0xC0,0x80,0x00,0x00,0x00,0x1F,0x3F,0x60,0x40,0x40,0x40,0x20,0x10,0xFF,0xFE,0x00,0x00,0x00,0x0C,0x1C,0x10,0x10,0x10,0x08,0x0F,0x03,0x00,0x00&#125;,/*\"9\",25*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0E,0x0E,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1C,0x1C,0x1C,0x00,0x00,0x00,0x00&#125;,/*\":\",26*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0C,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x38,0x00,0x00,0x00,0x00,0x00&#125;,/*\";\",27*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x40,0x20,0x10,0x00,0x00,0x00,0x10,0x28,0x44,0x82,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x04,0x08,0x10,0x00&#125;,/*\"&lt;\",28*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\"=\",29*/\n&#123;0x00,0x00,0x10,0x20,0x40,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x82,0x44,0x28,0x10,0x00,0x00,0x00,0x10,0x08,0x04,0x02,0x01,0x00,0x00,0x00,0x00,0x00&#125;,/*\">\",30*/\n&#123;0x00,0xC0,0x20,0x20,0x10,0x10,0x10,0x10,0x30,0xE0,0xC0,0x00,0x00,0x03,0x03,0x00,0x00,0xF0,0x10,0x08,0x0C,0x07,0x03,0x00,0x00,0x00,0x00,0x00,0x1C,0x1C,0x1C,0x00,0x00,0x00,0x00,0x00&#125;,/*\"?\",31*/\n&#123;0x00,0x00,0x00,0xC0,0x40,0x60,0x20,0x20,0x20,0x40,0xC0,0x00,0x00,0xFC,0xFF,0x01,0xF0,0x0E,0x03,0xC1,0xFE,0x03,0x80,0x7F,0x00,0x01,0x07,0x0E,0x08,0x11,0x11,0x10,0x11,0x09,0x04,0x02&#125;,/*\"@\",32*/\n&#123;0x00,0x00,0x00,0x00,0x80,0xE0,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x7C,0x43,0x40,0x47,0x7F,0xF8,0x80,0x00,0x00,0x10,0x18,0x1F,0x10,0x00,0x00,0x00,0x00,0x13,0x1F,0x1C,0x10&#125;,/*\"A\",33*/\n&#123;0x20,0xE0,0xE0,0x20,0x20,0x20,0x20,0x60,0xC0,0x80,0x00,0x00,0x00,0xFF,0xFF,0x10,0x10,0x10,0x10,0x18,0x2F,0xE7,0x80,0x00,0x10,0x1F,0x1F,0x10,0x10,0x10,0x10,0x10,0x18,0x0F,0x07,0x00&#125;,/*\"B\",34*/\n&#123;0x00,0x00,0x80,0xC0,0x40,0x20,0x20,0x20,0x20,0x60,0xE0,0x00,0x00,0xFC,0xFF,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x01,0x07,0x0E,0x18,0x10,0x10,0x10,0x08,0x04,0x03,0x00&#125;,/*\"C\",35*/\n&#123;0x20,0xE0,0xE0,0x20,0x20,0x20,0x20,0x40,0xC0,0x80,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0xFE,0x00,0x10,0x1F,0x1F,0x10,0x10,0x10,0x18,0x08,0x0E,0x07,0x01,0x00&#125;,/*\"D\",36*/\n&#123;0x20,0xE0,0xE0,0x20,0x20,0x20,0x20,0x20,0x20,0x60,0x80,0x00,0x00,0xFF,0xFF,0x10,0x10,0x10,0x10,0x7C,0x00,0x00,0x00,0x00,0x10,0x1F,0x1F,0x10,0x10,0x10,0x10,0x10,0x10,0x18,0x06,0x00&#125;,/*\"E\",37*/\n&#123;0x20,0xE0,0xE0,0x20,0x20,0x20,0x20,0x20,0x60,0x60,0x80,0x00,0x00,0xFF,0xFF,0x10,0x10,0x10,0x10,0x7C,0x00,0x00,0x01,0x00,0x10,0x1F,0x1F,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\"F\",38*/\n&#123;0x00,0x00,0x80,0xC0,0x60,0x20,0x20,0x20,0x40,0xE0,0x00,0x00,0x00,0xFC,0xFF,0x01,0x00,0x00,0x40,0x40,0xC0,0xC1,0x40,0x40,0x00,0x01,0x07,0x0E,0x18,0x10,0x10,0x10,0x0F,0x0F,0x00,0x00&#125;,/*\"G\",39*/\n&#123;0x20,0xE0,0xE0,0x20,0x00,0x00,0x00,0x00,0x20,0xE0,0xE0,0x20,0x00,0xFF,0xFF,0x10,0x10,0x10,0x10,0x10,0x10,0xFF,0xFF,0x00,0x10,0x1F,0x1F,0x10,0x00,0x00,0x00,0x00,0x10,0x1F,0x1F,0x10&#125;,/*\"H\",40*/\n&#123;0x00,0x00,0x20,0x20,0x20,0xE0,0xE0,0x20,0x20,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x10,0x10,0x1F,0x1F,0x10,0x10,0x10,0x00,0x00&#125;,/*\"I\",41*/\n&#123;0x00,0x00,0x00,0x00,0x20,0x20,0x20,0xE0,0xE0,0x20,0x20,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x60,0xE0,0x80,0x80,0x80,0xC0,0x7F,0x3F,0x00,0x00,0x00&#125;,/*\"J\",42*/\n&#123;0x20,0xE0,0xE0,0x20,0x00,0x00,0x20,0xA0,0x60,0x20,0x20,0x00,0x00,0xFF,0xFF,0x30,0x18,0x7C,0xE3,0xC0,0x00,0x00,0x00,0x00,0x10,0x1F,0x1F,0x10,0x00,0x00,0x01,0x13,0x1F,0x1C,0x18,0x10&#125;,/*\"K\",43*/\n&#123;0x20,0xE0,0xE0,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x1F,0x1F,0x10,0x10,0x10,0x10,0x10,0x10,0x18,0x06,0x00&#125;,/*\"L\",44*/\n&#123;0x20,0xE0,0xE0,0xE0,0x00,0x00,0x00,0x00,0xE0,0xE0,0xE0,0x20,0x00,0xFF,0x01,0x3F,0xFE,0xC0,0xE0,0x1E,0x01,0xFF,0xFF,0x00,0x10,0x1F,0x10,0x00,0x03,0x1F,0x03,0x00,0x10,0x1F,0x1F,0x10&#125;,/*\"M\",45*/\n&#123;0x20,0xE0,0xE0,0xC0,0x00,0x00,0x00,0x00,0x00,0x20,0xE0,0x20,0x00,0xFF,0x00,0x03,0x07,0x1C,0x78,0xE0,0x80,0x00,0xFF,0x00,0x10,0x1F,0x10,0x00,0x00,0x00,0x00,0x00,0x03,0x0F,0x1F,0x00&#125;,/*\"N\",46*/\n&#123;0x00,0x00,0x80,0xC0,0x60,0x20,0x20,0x60,0xC0,0x80,0x00,0x00,0x00,0xFE,0xFF,0x01,0x00,0x00,0x00,0x00,0x00,0xFF,0xFE,0x00,0x00,0x01,0x07,0x0E,0x18,0x10,0x10,0x18,0x0C,0x07,0x01,0x00&#125;,/*\"O\",47*/\n&#123;0x20,0xE0,0xE0,0x20,0x20,0x20,0x20,0x20,0x60,0xC0,0x80,0x00,0x00,0xFF,0xFF,0x20,0x20,0x20,0x20,0x20,0x30,0x1F,0x0F,0x00,0x10,0x1F,0x1F,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\"P\",48*/\n&#123;0x00,0x00,0x80,0xC0,0x60,0x20,0x20,0x60,0xC0,0x80,0x00,0x00,0x00,0xFE,0xFF,0x01,0x00,0x00,0x00,0x00,0x00,0xFF,0xFE,0x00,0x00,0x01,0x07,0x0E,0x11,0x11,0x13,0x3C,0x7C,0x67,0x21,0x00&#125;,/*\"Q\",49*/\n&#123;0x20,0xE0,0xE0,0x20,0x20,0x20,0x20,0x20,0x60,0xC0,0x80,0x00,0x00,0xFF,0xFF,0x10,0x10,0x30,0xF0,0xD0,0x08,0x0F,0x07,0x00,0x10,0x1F,0x1F,0x10,0x00,0x00,0x00,0x03,0x0F,0x1C,0x10,0x10&#125;,/*\"R\",50*/\n&#123;0x00,0x80,0xC0,0x60,0x20,0x20,0x20,0x20,0x40,0x40,0xE0,0x00,0x00,0x07,0x0F,0x0C,0x18,0x18,0x30,0x30,0x60,0xE0,0x81,0x00,0x00,0x1F,0x0C,0x08,0x10,0x10,0x10,0x10,0x18,0x0F,0x07,0x00&#125;,/*\"S\",51*/\n&#123;0x80,0x60,0x20,0x20,0x20,0xE0,0xE0,0x20,0x20,0x20,0x60,0x80,0x01,0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x10,0x1F,0x1F,0x10,0x00,0x00,0x00,0x00&#125;,/*\"T\",52*/\n&#123;0x20,0xE0,0xE0,0x20,0x00,0x00,0x00,0x00,0x00,0x20,0xE0,0x20,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x07,0x0F,0x18,0x10,0x10,0x10,0x10,0x10,0x08,0x07,0x00&#125;,/*\"U\",53*/\n&#123;0x20,0x60,0xE0,0xE0,0x20,0x00,0x00,0x00,0x20,0xE0,0x60,0x20,0x00,0x00,0x07,0x7F,0xF8,0x80,0x00,0x80,0x7C,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x1F,0x1C,0x07,0x00,0x00,0x00,0x00&#125;,/*\"V\",54*/\n&#123;0x20,0xE0,0xE0,0x20,0x00,0xE0,0xE0,0x20,0x00,0x20,0xE0,0x20,0x00,0x07,0xFF,0xF8,0xE0,0x1F,0xFF,0xFC,0xE0,0x1F,0x00,0x00,0x00,0x00,0x03,0x1F,0x03,0x00,0x01,0x1F,0x03,0x00,0x00,0x00&#125;,/*\"W\",55*/\n&#123;0x00,0x20,0x60,0xE0,0xA0,0x00,0x00,0x20,0xE0,0x60,0x20,0x00,0x00,0x00,0x00,0x03,0x8F,0x7C,0xF8,0xC6,0x01,0x00,0x00,0x00,0x00,0x10,0x18,0x1E,0x13,0x00,0x01,0x17,0x1F,0x18,0x10,0x00&#125;,/*\"X\",56*/\n&#123;0x20,0x60,0xE0,0xE0,0x20,0x00,0x00,0x00,0x20,0xE0,0x60,0x20,0x00,0x00,0x01,0x07,0x3E,0xF8,0xE0,0x18,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x10,0x1F,0x1F,0x10,0x10,0x00,0x00,0x00&#125;,/*\"Y\",57*/\n&#123;0x00,0x80,0x60,0x20,0x20,0x20,0x20,0xA0,0xE0,0xE0,0x20,0x00,0x00,0x00,0x00,0x00,0xC0,0xF0,0x3E,0x0F,0x03,0x00,0x00,0x00,0x00,0x10,0x1C,0x1F,0x17,0x10,0x10,0x10,0x10,0x18,0x06,0x00&#125;,/*\"Z\",58*/\n&#123;0x00,0x00,0x00,0x00,0x00,0xFC,0x04,0x04,0x04,0x04,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x40,0x40,0x40,0x40,0x40,0x00&#125;,/*\"[\",59*/\n&#123;0x00,0x00,0x10,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x1C,0x60,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x0C,0x70,0x80,0x00&#125;,/*\"\\\",60*/\n&#123;0x00,0x00,0x04,0x04,0x04,0x04,0x04,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x40,0x40,0x40,0x40,0x7F,0x00,0x00,0x00,0x00&#125;,/*\"]\",61*/\n&#123;0x00,0x00,0x00,0x10,0x08,0x0C,0x04,0x0C,0x08,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\"^\",62*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80&#125;,/*\"_\",63*/\n&#123;0x00,0x00,0x00,0x04,0x04,0x08,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\"`\",64*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x98,0xD8,0x44,0x64,0x24,0x24,0xFC,0xF8,0x00,0x00,0x00,0x0F,0x1F,0x18,0x10,0x10,0x10,0x08,0x1F,0x1F,0x10,0x18&#125;,/*\"a\",65*/\n&#123;0x00,0x20,0xE0,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x18,0x08,0x04,0x04,0x0C,0xF8,0xF0,0x00,0x00,0x00,0x1F,0x0F,0x18,0x10,0x10,0x10,0x18,0x0F,0x03,0x00&#125;,/*\"b\",66*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0xF8,0x18,0x04,0x04,0x04,0x3C,0x38,0x00,0x00,0x00,0x00,0x03,0x0F,0x0C,0x10,0x10,0x10,0x10,0x08,0x06,0x00,0x00&#125;,/*\"c\",67*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0xE0,0xF0,0x00,0x00,0x00,0xE0,0xF8,0x1C,0x04,0x04,0x04,0x08,0xFF,0xFF,0x00,0x00,0x00,0x03,0x0F,0x18,0x10,0x10,0x10,0x08,0x1F,0x0F,0x08,0x00&#125;,/*\"d\",68*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0xF8,0x48,0x44,0x44,0x44,0x4C,0x78,0x70,0x00,0x00,0x00,0x03,0x0F,0x0C,0x18,0x10,0x10,0x10,0x08,0x04,0x00&#125;,/*\"e\",69*/\n&#123;0x00,0x00,0x00,0x00,0x80,0xC0,0x60,0x20,0x20,0xE0,0xC0,0x00,0x00,0x04,0x04,0x04,0xFF,0xFF,0x04,0x04,0x04,0x04,0x00,0x00,0x00,0x00,0x10,0x10,0x1F,0x1F,0x10,0x10,0x10,0x00,0x00,0x00&#125;,/*\"f\",70*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0xF8,0x8C,0x04,0x04,0x8C,0xF8,0x74,0x04,0x0C,0x00,0x70,0x76,0xCF,0x8D,0x8D,0x8D,0x89,0xC8,0x78,0x70,0x00&#125;,/*\"g\",71*/\n&#123;0x00,0x20,0xE0,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x08,0x04,0x04,0x04,0xFC,0xF8,0x00,0x00,0x00,0x10,0x1F,0x1F,0x10,0x00,0x00,0x10,0x1F,0x1F,0x10,0x00&#125;,/*\"h\",72*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x60,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x04,0x04,0xFC,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x10,0x10,0x1F,0x1F,0x10,0x10,0x10,0x00,0x00&#125;,/*\"i\",73*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x04,0x04,0xFC,0xFC,0x00,0x00,0x00,0x00,0x00,0xC0,0xC0,0x80,0x80,0xC0,0x7F,0x3F,0x00,0x00,0x00&#125;,/*\"j\",74*/\n&#123;0x00,0x20,0xE0,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x80,0xC0,0xF4,0x1C,0x04,0x04,0x00,0x00,0x00,0x10,0x1F,0x1F,0x11,0x00,0x03,0x1F,0x1C,0x10,0x10,0x00&#125;,/*\"k\",75*/\n&#123;0x00,0x00,0x20,0x20,0x20,0xE0,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x10,0x10,0x1F,0x1F,0x10,0x10,0x10,0x00,0x00&#125;,/*\"l\",76*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0xFC,0xFC,0x08,0x04,0xFC,0xFC,0x08,0x04,0xFC,0xFC,0x00,0x10,0x1F,0x1F,0x10,0x00,0x1F,0x1F,0x10,0x00,0x1F,0x1F,0x10&#125;,/*\"m\",77*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0xFC,0xFC,0x08,0x08,0x04,0x04,0xFC,0xF8,0x00,0x00,0x00,0x10,0x1F,0x1F,0x10,0x00,0x00,0x10,0x1F,0x1F,0x10,0x00&#125;,/*\"n\",78*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0xF0,0x18,0x0C,0x04,0x04,0x0C,0x18,0xF0,0xE0,0x00,0x00,0x03,0x0F,0x0C,0x10,0x10,0x10,0x10,0x0C,0x0F,0x03,0x00&#125;,/*\"o\",79*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0xFC,0xFC,0x08,0x04,0x04,0x04,0x0C,0xF8,0xF0,0x00,0x00,0x80,0xFF,0xFF,0x88,0x90,0x10,0x10,0x1C,0x0F,0x03,0x00&#125;,/*\"p\",80*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0xF8,0x1C,0x04,0x04,0x04,0x08,0xF8,0xFC,0x00,0x00,0x00,0x03,0x0F,0x18,0x10,0x10,0x90,0x88,0xFF,0xFF,0x80,0x00&#125;,/*\"q\",81*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x04,0x04,0xFC,0xFC,0x10,0x08,0x04,0x04,0x0C,0x0C,0x00,0x10,0x10,0x10,0x1F,0x1F,0x10,0x10,0x10,0x00,0x00,0x00,0x00&#125;,/*\"r\",82*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x78,0xCC,0xC4,0x84,0x84,0x84,0x0C,0x1C,0x00,0x00,0x00,0x1E,0x18,0x10,0x10,0x10,0x11,0x19,0x0F,0x06,0x00&#125;,/*\"s\",83*/\n&#123;0x00,0x00,0x00,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x04,0x04,0xFF,0xFF,0x04,0x04,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0x1F,0x10,0x10,0x10,0x0C,0x00,0x00&#125;,/*\"t\",84*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0xFC,0xFE,0x00,0x00,0x00,0x04,0xFC,0xFE,0x00,0x00,0x00,0x00,0x0F,0x1F,0x18,0x10,0x10,0x08,0x1F,0x0F,0x08,0x00&#125;,/*\"u\",85*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x0C,0x3C,0xFC,0xC4,0x00,0x00,0xC4,0x3C,0x0C,0x04,0x00,0x00,0x00,0x00,0x01,0x0F,0x1E,0x0E,0x01,0x00,0x00,0x00&#125;,/*\"v\",86*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x3C,0xFC,0xC4,0x00,0xE4,0x7C,0xFC,0x84,0x80,0x7C,0x04,0x00,0x00,0x07,0x1F,0x07,0x00,0x00,0x07,0x1F,0x07,0x00,0x00&#125;,/*\"w\",87*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x04,0x1C,0x7C,0xE4,0xC0,0x34,0x1C,0x04,0x04,0x00,0x00,0x10,0x10,0x1C,0x16,0x01,0x13,0x1F,0x1C,0x18,0x10,0x00&#125;,/*\"x\",88*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x0C,0x3C,0xFC,0xC4,0x00,0xC4,0x3C,0x04,0x04,0x00,0x00,0x00,0xC0,0x80,0xC1,0x37,0x0E,0x01,0x00,0x00,0x00,0x00&#125;,/*\"y\",89*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1C,0x04,0x04,0xC4,0xF4,0x7C,0x1C,0x04,0x00,0x00,0x00,0x00,0x10,0x1C,0x1F,0x17,0x11,0x10,0x10,0x18,0x0E,0x00&#125;,/*\"z\",90*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0x0C,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x28,0xEF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0x60,0x40,0x00,0x00&#125;,/*\"&#123;\",91*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00&#125;,/*\"|\",92*/\n&#123;0x00,0x00,0x04,0x0C,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xEF,0x28,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x60,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\"&#125;\",93*/\n&#123;0x00,0x18,0x06,0x02,0x02,0x04,0x08,0x10,0x20,0x20,0x30,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\"~\",94*/\n&#125;;\n\n写字节   硬件SPI\n\n\n\n\n\n\n\n\n\nstatic void hal_Oled_WR_Byte(unsigned char dat,unsigned char cmd)\n&#123;\t\n\tunsigned char i;\t\t\n\tunsigned char retry=0;\t\t\n\tif(cmd)\n\t&#123;\n\t\tOLED_DC_Set();\n\t&#125;else \n\t&#123;\n\t\tOLED_DC_Clr();\t\t  \n\t&#125;\n\tSPI1->DR=dat;\t \t  //发送一个byte  \n\tretry=0;\n\twhile((SPI1->SR &amp; SPI_I2S_FLAG_BSY) != RESET)\n\t&#123;\n\t\tretry++;\n\t\tif(retry>200)\n\t\t\treturn;\n\t&#125;  \t\t\t     \t\t  \n\tOLED_DC_Set();   \t  \n&#125;\n\n写字节   软件模拟SPI\n\n\n\n\n\n\n\n\n我们这个是3线spi就限制了不可以软件模拟，软件模拟需要4线，还有一个片选cs，但是软件模拟得知道咋写的\n//写字节  软件模拟SPI\nvoid OLED_WR_Byte(u8 dat,u8 cmd)\n&#123;\t\n\tu8 i;\t\t\t  \n\tif(cmd)\n\t  OLED_DC_Set();\n\telse \n\t  OLED_DC_Clr();\t\t  \n\t//我们3线没有这条线\n    OLED_CS_Clr();\n\tfor(i=0;i&lt;8;i++)\n\t&#123;\t\t\t  \n\t\tOLED_SCL_Clr();\n\t\tif(dat&amp;0x80)\n\t\t   OLED_SDA_Set();\n\t\telse \n\t\t   OLED_SDA_Clr();\n\t\tOLED_SCL_Set();\n\t\tdat&lt;&lt;=1;   \n\t&#125;\t\t\n    //没有这条\n\tOLED_CS_Set();\n\tOLED_DC_Set();   \t  \n&#125;\n\n\n虫子你之后找个机会把lvgl给移植过来，那个UI比这个帅多了串行FLASH文件系统FatFs使用SPI FLASH直接存储数据\n\n\n\n\n\n\n\n\n当需要记录字符“STM32 SPI FLASH”时。可以把这些文字转化成ASCII码，存储在数组中，然后调用SPI_FLASH_BufferWrite函数，把数组内容写入到SPI Flash芯片的指定地址上，在需要的时候从该地址把数据读取出来，再对读出来的数据以ASCII码的格式进行解读\n\n\n难以记录有效数据的位置\n难以确定存储介质的剩余空间\n不明确应以何种格式来解读数据\n\n上面那样存储就有3个致命，所以我们刚开始应该把文件信息啥的先存储在开头\n\nWindows上的文件系统\n\n\n\n\n\n\n\n\n文件系统，就是对数据进行管理的方式。使用文件系统可有效地管理存储介质\n文件系统在计算机中的表现形式\n\n磁盘的物理结构\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n使用文件系统时，它为了存储和管理数据，在存储介质建立了一些组织结构，这些结构包括操作系统引导区、目录和文件\n常见的windows下的文件系统格式包括FAT32、NTFS、exFAT。在使用文件系统前，要先对存储介质进行格式化。格式化时会在存储介质上新建一个文件分配表和目录。这样，文件系统就可以记录数据存放的物理地址，剩余空间\n磁盘分区表\n\n\n\n\n\n\n\n\n\nWindows操作系统为了便于用户对磁盘的管理。加入了磁盘分区的概念，即将一块磁盘逻辑划分为几块，它会把磁盘的分区信息记录到硬盘分区表中\n在硬盘分区表中，描述了各个逻辑分区的属性，如分区开始和结束位置所在的物理地址(柱面号、扇区号)，空间大小等信息\n文件系统 的结构与特性\n\n\n\n\n\n\n\n\n使用文件系统时，数据都以文件的形式存储。写入新文件时，先在目录中创建一个文件索引，它指示了文件存放的物理地址，再把数据存储到该地址中。当需要读取数据时，可以从目录中找到该文件的索引，进而在相应的地址中读取出数据。具体还涉及到逻辑地址、簇大小、不连续存储等一系列辅助结构或处理过程\n文件系统的存在使存取数据时，不再是简单地向某物理地址直接读写，而是要遵循它的读写格式。如经过逻辑转换，一个完整的文件可能被分开成多段存储到不连续的物理地址，使用目录或链表的方式来获知下一段的位置。\n文件系统的空间示意图\n\n\n\n\n\n\n\n\n\n存储了A.TXT，B.TXT，C.TXT文件\n\n记录了文件的开始簇位置、大小等信息\n\nC语言中的文件操作\n\n\n\n\n\n\n\n\n\n文件的打开操作 fopen 打开一个文件文件的关闭操作 fclose 关闭一个文件文件的读写操作 fgetc 从文件中读取一个字符                            fputc 写一个字符到文件中去                            fgets 从文件中读取一个字符串                            fputs 写一个字符串到文件中去                            fprintf 往文件中写格式化数据                            fscanf 格式化读取文件中数据                            fread 以二进制形式读取文件中的数据                            fwrite 以二进制形式写数据到文件中去                            getw 以二进制形式读取一个整数                            putw 以二进制形式存贮一个整数文件状态检查函数 feof 文件结束                            ferror 文件读&#x2F;写出错                            clearerr 清除文件错误标志                            ftell 了解文件指针的当前位置文件定位函数    rewind 反绕                            fseek 随机定位\nFATFS 文件系统简介\n\n\n\n\n\n\n\n\nFatFs是面向小型嵌入式系统的一种通用的FAT文件系统。它完全是由AISI C语言编写并且完全独立于底层的I&#x2F;O介质。因此它可以很容易地不加修改地移植到其他的处理器当中，如8051、PIC、AVR、SH、Z80、H8、ARM等。FatFs支持FAT12、FAT16、FAT32等格式\n利用前面写好的SPI Flash芯片驱动，把FatFs文件系统代码移植到工程之中，就可以利用文件系统的各种函数，对SPI Flash芯片以“文件”格式进行读写操作了\n二级标题三级标题四级标题五级标题六级标题","slug":"wifi主机/wifi主机第四部分  精细化发育","date":"2020-08-15T10:49:36.000Z","categories_index":"单片机","tags_index":"STM32,主机","author_index":"虫子"}]