[{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"调用门调用门的作用调用门可以用来提权，通过提权可以实现访问高地址空间等RING0（内核）层才能进行的操作\n\n调用门和长调用关系回顾先前的笔记可知：\n长调用CALL FAR CS:EIP指令要调用的地址是由CS段选择子查GDT得到的调用门 段描述符得来的，后面的EIP不发挥作用\n\n调用门执行流程\n根据CS的值 查GDT，找到对应的段描述符 这个描述符是一个调用门\n在调用门描述符中存储另一个代码段的选择子\n选择子指向的段 段.Base + 偏移地址 就是真正要执行的地址\n\n\n调用门描述符对比段描述符\n\n调用门描述符结构\n\n当一个段描述符是一个调用门描述符时，有以下特征：\n\nS位为0，表示该段描述符为系统段描述符（调用门描述符属于系统段描述符）\nType域为1100，表示该段描述符为32位调用门\n低16位到31位由原本的基地址变为存储一个段选择子，该段选择子才和代码真正要调用的地址相关\n真正要调用的地址 &#x3D; 段选择子所指向的段.Base + 32位的段中偏移 （段中偏移分为两部分：高位31-16位和低位15-0位）\n段.Base默认为0，故真正要调用的地址 &#x3D; 32位的段中偏移\n\n\n给出段描述符和调用门描述符各部分的对比（上半部分为段描述符，下半部分为调用门描述符）：\n\n\n\n数据位\n31-24\n23\n22\n21\n20\n19-16\n15\n14-13\n12\n11-8\n7-0\n\n\n\n\n含义\nBase\nG\nD&#x2F;B\n0\nAVL\nSeg.Limit\nP\nDPL\nS\nType\nBase\n\n\n\n解释\n基地址\n粒度\n默认操作大小\n固定为0\n用于系统软件使用\n段大小限制\n有效位\n特权等级\n描述符类型\n段类型\n基地址\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n数据位\n31-16\n\n\n\n\n\n15\n14-13\n12\n11-8\n7-5\n4-0\n\n\n含义\noffset\n\n\n\n\n\nP\nDPL\nS\nType\n无\nparam.count\n\n\n解释\n段中偏移\n\n\n\n\n\n有效位\n特权等级\n值为0\n值为1100\n值为000\n参数计数\n\n\n\n\n\n\n数据位\n31-16\n15-0\n\n\n\n含义\nBase Adress\nSegment Limit\n\n\n解释\n基地址\n段大小限制\n\n\n\n\n\n\n\n数据位\n31-16\n15-0\n\n\n含义\nselector\noffset\n\n\n解释\n段选择子\n段中偏移\n\n\n\n构造无参调用门描述符了解了调用门描述符的结构后，尝试自己构造一个无参的调用门描述符，如下：\n\n\n\n数据位\n31-16\n\n\n\n\n\n15\n14-13\n12\n11-8\n7-5\n4-0\n\n\n\n含义\noffset\n\n\n\n\n\nP\nDPL\nS\nType\n无\nparam\n\n\n解释\n段中偏移\n\n\n\n\n\n有效位\n特权等级\n值为0\n值为1100\n值为000\n参数\n\n\n值（二进制）\n0\n\n\n\n\n\n1\n11\n0\n1100\n000\n0000\n\n\n\n\n\n数据位\n31-16\n15-0\n\n\n\n含义\nselector\noffset\n\n\n解释\n段选择子\n段中偏移\n\n\n值（十六进制）\n0x0008\n0\n\n\n得到调用门描述符为：0000EC00&#96;00080000\n段中偏移暂时不明确要调用的代码段，先置0\n\n示例代码接下来给出一段演示代码：\n 复制代码 隐藏代码#include &lt;Windows.h&gt;\n#include &lt;stdio.h&gt;\n\n __declspec(naked) void callGate()&#123;\n         _asm&#123;\n                 int 3                                &#x2F;&#x2F;软中断\n                 retf                                &#x2F;&#x2F;注意这里长调用对应长返回\n         &#125;\n &#125;\n\nint main()&#123;\n\n        char buff[6];\n        &#x2F;&#x2F;*(DWORD*)&amp;buff[0]&#x3D; 0x12345678;        &#x2F;&#x2F;低地址32位为0x12345678，EIP已废弃，故随便填即可\n        &#x2F;&#x2F;*(DWORD*)&amp;buff[4]&#x3D;0x48;                        &#x2F;&#x2F;高地址16位为0x48，段选择子\n\n        &#x2F;&#x2F;也可以换作这种写法\n        _asm&#123;\n                mov dword ptr ds:[buff],0x12345678        &#x2F;&#x2F;低32位赋值废弃EIP\n                lea eax,dword ptr ds:[buff]                        &#x2F;&#x2F;将buff地址给EAX\n                add eax,4                                                        &#x2F;&#x2F;地址+4，即得到高地址\n                mov word ptr ds:[eax],0x48                        &#x2F;&#x2F;高16位赋值段选择子selector\n        &#125;\n\n        &#x2F;&#x2F;使用 调用门\n        _asm&#123;\n                call fword ptr ds:[buff]                        &#x2F;&#x2F;fword 数据宽度为6字节\n        &#125;\n        return 0;\n&#125;\n\n代码说明代码十分简单，主要分为两部分：\n\ncallGate：调用门真正要调用的函数，先软中断，然后长返回\nmain：先构造一个CS:EIP，这里为0x48:0x12345678，然后使用调用门\n\n\n关于构造CS:EIP，可以观察到赋值后buff在内存中的存储情况：\n\n可以看到CS:EIP在内存中由高地址到低地址存储，为0x004812345678\n\n将门描述符写入GDT在代码中，CS的也就是段选择子的值为0x48，该选择子指向的GDT的地址为要写入的地址\n关于Selector和GDT地址的对应关系在保护模式笔记三 段描述符和段选择子中已经说明过了，这里不再赘述\n\n确定门描述符在写入GDT前，还需要确定要写入的值，前面已经构造好了的门描述符为：0x0000EC00&#96;00080000\n但其段中偏移还未确定，于是使用VC++ 6.0查看要调用的代码的地址：\n进入debug模式，中断后，选中callGate函数，然后右键→Go to Disassembly（查看反汇编）\n\n\n\n可以得到要调用的函数的地址为0x00401020\n\n将得到的要调用的函数地址填入门描述符中对应的offset得到：\n\n原：0000EC00&#96;00080000\n现：0040EC00&#96;00081020\n\n\n于是得到确定的门描述符为0040EC00&#96;00081020\n\n写入门描述符确定完门描述符和要写入的地址后，就可以将其写入GDT了，操作如下：\n指令如下：\n 复制代码 隐藏代码r gdtr                                查看gdtr\ndq 0x8003f000                以qword查看地址，这里的地址为上面得到的gdtr地址\neq 8003f048 0040EC00&#96;00081020                写入门描述符\ndq 0x8003f000                查看是否写入成功\n\n\n过程图如下：\n\n\n执行代码执行代码结果如下：\nWindbg获取到了代码中的int 3断点\n\n可以看到此时中断的地址正是门描述符中的偏移地址（要调用的地址 &#x3D; 段.Base+Offset，Base默认为0，故要调用的地址就直接等于门描述符中的offset）\n\n原本的Ring3（应用）层的int 3断点不会被Windbg所捕获，但这里通过门描述符提权后变为了Ring0（内核层）权限，故会引起Windbg的捕获\n可以查看此时的寄存器情况：\n 复制代码 隐藏代码\nr\n\n\n此时的CS正是前面构造的门描述符中的selector（选择子）\n\n接下来继续单步执行\n 复制代码 隐藏代码\nt\n\n\n可以看到int 3的下一行代码位retf，也就是callGate函数里的代码中的下一行，由此可以确定调用成功\n\n对比执行前后寄存器前面只提到了CS段寄存器的变化，现在来总览对比执行前后寄存器的变化：\n执行前寄存器情况在使用调用门的汇编语句处下断点，断下后得到：\n\n\n得到此时的寄存器情况：\n\n\n\n寄存器\n值\n\n\n\nESP\n12FF2C\n\n\nEBP\n12FF80\n\n\nCS\n1B\n\n\nDS\n23\n\n\nES\n23\n\n\nSS\n23\n\n\nFS\n3B\n\n\nGS\n0\n\n\n\n执行后寄存器情况\n\n\n得到此时的寄存器情况：\n\n\n\n寄存器\n值\n\n\n\nESP\nB1026DD0\n\n\nEBP\n12FF80\n\n\nCS\n08\n\n\nDS\n23\n\n\nES\n23\n\n\nSS\n10\n\n\nFS\n30\n\n\nGS\n0\n\n\n\n变化对比\n\n\n寄存器\n执行前值\n执行后值\n是否变化\n\n\n\nESP\n12FF2C\nB1026DD0\n√\n\n\nEBP\n12FF80\n12FF80\n×\n\n\nCS\n1B\n08\n√\n\n\nDS\n23\n23\n×\n\n\nES\n23\n23\n×\n\n\nSS\n23\n10\n√\n\n\nFS\n3B\n30\n√\n\n\nGS\n0\n0\n×\n\n\n可以得出变化的寄存器有：ESP、CS、SS、FS\n通过调用门提权后，前后寄存器的变化涉及到TSS，这里先记录下变化，具体细节留作之后\n\n构造有参调用门描述符示例代码 复制代码 隐藏代码#include &lt;Windows.h&gt;\n#include &lt;stdio.h&gt;\n\nint a,b,c;\n\n __declspec(naked) void callGate()&#123;\n         _asm&#123;\n                pushad                                                        &#x2F;&#x2F;将所有32位通用寄存器压入堆栈\n        pushfd                                                        &#x2F;&#x2F;将32位标志寄存器EFLFAGS压入堆栈\n        &#x2F;&#x2F;关于为何是通过ESP+XXX寻址详见后续的堆栈情况说明\n                mov eax,[esp+0x24+0x8+0x8]                &#x2F;&#x2F;从堆栈中取出第一个参数\n                mov dword ptr ds:[a],eax                &#x2F;&#x2F;将取出的参数赋值给全局变量a\n                mov eax,[esp+0x24+0x8+0x4]                &#x2F;&#x2F;从堆栈中取出第二个参数\n                mov dword ptr ds:[b],eax                &#x2F;&#x2F;将取出的参数赋值给全局变量b\n        mov eax,[esp+0x24+8+0]                        &#x2F;&#x2F;从堆栈中取出第三个参数\n                mov dword ptr ds:[c],eax                &#x2F;&#x2F;将取出的参数赋值给全局变量c\n                popfd                                                        &#x2F;&#x2F;将所有32位通用寄存器出栈\n                popad                                                        &#x2F;&#x2F;将所有32位标志寄存器EFLFAGS出栈\n                retf 0xC&#x2F;&#x2F;注意这里长调用对应长返回，堆栈平衡 0xC&#x3D;12&#x3D;3*4&#x3D;参数个数*参数的数据宽度（单位字节）\n         &#125;\n &#125;\n\nint main()&#123;\n\n        char buff[6];\n        &#x2F;&#x2F;*(DWORD*)&amp;buff[0]&#x3D; 0x12345678;        &#x2F;&#x2F;低地址32位为0x12345678，EIP已废弃，故随便填即可\n        &#x2F;&#x2F;*(DWORD*)&amp;buff[4]&#x3D;0x48;                        &#x2F;&#x2F;高地址16位为0x48，段选择子\n\n        &#x2F;&#x2F;也可以换作这种写法\n        _asm&#123;\n                mov dword ptr ds:[buff],0x12345678        &#x2F;&#x2F;低32位赋值废弃EIP\n                lea eax,dword ptr ds:[buff]                        &#x2F;&#x2F;将buff地址给EAX\n                add eax,4                                                        &#x2F;&#x2F;地址+4，即得到高地址\n                mov word ptr ds:[eax],0x48                        &#x2F;&#x2F;高16位赋值段选择子selector\n        &#125;\n\n        &#x2F;&#x2F;使用 调用门\n        _asm&#123;\n                push 1\n                push 2\n                push 3\n                call fword ptr ds:[buff]                        &#x2F;&#x2F;fword 数据宽度为6字节\n        &#125;\n        printf(&quot;%X\\t%X\\t%X\\n&quot;,a,b,c);\n        return 0;\n&#125;\n\n\n代码说明与构造无参调用门描述符相比，主要变化为：\n\n在使用调用门前压入了三个参数：1、2、3\n调用代码作用为：①保护现场（压入所有通用寄存器和标志寄存器）；②从堆栈中取出对应的参数；③将取出的参数赋值给对应的全局变量\n调用代码最后要平衡堆栈，ret 0xC      0xC&#x3D;12&#x3D;34&#x3D;参数个数参数的数据宽度（单位字节）\n在调用结束后，输出调用后被赋值的全局变量，验证参数是否成功传递\n\n\n堆栈情况说明堆栈调用情况按执行流程顺序依次说明：\n执行前(压入参数后)\n记录下此时的堆栈情况：\n\n\n\n地址\n相对栈顶地址\n值\n说明\n\n\n\n0012FF20\nESP\n3\n压入的第三个参数\n\n\n0012FF24\nESP+4\n2\n压入的第二个参数\n\n\n0012FF28\nESP+8\n1\n压入的第一个参数\n\n\n\n切换到调用代码后\n记录下此时的堆栈情况：\n\n\n\n地址\n相对栈顶地址\n值\n说明\n\n\n\nB9CAFDC4\nESP\n0040D4E8\n执行后要返回的地址\n\n\nB9CAFDC8\nESP+0x4\n1B\n执行后要恢复的段选择子:CS\n\n\nB9CAFDCC\nESP+0x8\n3\n压入的第三个参数\n\n\nB9CAFDD0\nESP+0xC\n2\n压入的第二个参数\n\n\nB9CAFDD4\nESP+0x10\n1\n压入的第一个参数\n\n\nB9CAFDD8\nESP+0x14\n0012FF20\n执行后要恢复的堆栈寄存器:ESP\n\n\nB9CAFDDC\nESP+0x18\n23\n执行后要恢复的段选择子:SS\n\n\n\n保存通用寄存器组后\n记录下此时的堆栈情况：\n\n\n\n地址\n相对栈顶地址\n值\n说明\n\n\n\nB9CAFDA4～B9CAFDC0\nESP～ESP+0x1C\n略\n通用寄存器组\n\n\nB9CAFDC4\nESP+0x20\n0040D4E8\n执行后要返回的地址\n\n\nB9CAFDC8\nESP+0x20+0x4\n1B\n执行后要恢复的段选择子:CS\n\n\nB9CAFDCC\nESP+0x20+0x8\n3\n压入的第三个参数\n\n\nB9CAFDD0\nESP+0x20+0xC\n2\n压入的第二个参数\n\n\nB9CAFDD4\nESP+0x20+0x10\n1\n压入的第一个参数\n\n\nB9CAFDD8\nESP+0x20+0x14\n0012FF20\n执行后要恢复的堆栈寄存器:ESP\n\n\nB9CAFDDC\nESP+0x20+0x18\n23\n执行后要恢复的段选择子:SS\n\n\n\n保存标志寄存器后\n记录下此时的堆栈情况：\n\n\n\n地址\n相对栈顶地址\n值\n说明\n\n\n\nB9CAFDA0\nESP\n0x202\n标志寄存器\n\n\nB9CAFDA4～B9CAFDC0\nESP+0x4～ESP+0x4+0x1C\n略\n通用寄存器组\n\n\nB9CAFDC4\nESP+0x4+0x20\n0040D4E8\n执行后要返回的地址\n\n\nB9CAFDC8\nESP+0x4+0x20+0x4\n1B\n执行后要恢复的段选择子:CS\n\n\nB9CAFDCC\nESP+0x4+0x20+0x8\n3\n压入的第三个参数\n\n\nB9CAFDD0\nESP+0x4+0x20+0xC\n2\n压入的第二个参数\n\n\nB9CAFDD4\nESP+0x4+0x20+0x10\n1\n压入的第一个参数\n\n\nB9CAFDD8\nESP+0x4+0x20+0x14\n0012FF20\n执行后要恢复的堆栈寄存器:ESP\n\n\nB9CAFDDC\nESP+0x4+0x20+0x18\n23\n执行后要恢复的段选择子:SS\n\n\n\n将门描述符写入GDT确定门描述符先确定段中偏移：进入debug模式，中断后，选中callGate函数，然后右键→Go to Disassembly（查看反汇编）\n\n\n\n可以得到要调用的函数的地址为0x0040D480\n\n将得到的要调用的函数地址填入门描述符中对应的offset得到：\n\n原：0000EC00&#96;00080000\n现：0040EC00&#96;0008D480\n\n因为此次调用门描述符需要传递三个参数，故修改为：\n0040EC03&#96;0008D480\nPS：修改了门描述符结构中的param.count，如不熟悉可回顾上面的 调用门描述符结构\n\n于是得到确定的门描述符为0040EC03&#96;0008D480\n\n写入门描述符确定完门描述符和要写入的地址后，就可以将其写入GDT了，操作如下：\n指令如下：\n 复制代码 隐藏代码r gdtr                                查看gdtr\ndq 8003f000                以qword查看地址，这里的地址为上面得到的gdtr地址\neq 8003f048 0040EC03&#96;0008D480                写入门描述符\ndq 8003f000                查看是否写入成功\n\n\n过程图如下：\n\n\n执行代码执行代码结果如下：\n\n代码执行后，能够正确地输出三个参数，构造有参调用门描述符成功\n\n总结\n当通过门，权限不变的时候，只会PUSH两个值：①CS（新的CS的值由调用门决定） ；②返回地址\n当通过门，权限改变的时候，会PUSH四个值：①SS；② ESP；③ CS ；④ 返回地址  （新的CS的值由调用门决定 新的SS和ESP由TSS提供）\n通过门调用时，要执行代码的地址由调用门中的选择子决定；使用RETF返回时，由堆栈中压入的返回地址决定\n\n\n关于TSS的内容留作之后的笔记(*￣3￣)╭PS：写得比较匆忙，可能会有谬误之处，欢迎指出\n","slug":"调用门提权（无参+有参）","date":"2022-12-14T07:19:32.629Z","categories_index":"","tags_index":"","author_index":"虫子"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"段权限检查CPU权限分级在补充段权限检查之前，要了解CPU的权限分级\n\n\n处理器的段保护机制定义了RING0,RING1,RING2,RING3一共4个特权级别\n大多数现代操作系统将0级用于内核&#x2F;可执行程序，将3级用于应用程序\n可用于级别n的任何资源也可用于级别0到n，因此特权级别是环\n当特权较低的进程尝试访问特权较高的进程时，将向操作系统报告常规保护错误异常\n8086中的实模式程序在级别0（最高特权级别）上执行，而8086中的虚拟模式在级别3执行所有程序\n多数现代x86内核仅使用两个特权级别，即RING0和RING3\n\n\n\n\n\n\nRING0\nRING1\nRING2\nRING3\n\n\n\n通常用途\n内核\n特权代码、特权数据、特权栈\n特权代码、特权数据、特权栈\n应用程序\n\n\n级别\n最高\n第二高\n第三高\n最低\n\n\n对应层\n内核层（内核态）\n\n\n应用层（用户态）\n\n\n\n内核层在内核模式下，CPU可以执行其体系结构允许的任何操作。可以执行任何指令，启动任何I &#x2F; O操作，访问任何内存区域，使用特权指令，控制中断、修改页表、访问设备等等\n应用层硬件会对CPU操作施加某些限制。通常，某些指令是不允许的（尤其是那些指令（包括I &#x2F; O操作）可能会改变机器的全局状态），某些内存区域无法访问等。CPU的用户模式功能通常是这些指令的子集可以在内核模式下使用，但是在某些情况下，例如非本机体系结构的硬件仿真，它们可能与标准内核模式下的可用软件有显着差异\n\n应用层切换内核层应用程序的代码运行在最低运行级别上ring3上，不能做受限操作\n如果要做受限操作，比如要访问磁盘，写文件，那就要通过执行系统调用（函数），执行系统调用的时候，CPU的运行级别会发生从ring3到ring0的切换，并跳转到系统调用对应的内核代码位置执行，这样内核就为你完成了设备访问，完成之后再从ring0返回ring3。这个过程也称作用户态和内核态的切换\n\nCPU权限分级的作用RING设计的初衷是将系统权限与程序分离出来，使之能够让OS更好的管理当前系统资源，也使得系统更加稳定\n举个很常见的例子：\n普通的应用程序崩溃一般是程序未响应或者停止运行，并不会影响系统的正常运行\n但当驱动程序出现问题后，动辄 BSOD（蓝屏死机）\n\n判断程序特权级别了解了CPU的权限分级后，再来了解 如何查看程序处于几环\n这涉及到了CPL(Current Privilege Level) ：当前特权级别\nCPL是段寄存器CS和SS的段选择子的后两位\n在保护模式笔记三 段描述符和段选择子中已经说明了段选择子的结构\n\n\n\n\nIndex\nTI\nRPL\n\n\n\n含义\n索引\n表指示器\n请求特权等级\n\n\n全称\nIndex\nTable Indicator\nRequested Privilege Level\n\n\n数据宽度\n13位\n1位\n2位\n\n\n对比可知，当段寄存器为CS和SS时，其段选择子的RPL就是CPL\n\n通过OD附加应用程序后查看其段寄存器：\n\n\n\n\n\n段寄存器\n段选择子(Selector)\n二进制段选择子\n二进制RPL\n十进制RPL\n\n\n\nES\n23\n0010 0011\n11\n3\n\n\nCS\n1B\n0001 1011\n11（CPL）\n3（CPL）\n\n\nSS\n23\n0010 0011\n11（CPL）\n3（CPL）\n\n\nDS\n23\n0010 0011\n11\n3\n\n\nFS\n3B\n0011 1011\n11\n3\n\n\n根据CS和SS的段选择子可以得到CPL为3，印证了应用程序的CPU权限分级为RING3\n\nEPL(有效特权级别)上面提到了CPL（当前特权级别）和RPL（请求特权级别）\n所谓的有效特权级别EPL(Effective Privilege Level)，顾名思义就是最终的确定可否执行的特权\nEPL &#x3D; max(RPL,CPL)\n即 EPL 等于 RPL和CPL的最大值，EPL为RPL和CPL中较低的权限\n\nDPL(描述符特权级别)关于DPL，在保护模式笔记四 段描述符结构中已经略微说明了，现在展开细说\nDPL的作用DPL存储在段描述符中，规定了访问该段所需要的特权级别是什么；即 如果想要加载某个段描述符，就必须具备对应的特权级别\nDPL权限检查当加载一个段描述符时，首先CPU要判断其P位（有效位），如果该段描述符有效，则继续进行DPL权限检查\n所谓的DPL权限检查 就是 判断 DPL是否满足：EPL&#x3D;max(RPL,CPL)&lt;&#x3D;DPL是否成立\n只有当EPL&lt;&#x3D;DPL时，权限检查才通过，段描述符才能够被加载到段寄存器中\n\n\n\nRPL\nCPL\nEPL\nDPL\n权限检查是否通过\n\n\n\n0\n0\n0\n0\n√\n\n\n0\n0\n0\n3\n√\n\n\n0\n3\n3\n0\n×\n\n\n0\n3\n3\n3\n√\n\n\n3\n0\n3\n0\n×\n\n\n3\n0\n3\n3\n√\n\n\n3\n3\n3\n0\n×\n\n\n3\n3\n3\n3\n√\n\n\n\n总结\n\n\n\nRPL\nCPL\nEPL\nDPL\n\n\n\n含义\n请求特权级别\n当前特权级别\n有效特权级别\n描述符特权级别\n\n\n说明\n用什么权限去访问一个段\nCPU当权的权限级别\nmax(RPL,CPL)\n访问该段所需要的特权级别\n\n\n","slug":"段权限检查","date":"2022-12-14T07:19:32.621Z","categories_index":"","tags_index":"","author_index":"虫子"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"段描述符引出问题首先要解决的就是上个笔记遗留下来的问题：\n 复制代码 隐藏代码mov bx,ds                &#x2F;&#x2F;将段寄存器ds的Selector部分保存到bx（ecx的低16位）\nmov ax,cs                &#x2F;&#x2F;将段寄存器cs的Selector部分保存到ax（eax的低16位）\nmov ds,ax                &#x2F;&#x2F;将先前读出来的段寄存器去写ds这个段寄存器，也就是用cs段寄存器覆盖ds段寄存器\n\n写寄存器是对整个96位的段寄存器进行修改，但是这里只给出了16位的段选择子Selector，剩下的80位呢\n\n在回答问题之前，还需要了解两个结构：GDT（全局描述符表）和 LDT（局部描述符表）\n为什么要了解这两张表？\n因为当执行类似前面对段寄存器进行修改的指令：MOV DS,AX时，CPU会先查表，根据AX的值（段选择子）来决定查找GDT还是LDT\n但在Windows中LDT并没有被使用，于是AX的值(段选择子)是用来决定查询表中的哪个位置\n\nGDT什么是GDTGDT全称：Global Descriptor Table，为全局描述符表，表中存储的数据项为段描述符\n\nGDT的数量一个处理器对应一个GDT\n\n定位GDT大致了解了GDT是一张表，接下来则要定位到这张表，查看其内容\n想要定位GDT表的位置，可以通过gdtr寄存器来定位\ngdtr寄存器存储了GDT表的起始位置和GDT表的大小\n\n通过windbg定位GDT通过在windbg中输入下列指令查看有关GDT的信息：\n 复制代码 隐藏代码r gdtr      &#x2F;&#x2F;读取gdt表的起始位置\nr gdtl      &#x2F;&#x2F;读取gdt表的大小\n\n\n\n\n得到了：\n\n\n\n\nGDT表的起始位置\nGDT表的大小\n\n\n\n值\n0x8003f000\n0x3ff\n\n\n数据宽度\nDWORD(4字节)\nWORD(2字节)\n\n\n\n得到了GDT表的起始位置后，就可以查看GDT表的内容了：\n 复制代码 隐藏代码\ndq 0x8003f000\n\n\n\n段描述符知道了查询的表为GDT后，再说说GDT表存储的数据项：段描述符\n\n什么是段描述符段描述符顾名思义就是用来描述段的信息的，每个段对应一个段描述符\n\n段描述符的数据宽度每个段描述符的数据宽度为：64位&#x3D;8字节（QWORD）\n\n定位段描述符通过段选择子可以定位到对应的段描述符\n如何定位，则要先了解段选择子的结构\n\n段选择子什么是段选择子段选择子顾名思义就是用来选择段的，通过段选择子可以定位到对应的段描述符\n\n段选择子的结构\n\n\n\n\n\nIndex\nTI\nRPL\n\n\n\n含义\n索引\n表指示器\n请求特权等级\n\n\n全称\nIndex\nTable Indicator\nRequested Privilege Level\n\n\n数据宽度\n13位\n1位\n2位\n\n\n\nIndex索引，真正用来索引段描述符的数据\n\nTI表指示器，用来确定选择GDT（全局描述符表）还是LDT（局部描述符表）\n\n\n\n\nTI&#x3D;&#x3D;0\nTI&#x3D;&#x3D;1\n\n\n\n选择的表\nGDT\nLDT\n\n\n在Windows上并不使用LDT表，故TI恒等于0\n\nRPL请求的特权等级，会和请求的段描述符的特权等级进行比较，留作后续补充说明\n\n根据段选择子定位段描述符了解了段选择子的结构后，就可以通过段选择子来定位段描述符了\n例子：以段选择子 &#x3D; 0x001B为例\n首先将段选择子转换为二进制 ： 0000 0000 0001 1011\n将其按段选择子的结构填入：\n\n\n\n\nIndex\nTI\nRPL\n\n\n\n二进制值\n0000 0000 0001 1\n0\n11\n\n\n十进制值\n3\n0\n3\n\n\n含义\n索引为3\n查询GDT表\n请求特权等级为3\n\n\n得到的索引为3\n拿到索引之后就可以定位对应的段描述符了\n对应的段描述符地址 &#x3D; GDT表首地址 + 索引× 段描述符长度 &#x3D; GDT表首地址 + 索引 × 8（注意这里的单位为字节，64位&#x3D;8字节）\n所以：对应的段描述符地址 &#x3D; 0x8003f000 + 3×8&#x3D; 0x8003f000 + 24 &#x3D; 0x8003f000 + 0x18 &#x3D; 0x8003f018\n\n\n加载段描述符至段寄存器除了MOV指令，还可以使用LES、LSS、LDS、LFS、LGS指令修改寄存器.\nCS不能通过上述的指令进行修改，CS为代码段，CS的改变会导致EIP的改变，要改CS，必须要保证CS与EIP一起改，在后续的笔记会提到\n\n下面以lds为例子，观察指令执行前后寄存器的变化\n 复制代码 隐藏代码#include &lt;stdio.h&gt;\n#include &lt;windows.h&gt;\n\nchar buffer[6]&#x3D;&#123;0x44,0x33,0x22,0x11,0x1B,0x00&#125;;\n\nint main()&#123;\n\n    _asm&#123;\n        push ds\n        lds eax,fword ptr ds:[buffer]   &#x2F;&#x2F;fword为6字节\n        pop ds\n\n    &#125;\n        return 0;\n&#125;\n\n\n下断点观察\n\n执行前\n\n执行后\n\n对比执行前后\n\n\n\nEAX\nDS\n\n\n\n执行前\n0xCCCCCCCC\n0x23\n\n\n执行后\n0x11223344\n0x1B\n\n\n\n得出指令功能LDS指令格式为：LDS OPRD1,OPRD2\nOPRD1用来接收OPRD2的低(OPRD-2)字节\nOPRD2的高2字节为段选择子，通过段选择子修改DS\n其它指令：LES、LSS、LFS、LGS也是一样的格式，只不过修改的段寄存器不同罢了\n\n内存寻址关系一览图下面给出内存寻址的流程中，GDT、段描述符、段选择子的关系图：\n\n\n以MOV EAX,DWORD PTR DS:[0x123456]为例\n根据DS获得Segment Selector（段选择子）：0x23（在 保护模式笔记二 段寄存器中获得的，不同机器可能不同）\n根据地址获得Offset(偏移)：0x123456\n然后通过段选择子查询GDT（全局描述符表）得到对应的Segment Descriptor（段描述符）\n通过段描述符可以得到Base（基地址）&#x3D; 0 （DS段寄存器的Base为0）\n最终要访问的内存地址为：Base+Offset &#x3D; 0+0x123456&#x3D;0x123456（期间也会根据段描述符进行一系列校验，这里暂且不提）\n\n说明该篇笔记主要介绍了如何通过段选择子定位到对应的段描述符并补充了段选择子的结构和修改段寄存器的指令\n但关于段描述符的结构还没有深入介绍\n前面引出的问题也尚未完全解决，通过前面的学习得知段寄存器剩下的80位是通过段描述符来填充的\n但是段描述符的长度只有64位，如何填充80位？\n这些都留作之后的笔记再作说明(づ￣ 3￣)づ\n","slug":"段描述符和段选择子","date":"2022-12-14T07:19:32.617Z","categories_index":"","tags_index":"","author_index":"虫子"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"段寄存器什么是段寄存器在先前的逆向基础笔记五 标志寄存器中，有提到过段寄存器的概念\n当使用汇编来操作一个内存地址时，就会涉及到段寄存器，只不过先前并没有太过在意\n如：\n 复制代码 隐藏代码\nmov dword ptr ds:[0x123456],eax\n\n注意汇编语句中的 ds，它就是一个段寄存器\n实际上真正读取的内存地址为：ds.base+0x123456\n\n段寄存器有哪些段寄存器共8个： CS DS ES SS FS GS LDTR TR\nCS代码段寄存器，用于存放代码段的段基址\nDS数据段寄存器，用于存放数据段的段基址\nES附加段寄存器，用于存放附加段的段基址\nSS堆栈段寄存器，用于存放堆栈段的段基址，指示堆栈段区域的位置\nFS附加段寄存器，F为上一个附加段寄存器字母E后的字母，没有对应的名称\n指向一种被称为线程信息块（TIB）的结构，这种结构是由内核在创建线程时创建的，用于支持操作系统相关功能、服务和API\nGS附加段寄存器，G为上一个附加段寄存器字母F后的字母，没有对应的名称\n在32位Windows上GS保留供将来使用\n在x64模式下，FS和GS段寄存器已交换\nWin64使用GS的原因是该FS寄存器用于32位兼容性层（称为Wow64）\n32位应用程序永远不会导致GS更改，而64位应用程序永远不会导致FS更改\n注意，在Win64和Wow64中GS是非零的，这可以用来检测一个32位应用程序是否在64位Windows中运行，在一个“真正“的32位Windows中GS总是零\nIDTR中断描述符表寄存器，用于存放中断描述符表IDT的32位线性基地址和16位表长度值\nTR任务寄存器，用于存放当前任务TSS段的16位段选择符、32位基地址、16位段长度和描述符属性值\n\n段寄存器的结构\n\n\n组成\nBase\nLimit\nAttribute\nSelector\n\n\n\n数据宽度\n32位\n32位\n16位\n16位\n\n\n是否可见\n不可见\n不可见\n不可见\n可见\n\n\n描述\n基地址（当前段的起始地址）\n大小限制（当前段的整个长度）\n属性（当前段是否可读可写可执行）\n段选择子\n\n\n\n 复制代码 隐藏代码struct Segment&#123;\n    WORD Selector;\n    WORD Attribute;\n    DWORD Base;\n    DWORD Limit;\n&#125;\n\n\n段寄存器的属性拿OD随便载入一个程序，观察寄存器窗口：\n\n得到了当前的计算机的段寄存器信息（不同计算机段寄存器信息不一定相同）\n\n\n\n\n段寄存器\nSelector\nAttribute\nBase\nLimit\n\n\n\nES\n0023\n可读、可写\n0\n0xFFFFFFFF\n\n\nCS\n001B\n可读、可执行\n0\n0xFFFFFFFF\n\n\nSS\n0023\n可读、可写\n0\n0xFFFFFFFF\n\n\nDS\n0023\n可读、可写\n0\n0xFFFFFFFF\n\n\nFS\n003B\n可读、可写\n0x7FFDE000\n0xFFF\n\n\nGS\n-\n-\n-\n-\n\n\n段寄存器的读写对于段寄存器可以使用MOV指令进行读写（LDTR和TR除外）\n读段寄存器 复制代码 隐藏代码#include &lt;stdio.h&gt;\n#include &lt;windows.h&gt;\nint main()&#123;\n    WORD selector&#x3D;0;\n    _asm&#123;\n        mov selector, es\n    &#125;\n    printf(&quot;%x\\n&quot;,selector);\n    return 0;\n&#125;\n\n对段寄存器的读操作只能读取段寄存器的16位Selector部分（可见部分）\n\n运行结果\n能够正确地读出es段寄存器的selector\n\n写段寄存器 复制代码 隐藏代码#include &lt;stdio.h&gt;\n#include &lt;windows.h&gt;\nWORD data&#x3D;0x0610;\nWORD readData&#x3D;0;\n__declspec(naked) void fuction()&#123;\n     __asm&#123;\n                &#x2F;&#x2F;保留调用前堆栈\n                push ebp\n                &#x2F;&#x2F;提升堆栈\n                mov ebp,esp\n                sub esp,0x40\n                &#x2F;&#x2F;保护现场\n                push ebx\n                push esi\n                push edi\n                &#x2F;&#x2F;初始化提升的堆栈，填充缓冲区\n                mov eax,0xCCCCCCCC\n                mov ecx,0x10\n                lea edi,dword ptr ds:[ebp-0x40]\n                rep stosd\n                &#x2F;&#x2F;函数核心功能\n\n                push ds         &#x2F;&#x2F;保存ds段寄存器\n                mov ax,cs       &#x2F;&#x2F;将cs段寄存器的段选择子赋值给ax\n                mov ds,ax       &#x2F;&#x2F;使用cs段寄存器覆盖ds段寄存器\n                mov ax,word ptr ds:[data]       &#x2F;&#x2F;使用修改后的段寄存器ds读取，这里相当于mov ax,word ptr cs:[data]\n                pop ds          &#x2F;&#x2F;还原ds段寄存器\n                mov readData,ax &#x2F;&#x2F;将读出来的数据赋值给变量\n\n                &#x2F;&#x2F;恢复现场\n                pop edi\n                pop esi\n                pop ebx\n\n                &#x2F;&#x2F;降低堆栈\n                mov esp,ebp\n                pop ebp                \n\n                &#x2F;&#x2F;返回\n                ret \n        &#125;        \n&#125;\n\nint main()&#123;\n\n        fuction();\n        printf(&quot;%X\\n&quot;,readData);\n\n        return 0;\n&#125;\n\n\n运行结果\n可以看到代码是能够正常执行，并且输出对应的data\n\n说明上述代码使用了裸函数，避免了编译器的干扰；关于裸函数可以回顾：逆向基础笔记九 C语言内联汇编和调用协定\n截取出关键代码：\n 复制代码 隐藏代码push ds         &#x2F;&#x2F;保存ds段寄存器\nmov ax,cs       &#x2F;&#x2F;将cs段寄存器的段选择子赋值给ax\nmov ds,ax       &#x2F;&#x2F;使用cs段寄存器覆盖ds段寄存器\nmov ax,word ptr ds:[data]       &#x2F;&#x2F;使用修改后的段寄存器ds读取，这里相当于mov ax,word ptr cs:[data]\npop ds          &#x2F;&#x2F;还原ds段寄存器\nmov readData,ax &#x2F;&#x2F;将读出来的数据赋值给变量\n\n\n代码注释如上，就是个简单的覆盖段寄存器的操作\n\n为什么明明替换了段寄存器，仍然能够正常运行呢？\n首先要注意到，替换和被替换的段寄存器分别是：cs和ds；它们的base是相同的都为0，因此所访问的内存自然也是相同的\n再来看权限问题：无论是cs还是ds，它们都具有可读的权限；这里也只对数据进行了读操作，于是可以正常运行\n如果这里将读取data的代码修改为写data的代码，则会报错：\n 复制代码 隐藏代码mov ax,word ptr ds:[data]   &#x2F;&#x2F;使用cs段寄存器覆盖过的ds段寄存器，读取data\n&#x2F;&#x2F;将上面的代码修改为：\nmov word ptr ds:[data],ax   &#x2F;&#x2F;使用cs段寄存器覆盖过的ds段寄存器，修改data\n\n为什么会报错？因为此时的ds段寄存器已经被覆盖为了cs段寄存器，而cs段寄存器的权限为可读、可执行，没有可写的权限，所以会报错\n报错截图：\n\n可以看到，此时的data的地址明明是有效的，先前也验证了可以正确读取，但是在这里就会报错：Acccess Violation（非法访问）\n就这里就是因为段寄存器权限不足导致的，也是为什么先前都是使用ds段寄存器来赋值，而不是用cs段寄存器\n 复制代码 隐藏代码mov word ptr ds:[address],data  &#x2F;&#x2F;使用ds段寄存器修改数据，可以正常修改\nmov word ptr cs:[address],data &#x2F;&#x2F;使用cs段寄存器修改数据，会报错\n\n\n和前面对段寄存器的读操作不同，写寄存器是对整个96位的段寄存器进行修改\n但是这里明明只给出了16位的段选择子Selector，剩下的80位呢？\n这个就段描述符有关了，这里暂且不谈，留作之后自会知晓，先记住写寄存器是对整个段寄存器进行修改即可\n\n验证Limit在前面的读写中，或多或少都验证了段寄存器的几个属性：Base、Selector、Attribute\n现在最后验证一下Limit\n 复制代码 隐藏代码#include &lt;stdio.h&gt;\n#include &lt;windows.h&gt;\nint main()&#123;\n\n    unsigned char base;\n    _asm&#123;   \n\n        mov al,fs:[0x1000]      &#x2F;&#x2F;超过limit:0xfff，无法正常运行\n        mov base,al\n    &#125;\n    printf(&quot;%x\\n&quot;,base);\n    return 0;\n&#125;\n\n\n\n 复制代码 隐藏代码#include &lt;stdio.h&gt;\n#include &lt;windows.h&gt;\nint main()&#123;\n\n    unsigned char base;\n    _asm&#123;   \n\n        mov al,fs:[0xfff]       &#x2F;&#x2F;在临界点可以正常运行\n        mov base,al\n    &#125;\n    printf(&quot;%x\\n&quot;,base);\n    return 0;\n&#125;\n\n\n\n总结\n段寄存器共96位，其中16位为可见部分，后80位为不可见部分\n不同计算机段寄存器信息不一定相同\nFS和GS两个段寄存器分别在32位程序和64位程序发挥作用\n\n","slug":"段寄存器","date":"2022-12-14T07:19:32.614Z","categories_index":"","tags_index":"","author_index":"虫子"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"保护模式x86 CPU的三种模式x86 CPU有3种模式：实模式、保护模式和虚拟8086模式\n现在的操作系统大多都是处于保护模式下\n\n\n\n\n实模式\n保护模式\n虚拟8086模式\n\n\n\n内存寻址方式\n段式寻址\n支持内存分页和虚拟内存\n段式寻址\n\n\n寻址范围\n任意寻址\n有限\n任意寻址\n\n\n举例系统\ndos系统\nWindows系统\n？\n\n\n上面只是简单列举了三种模式的一些区别，具体细节不作深入\n只需要明确一点：保护模式相比于其它两种模式，根本在于进程内存受到了保护\n\nx86和x64想必不少人会疑问，现在大多数计算机都是x64的了，为什么还在讲x86？\n因为x64是向下兼容x86的\n\nx86：由Intel推出的一种复杂指令集,能够生产支持这种指令集CPU公司主要是Intel和AMD\nx64：AMD在1999年的时候，拓展了这套指令集，称为x86-64,后改名为AMD64,Intel也兼容了这个产品，称为Intel 64.但AMD64和Intel64，几乎是一样的，所以在很多资料中统称为x64\n\n\n什么是保护模式保护模式是基于安全性和稳定性的考量而产生的一种CPU模式\n\n保护模式的两大特点前面说过保护模式区别于其它两种模式的根本是在进程内存上\n所以保护模式的两大特点也是基于内存的：\n\n段的机制（内存分段）\n页的机制（内存分页）\n\n\n为什么要学习保护模式因为现在的Window系统都是基于保护模式运作的\n所以学习保护模式后才能真正地理解内核是如何运作的\n并且通过保护模式的知识，可以实现 提权操作（在应用层做到内核层才能做的事）\n不了解保护模式，就相当于写的程序不过是在调用WinAPI而已：在应用层(ring3)调用应用层API，在内核层(ring0)调用内核层API\n并且由于保护模式对进程内存的保护，在学习它之后，能够对内存有进一步的认识\n\n参考书籍英特尔®64和IA-32体系结构软件开发人员手册合并卷\n详细说明本文档包含以下内容：\n第1卷：介绍支持IA-32和Intel®64体系结构的处理器的体系结构和编程环境。\n第2卷：包括完整的指令集参考AZ。描述说明的格式，并提供说明的参考页。\n第3卷：包括完整的系统编程指南，第1、2、3和4部分。描述了Intel®64和IA-32体系结构的操作系统支持环境，包括：内存管理，保护，任务管理，中断和异常处理，多处理器支持，热和电源管理功能，调试，性能监控，系统管理模式，虚拟机扩展（VMX）指令，英特尔®虚拟化技术（英特尔®VT）和英特尔®软件保护扩展（英特尔®SGX） ）。\n第4卷：描述了支持IA-32和Intel®64体系结构的处理器的特定于模型的寄存器。\n","slug":"保护模式介绍","date":"2022-12-14T07:19:32.609Z","categories_index":"","tags_index":"","author_index":"虫子"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"","slug":"中断门和IDT(中断描述符表)","date":"2022-12-14T07:19:32.604Z","categories_index":"","tags_index":"","author_index":"虫子"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n2.（4.0分） In this and succeeding meetings the of attention was primarily on the manpower involved, with some discussion of the public expenditure costs.A focusB absenceC minimumD authority\n","slug":"hello-world","date":"2022-12-14T07:19:32.599Z","categories_index":"","tags_index":"","author_index":"虫子"},{"id":"7bcb9e1af25ded2b038f5286bb791f16","title":"第一篇博客","content":"","slug":"第一篇博客","date":"2022-12-13T16:26:03.000Z","categories_index":"","tags_index":"","author_index":"虫子"}]