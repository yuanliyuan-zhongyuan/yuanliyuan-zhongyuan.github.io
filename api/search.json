[{"id":"cc63799a1b9642350fcc7dd68903abec","title":"WIFI主机-资源存储","content":"WIFI主机\n\n\n\n\n\n\n\n\n\n常用存储器存储器种类\n\nRAM存储器\n\n\n\n\n\n\n\n\nRAM是“Random Access Memory”的缩写，被译为随机存储器。所谓“随机存取”，指的是当存储器中的消息被读取或写入时，所需要的时间与这段信息所在的位置无关。这个词的由来是因为早期计算机曾使用磁鼓作为存储器，磁鼓是顺序读写设备，而RAM可随读取其内部任意地址的数据，时间都是相同的，因此得名\n实际上现在RAM已经专门用于指代作为计算机内存的易失性半导体存储器\n根据RAM的存储机制，又分为动态随机存储器DRAM(Dynamic RAM)以及静态随机存储器SRAM(Static RAM)两种\nDRAM的存储单元结构\n动态随机存储器DRAM(Dynamic RAM)\n\n&#x3D;&#x3D;DRAM以电容的电荷来表示数据&#x3D;&#x3D;\nSRAM的存储单元结构\n静态随机存储器SRAM(Static RAM)\n\n&#x3D;&#x3D;SRAM以锁存器来存储数据&#x3D;&#x3D;\nDRAM与SRAM的特性\n\n同步&#x2F; 异步存储器\n\n\n\n\n\n\n\n\n可直接根据是否有时钟信号线区分\n同步方式\n\n异步方式\n\n常见的DRAM都采用同步方式，称为SDRAM(Synchronous DRAM)。\n常见的SRAM都采用异步方式，它们被直接称为SRAM。\n不同种类SDRAM的差异\n\nROM存储器\n\n\n\n\n\n\n\n\nROM是“Read Only Memory”的缩写，意为只能读的存储器。由于技术的发展，后来设计出了可以方便写入数据的ROM，而这个“Read Only Memory”的名称被沿用下来了，现在一般用于指代非易失性半导体存储器，包括后面介绍的FLASH存储器，有些人也把它归到ROM类里边\n\nFLASH存储器\n\n\n\n\n\n\n\n\nFLASH存储器又称为闪存，它也是可重复擦写的储器，部分书籍会把FLASH存储器称为FLASH ROM，但它的容量一般比EEPROM大得多，且在擦除时，一般以多个字节为单位。\n根据存储单元电路的不同，FLASH存储器又分为NORFLASH和NAND FLASH\n\n什么是EEPROM\n\n\n\n\n\n\n\n\n就是一个存储芯片，可以按字节进行读写操作。最常用的有AT24Cxx系列，比如AT24C64/C128\n我们用的是AT24C128，根据芯片手册描述，内存总共有131072个Bit大小，除以8就是Byte，再除1024就是KB。\n\n和Flash有什么区别\n\n\n\n\n\n\n\n\n\nEEPROM可以按“字节”擦写，而FLASH只能按“块”一大片一大片的擦写。\nEEPROM容量一般比Flash小。\n读的速度的话，应该不是两者的差别，只是EERPOM一般用于低端产品，读的速度不需要那么快，真要做的话，其实也是可以做的和FLASH差不多。\nEEPROM价格比Flash便宜，一般用于低端产品。\n\n我们产品对内存需求不大，对读写速度没太大要求，所以选用价格便宜的EEPROM。\nIIC协议简介\n\n\n\n\n\n\n\n\nI2C 通讯协议(Inter－Integrated Circuit)是由Phiilps公司开发的，由于它引脚少，硬件实现简单，可扩展性强，不需要USART、CAN等通讯协议的外部收发设备，现在被广泛地使用在系统内多个集成电路(IC)间的通讯。\nI2C物理层的特点\n\n\n\n\n\n\n\n\n\n\n它是一个支持多设备的总线。“总线”指多个设备共用的信号线。在一个I2C通讯总线中，可连接多个I2C通讯设备，支持多个通讯主机及多个通讯从机\n一个I2C总线只使用两条总线线路，一条双向串行数据线(SDA) ，一条串行时钟线 (SCL)。数据线即用来表示数据，时钟线用于数据收发同步\n每个连接到总线的设备都有一个独立的地址，主机可以利用这个地址进行不同设备之间的访问\n总线通过上拉电阻接到电源。当I2C设备空闲时，会输出高阻态，而当所有设备都空闲，都输出高阻态时，由上拉电阻把总线拉成高电平\n多个主机同时使用总线时，为了防止数据冲突，会利用仲裁方式决定由哪个设备占用总线。\n具有三种传输模式：标准模式传输速率为100kbit&#x2F;s ，快速模式为400kbit&#x2F;s ，高速模式下可达 3.4Mbit&#x2F;s，但目前大多I 2 C设备尚不支持高速模式。\n连接到相同总线的 IC 数量受到总线的最大电容 400pF 限制\n\nI2C 总线在物理连接上非常简单，分别由&#x3D;&#x3D;SDA(串行数据线)&#x3D;&#x3D;和&#x3D;&#x3D;SCL(串行时钟线)&#x3D;&#x3D;及上拉电阻组成。通信原理是通过对SCL和SDA线高低电平时序的控制，来产生I2C总线协议所需要的信号进行数据的传递。在总线空闲状态时，这两根线一般被上面所接的上拉电阻拉高，保持着高电平\nI2C的协议层\n\n\n\n\n\n\n\n\nI2C的协议定义了通讯的起始和停止信号、数据有效性、响应、仲裁、时钟同步和地址广播等环节\nI2C基本读写过程\n&#x3D;&#x3D;主机写数据到从机&#x3D;&#x3D;\n\n&#x3D;&#x3D;主机由从机中读数据&#x3D;&#x3D;\n\n&#x3D;&#x3D;通讯复合格式&#x3D;&#x3D;\n\n 通讯的起始和停止信号\n\n\n\n\n\n\n\n\n\n\n当 SCL 线是高电平时 SDA 线从高电平向低电平切换，这个情况表示通讯的起始。\n当 SCL 是高电平时 SDA 线由低电平向高电平切换，表示通讯的停止。\n起始和停止信号一般由&#x3D;&#x3D;主机&#x3D;&#x3D;产生。\n\n 数据有效性\n\n\n\n\n\n\n\n\nI2C使用SDA信号线来传输数据，使用SCL信号线进行数据同步。SDA数据线在SCL的每个时钟周期传输一位数据\n\n\nSCL为高电平的时候SDA表示的数据有效，即此时的SDA为高电平时表示数据“1”，为低电平时表示数据“0”。\n当SCL为低电平时，SDA的数据无效，一般在这个时候SDA进行电平切换，为下一次表示数据做好准备\n\n 地址及数据方向\n\n\n\n\n\n\n\n\n\nI2C总线上的每个设备都有自己的独立地址，主机发起通讯时，通过SDA信号线发送设备地址(SLAVE_ADDRESS)来查找从机。设备地址可以是7位或10位。\n紧跟设备地址的一个读写位R&#x2F;W用来表示数据传输方向，数据方向位为“1”时表示主机由从机读数据，该位为“0”时表示主机向从机写数据。\n\n\n 响应\n\n\n\n\n\n\n\n\nI2C的数据和地址传输都带响应。响应包括“应答(ACK)”和“非应答(NACK)”两种信号\n\n传输时主机产生时钟，在第9个时钟时，数据发送端会释放SDA的控制权，由数据接收端控制SDA，若SDA为高电平，表示非应答信号(NACK)，低电平表示应答信号(ACK)。\nSTM32的I2C特性及架构\n\n\n\n\n\n\n\n\n软件模拟协议：使用CPU直接控制通讯引脚的电平，产生出符合通讯协议标准的逻辑。硬件实现协议：由STM32的I2C片上外设专门负责实现I2C通讯协议，只要配置好该外设，它就会自动根据协议要求产生通讯信号，收发数据并缓存起来，CPU只要检测该外设的状态和访问数据寄存器，就能完成数据收发。这种由硬件外设处理I2C协议的方式减轻了CPU的工作，且使软件设计更加简单\nSTM32的I2C外设可用作通讯的主机及从机，支持100Kbit&#x2F;s和400Kbit&#x2F;s的速率，支持7位、10位设备地址，支持DMA数据传输，并具有数据校验功能。\n\n通讯引脚\n\n\n\n\n\n\n\n\nSTM32芯片有多个I2C外设，它们的I2C通讯信号引出到不同的GPIO引脚上\n\n时钟控制逻辑\n\n\n\n\n\n\n\n\nSCL线的时钟信号，由I 2 C接口根据时钟控制寄存器(CCR)控制，控制的参数主要为时钟频率。\n\n可选择I2C通讯的“标准&#x2F;快速”模式，这两个模式分别I2C对应100&#x2F;400Kbit&#x2F;s的通讯速率。\n在快速模式下可选择SCL时钟的占空比，可选T low &#x2F;T high &#x3D;2或T low &#x2F;T high &#x3D;16&#x2F;9模式\nCCR寄存器中12位的配置因子CCR，它与I2C外设的输入时钟源共同作用，产生SCL时钟。STM32的I2C外设输入时钟源为PCLK1\n\n&#x3D;&#x3D;计算时钟频率&#x3D;&#x3D;(了解就行，我们之后都是直接用库)\n\n数据控制逻辑\n\n\n\n\n\n\n\n\nI2C的SDA信号主要连接到数据移位寄存器上，数据移位寄存器的数据来源及目标是数据寄存器(DR)、地址寄存器(OAR)、PEC寄存器以及SDA数据线\n\n当向外发送数据的时候，数据移位寄存器以“数据寄存器”为数据源，把数据一位一位地通过SDA信号线发送出去；\n当从外部接收数据的时候，数据移位寄存器把SDA信号线采样到的数据一位一位地存储到“数据寄存器”中\n\n整体控制逻辑\n\n\n\n\n\n\n\n\n整体控制逻辑负责协调整个I2C外设，控制逻辑的工作模式根据我们配置的“控制寄存器(CR1&#x2F;CR2)”的参数而改变。\n在外设工作时，控制逻辑会根据外设的工作状态修改“状态寄存器(SR1和SR2)”，只要读取这些寄存器相关的寄存器位，就可以了解I2C的工作状态。\nSTM32 的I2C\n\n\n\n\n\n\n\n\n使用I2C外设通讯时，在通讯的不同阶段它会对“状态寄存器(SR1及SR2)”的不同数据位写入参数，通过读取这些寄存器标志来了解通讯状态。\n主发送器\n\n\n\n\n\n\n\n\n\n可使用STM32标准库函数来直接检测这些事件的复合标志，降低编程难度\n\n控制产生起始信号(S)，当发生起始信号后，它产生事件“EV5”，并会对SR1寄存器的“SB”位置1，表示起始信号已经发送\n发送设备地址并等待应答信号，若有从机应答，则产生事件“EV6”及“EV8”，这时SR1寄存器的“ADDR”位及“TXE”位被置1，ADDR 为1表示地址已经发送，TXE为1表示数据寄存器为空；\n往I2C的“数据寄存器DR”写入要发送的数据，这时TXE位会被重置0，表示数据寄存器非空，I2C外设通过SDA信号线一位位把数据发送出去后，又会产生“EV8”事件，即TXE位被置1，重复这个过程，可以发送多个字节数据；\n发送数据完成后，控制I2C设备产生一个停止信号(P)，这个时候会产生EV2事件，SR1的TXE位及BTF位都被置1，表示通讯结束\n\n主接收器\n\n\n\n\n\n\n\n\n\n\n起始信号(S)是由主机端产生的，控制发生起始信号后，它产生事件“EV5”，并会对SR1寄存器的“SB”位置1，表示起始信号已经发送；\n发送设备地址并等待应答信号，若有从机应答，则产生事件“EV6”这时SR1寄存器的“ADDR”位被置1，表示地址已经发送\n从机端接收到地址后，开始向主机端发送数据。当主机接收到这些数据后，会产生“EV7”事件，SR1寄存器的RXNE被置1，表示接收数据寄存器非空，读取该寄存器后，可对数据寄存器清空，以便接收下一次数据。此时可以控制I2C发送应答信号(ACK)或非应答信号(NACK)，若应答，则重复以上步骤接收数据，若非应答，则停止传输；\n发送非应答信号后，产生停止信号(P)，结束传输\n\nI2C初始化结构体\n\n\n\n\n\n\n\n\n\ntypedef struct\n&#123;\n  uint32_t I2C_ClockSpeed;         //设置SCL时钟频率，此值要低于40 0000        \n  uint16_t I2C_Mode;               // 指定工作模式，可选I2C模式和SMBUS模式\n  uint16_t I2C_DutyCycle;          //指定时钟占空比，可选low/high=2:1及16:9模式\n  uint16_t I2C_OwnAddress1;        // 指定自身的I2C设备地址\n  uint16_t I2C_Ack;                //使能或关闭响应(一般都要使能)\n  uint16_t I2C_AcknowledgedAddress;// 指定地址长度，可为7位或10位\n&#125;I2C_InitTypeDef;\n\n模拟IIC协议代码实战\n\n\n\n\n\n\n\n\n不是我不想硬件IIC，而是自古以来硬件IIC都有bug，所以很多公司都是软件IIC的，主要也是软件IIC移植性很高，我有时间也把硬件IIC写出来吧，硬件IIC比软件难不少\n模拟IIC就是通过我们控制单片机IO输出指定脉宽的高低电平组合去完成整个IIC的软件协议功能(时序)。STM32F103内部是带硬件IIC模块，也就是说不用自己辛苦去控制IO口完成时序，我们只需要调用他们读写的函数就可以了，至于时序怎么搞由单片机硬件IIC模块自己处理，这就是硬件IIC。那为什么硬件IIC这么方便还要用模拟的IIC？1.模拟的移植性更强，更换单片机只需要更改IO口，IIC时序部分代码基本不用改。2.据说STM32F103系列硬件IIC有问题，我是从来没用过内部硬件IIC，都是用模拟。\n我们写模拟IIC程序的思路是模块化思维，避免大量重复代码。所以我们一般会把最底层的起始时序、停止时序、应答时序和非应答时序都封装成函数方便后面字节写、页写、连续读功能代码使用\n这个代码实战需要完成的功能：写几个字节数据到EEPROM，再读出来看值是否和写进去的一样。\n功能代码实现流程\n\n\n\n\n\n\n\n\n\n配置EEPROM对应STM32引脚成普通IO口。\n完成起始时序。\n完成停止时序。\n完成应答和非应答时序。\n完成写8位数据时序。\n完成写一个字节数据功能函数。\n完成读8位数据时序。\n完成读1个字节数据功能函数\n\niic配置函数\n\n\n\n\n\n\n\n\n\n//iic配置函数\nstatic void hal_I2C_Config(void)\n&#123;\n  GPIO_InitTypeDef  GPIO_InitStructure; \n  /* Configure I2C2 pins: PB8->SCL and PB9->SDA */\n  I2C_GPIO_APBxClkCmd(I2C_GPIO_CLK, ENABLE);\n  GPIO_InitStructure.GPIO_Pin =  I2C_SCL_PIN | I2C_SDA_PIN;\n  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n  //开漏输出\n  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;  \n  GPIO_Init(I2C_SCL_PORT, &amp;GPIO_InitStructure);\n  \n  hal_I2C_SDA(1);\n  hal_I2C_SCL(1);\n&#125;\n\n 通讯的起始和停止信号\n\n\n\n\n\n\n\n\n\n//iic起始信号\nvoid I2C_Start(void)\n&#123;\n\thal_I2C_SDA(1);\n\thal_I2C_SCL(1);\n\t//延时一丢丢时间\n\tI2C_delay(1);\n\thal_I2C_SDA(0);\n\t//延时一丢丢时间\n\tI2C_delay(1);\n&#125;\n//iic停止信号\nvoid I2C_Stop(void)\n&#123;\n\thal_I2C_SCL(1);\n\thal_I2C_SDA(0);\n\t//延时一丢丢时间\n\tI2C_delay(1);\n\thal_I2C_SDA(1);\n\t//延时一丢丢时间\n\tI2C_delay(1);\n&#125;\n\n 数据有效性\n\n\n\n\n\n\n\n\n\n//iic发字节\nvoid I2C_SendByte(uint8_t SendByte) \n&#123;\n    uint8_t i=0;\n\tuint8_t temp;\n\ttemp = SendByte;\n\tfor(i=0;i&lt;8;i++)\n\t&#123;\n\t\thal_I2C_SCL(0);\n\t\tI2C_delay(1);\n\t\ttemp&amp;0x80 ? hal_I2C_SDA(1)\n\t\t          : hal_I2C_SDA(0);\n\t\tI2C_delay(1);\n\t\thal_I2C_SCL(1);\n\t\tI2C_delay(1);\n\t\ttemp&lt;&lt;=1;\n\t&#125;\n\thal_I2C_SCL(0);\n\tI2C_delay(1);\n&#125;\n\n 响应\n\n\n\n\n\n\n\n\n\n//iic数据线IO设置\nvoid hal_I2C_SDA_IO_Set(uint8_t IOMode)\n&#123;\n\tif(!IOMode)\t\t\t\t\t//输出\n\t&#123;\n\t\tGPIO_InitTypeDef  GPIO_InitStructure; \n\t\tI2C_GPIO_APBxClkCmd(I2C_GPIO_CLK, ENABLE);\n\t\tGPIO_InitStructure.GPIO_Pin = I2C_SDA_PIN;\n\t\tGPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n\t\t//开漏输出\n\t\tGPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;  \n\t\tGPIO_Init(I2C_SDA_PORT, &amp;GPIO_InitStructure);\n\t&#125;else if(IOMode)\t\t\t//输入\t\n\t&#123;\n\t\tGPIO_InitTypeDef  GPIO_InitStructure; \n\t\tI2C_GPIO_APBxClkCmd(I2C_GPIO_CLK, ENABLE);\n\t\tGPIO_InitStructure.GPIO_Pin = I2C_SDA_PIN;\n\t\tGPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n\t\t//上拉输入\n\t\tGPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;  \n\t\tGPIO_Init(I2C_SDA_PORT, &amp;GPIO_InitStructure);\n\t&#125;\n&#125;\n//iic数据线输入\nuint8_t hal_I2C_SDA_INPUT(void)\n&#123;\n\treturn GPIO_ReadInputDataBit(I2C_SDA_PORT, I2C_SDA_PIN);\t\t\n&#125;\n//iic应答\nvoid I2C_Ack(void)\n&#123;\t\n\thal_I2C_SCL(0);\n\tI2C_delay(1);\n\thal_I2C_SDA(0);\n\tI2C_delay(1);\n\thal_I2C_SCL(1);\n\tI2C_delay(1);\n\thal_I2C_SCL(0);\n\tI2C_delay(1);\n&#125;\n//iic非应答\nvoid I2C_NoAck(void)\n&#123;\t\n\thal_I2C_SCL(0);\n\tI2C_delay(1);\n\thal_I2C_SDA(1);\n\tI2C_delay(1);\n\thal_I2C_SCL(1);\n\tI2C_delay(1);\n\thal_I2C_SCL(0);\n\tI2C_delay(1);\n&#125;\n//iic等待应答\nuint8_t I2C_WaitAck(void) \t\n&#123;\n\thal_I2C_SDA(1);\n\t//SDA主机输入，控制权给接收端\n\thal_I2C_SDA_IO_Set(1);\t\t \n\thal_I2C_SCL(1);\n\tI2C_delay(1);\n\t//接收端发出高电平表示非应答\n\tif(hal_I2C_SDA_INPUT())\n\t&#123;\n\t\treturn 0;\n\t&#125;\n\thal_I2C_SCL(0);\n\t//控制权重新交给主机\n\thal_I2C_SDA_IO_Set(0);\t\t \n\tI2C_delay(1); \n\treturn 1;\n&#125;\n\n 读一个字节\n\n\n\n\n\n\n\n\n\n//读1个字节\nuint8_t I2C_ReadByte(uint16_t address)\n&#123;\n\tuint8_t dat;\n\tI2C_Start();\n\tI2C_SendByte(0xA0);\n\tI2C_WaitAck();\n\n\tI2C_SendByte((address>>8)&amp;0xFF);\n\tI2C_WaitAck();\n\n\tI2C_SendByte(address&amp;0xFF);\n\tI2C_WaitAck();\n\n\tI2C_Start();\n\tI2C_SendByte(0xA1);\n\tI2C_WaitAck();\n\t\n\tdat = I2C_ReceiveByte();\n\tI2C_NoAck();\n\tI2C_Stop();\n\treturn dat;\n&#125;\n\n 接收字节\n\n\n\n\n\n\n\n\n\n//iic接收字节\nuint8_t I2C_ReceiveByte(void)  \n&#123; \n\tuint8_t i;\n\tuint8_t ReceiveByte=0;\n\t\n\thal_I2C_SCL(0);\n\tI2C_delay(1);\n\thal_I2C_SDA(1);\n\thal_I2C_SDA_IO_Set(1);\t\t //SDA设置成输入\n\tfor(i=0; i&lt;8; i++)\n\t&#123;\n\t\tReceiveByte &lt;&lt;= 1;\n\t\tI2C_delay(1);\n\t\thal_I2C_SCL(1);\n\t\tI2C_delay(1);\n\t\tif(hal_I2C_SDA_INPUT())\n\t\t&#123;\n\t\t\tReceiveByte|=0x01;\n\t\t&#125;\n\t\thal_I2C_SCL(0);\n\t\t\n\t&#125;\n\thal_I2C_SDA_IO_Set(0);\t\t//SDA设置成输出\n\tI2C_delay(1);\n\treturn ReceiveByte;\n&#125;\n\n 字节写\n\n\n\n\n\n\n\n\n前面我们讲的都是底层传输的时序定义，时序明白以后就要封装成写一个字节这种时序的函数。\n\n//字节写\nvoid I2C_WriteByte(uint16_t address,uint8_t dat)\n&#123;\n\tI2C_Start();\n\t\n\tI2C_SendByte(0xA0);\n\tI2C_WaitAck();\n\t\n\tI2C_SendByte((address>>8)&amp;0xFF);\n\tI2C_WaitAck();\n\t\n\tI2C_SendByte(address&amp;0xFF);\n\tI2C_WaitAck();\n\t\n\tI2C_SendByte(dat);\n\tI2C_WaitAck();\n\t\n\tI2C_Stop();\t\n&#125;\n\n 页写功能\n\n\n\n\n\n\n\n\n芯片内部有256页不同分区组成，类似于我们电脑的硬盘分区。那每页的容量是64个字节。\n芯片规定一个起始信号最多只能写64个字节的数据，也就是1页，如果一次性要写64个字节以上的数据就要做翻页的功能，否则超过64个字节的数据会把数据给覆盖掉\n那翻页功能简单来说就是先判断写入的数据有多少个，如果超过64个就又重新发送起始信号，再继续往下写数据\n我们需要考虑到2种情况\n\n一次性写入的数据小于页字节\n一次性写入的数据大于页字节\n\n\n//页写函数,有自动翻页功能,24C64一页32Byte,num最大可写65523个字节\nvoid I2C_PageWrite(uint16_t address,uint8_t* pDat, uint16_t num)\n&#123;\n\tuint8_t *pBuffer,j;\n\tuint16_t len,i,page,remainder,addr,temp;\n\tpBuffer = pDat;\n\tlen = num;\t\t\n\taddr = address;\n\ttemp = 0;\n\tif(addr % EEPROM_PAGE_SIZE)\t//判断要写的地址\n\t&#123;\n\t\ttemp = EEPROM_PAGE_SIZE-(addr%EEPROM_PAGE_SIZE);\t\t\t//32-7=25 //计算出当前地址还差多少字节满1页\n\t\tif(len&lt;=temp)\n\t\t&#123;\n\t\t\ttemp = len;\n\t\t&#125;\n\t&#125;\n\t//先填满写入地址页\n\tif(temp)\n\t&#123;\n\t\tI2C_Start();\n\t\t\n\t\tI2C_SendByte(0xA0);\n\t\tI2C_WaitAck();\n\t\t\n\t\tI2C_SendByte((addr>>8)&amp;0xFF);\n\t\tI2C_WaitAck();\n\t\t\n\t\tI2C_SendByte(addr&amp;0xFF);\n\t\tI2C_WaitAck();\n\t\t\n\t\tfor(j=0; j&lt;temp; j++)\t\t \n\t\t&#123;\n\t\t\tI2C_SendByte(pBuffer[j]);\n\t\t\tI2C_WaitAck();\t\n\t\t&#125;\n\t\tI2C_Stop();\n\t\tI2C_delay(20000);\t\n\t&#125;\n\tlen -= temp;\t\t\t\n\taddr += temp;\t\t\t//地址加上已经写入的字节\n \n\tpage = len/EEPROM_PAGE_SIZE;\t\t\t\n\tremainder = len%EEPROM_PAGE_SIZE;\n\tfor(i=0; i&lt;page; i++)\t\t\n\t&#123;\n\t\tI2C_Start();\n\t\tI2C_SendByte(0xA0);\n\t\tI2C_WaitAck();\n\t\t\n\t\tI2C_SendByte((addr>>8)&amp;0xFF);\n\t\tI2C_WaitAck();\n\t\t\n\t\tI2C_SendByte(addr&amp;0xFF);\n\t\tI2C_WaitAck();\n\t\t\n\t\t\n\t\tfor(j=0;j&lt;EEPROM_PAGE_SIZE;j++)\n\t\t&#123;\n\t\t\tI2C_SendByte(pBuffer[temp+j]);\n\t\t\tI2C_WaitAck();\n\t\t&#125;\n\t\tI2C_Stop();\n\t\taddr += EEPROM_PAGE_SIZE;\n\t//\ttemp += EEPROM_PAGE_SIZE;\n\t\tI2C_delay(20000);\t\t\n\t&#125;\t\n\tif(remainder)\n\t&#123;\n\t\tI2C_Start();\n\t\tI2C_SendByte(0xA0);\n\t\tI2C_WaitAck();\n\t\t\n\t\tI2C_SendByte((addr>>8)&amp;0xFF);\n\t\tI2C_WaitAck();\n\t\t\n\t\tI2C_SendByte(addr&amp;0xFF);\n\t\tI2C_WaitAck();\n\t\t\n\t\tfor(j=0; j&lt;remainder; j++)\t\t \n\t\t&#123;\n\t\t\tI2C_SendByte(pBuffer[temp+j]);\n\t\t\tI2C_WaitAck();\t\n\t\t&#125;\n\t\tI2C_Stop();\n\t\tI2C_delay(20000);\t\t\n\t&#125;\n&#125;\n\n 连续读\n\n\n\n\n\n\n\n\n连续读功能比较简单，不需要解决翻页的问题\n\n//连续读多个字节\nvoid I2C_Read(uint16_t address,uint8_t* pBuffer, uint16_t len)\n&#123;\n\tuint16_t length;\n\tlength = len;\n\tI2C_Start();\n\tI2C_SendByte(0xA0);\n\tI2C_WaitAck();\n\n\tI2C_SendByte((address>>8)&amp;0xFF);\n\tI2C_WaitAck();\n\n\tI2C_SendByte(address&amp;0xFF);\n\tI2C_WaitAck();\n\n\tI2C_Start();\n\tI2C_SendByte(0xA1);\n\tI2C_WaitAck();\n\t\n\t//dat = I2C_ReceiveByte();\n\twhile(length)\n    &#123;\n      *pBuffer = I2C_ReceiveByte();\n      length == 1 ? I2C_NoAck()\n                  : I2C_Ack(); \n      pBuffer++;\n      length--;\n    &#125;\n\t \n\tI2C_Stop();\n\neeprom初始化\n\n\n\n\n\n\n\n\n\n//eeprom初始化\nvoid hal_eepromInit(void)\n&#123;\n\thal_I2C_Config();\n&#125;\n\nEEPROM实现探测器参数掉电保存什么是探测器\n\n\n\n\n\n\n\n\n\n探测器参数有哪些\n\n\n\n\n\n\n\n\n\n一般需要掉电保存的数据都是通过结构体的形式来定义，因为很多数据都是不同的数据类型，比如有unsignedchar类型,unsigned short类型，数组类型，枚举类型、指针类型等等。\n用结构体定义的方式更便于管理，更灵活，可读性也越强\n//支持探测器的总数量  这个取决于eeprom有多大\n#define PARA_DTC_SUM\t\t20\t\t\t\t\t\t\n\n//探测器类型\ntypedef enum\n&#123;\n\tDTC_DOOR,\t\t    //门磁探测器\n\tDTC_PIR,\t\t    //红外探测器\n\tDTC_REMOTE,\t\t\t//遥控器\n\tDTC_TYP_SUM,\n&#125;DTC_TYPE_TYPEDEF;\t    //探测器类型设置值\n\n//探测器防区类型\ntypedef enum\n&#123;\n\tZONE_TYP_24HOURS,\t//24小时警戒\t\n\tZONE_TYP_1ST,\t\t//布防警戒\n\tZONE_TYP_2ND,\t\t//在家布放警戒\n\tSTG_DEV_AT_SUM\n&#125;ZONE_TYPED_TYPEDEF;\n\n//探测器属性\ntypedef struct\n&#123;\n\tunsigned char ID;\t\t\t\t\t\t//设备ID\n\tunsigned char Mark;\t\t \t\t\t\t//0-未学习 1-已学习\n\tunsigned char NameNum;\t\t\t\t\t//名称序号\n\tunsigned char Name[16];\t\t\t\t\t//设备名称\n\tDTC_TYPE_TYPEDEF DTCType;\t\t\t\t//设备类型\n\tZONE_TYPED_TYPEDEF ZoneType;\t\t\t//防区类型\n\n\tunsigned char Code[3];\t\t\t\t\t//1527/2262  24Bit数据\n&#125;Stu_DTC;\n\nFactoryReset  出厂设置函数\n\n\n\n\n\n\n\n\n\n//出厂设置函数\nvoid FactoryReset(void)\n&#123;\n\tuint16_t i;\n\tuint8_t j;\n\t//所有传感器初始化\n\tfor(i=0; i&lt;PARA_DTC_SUM; i++)\n\t&#123;\n\t\tDTC[i].ID = 0;\n\t\tDTC[i].Mark = 0;\n\t\tDTC[i].NameNum = 0;\n\t\tfor(j=0; j&lt;16; j++)\n\t\t&#123;\n\t\t\tDTC[i].Name[i] = 0;\n\t\t&#125;\n\t\tDTC[i].DTCType = DTC_DOOR;\n\t\tDTC[i].ZoneType = ZONE_TYP_1ST;\n\t\tDTC[i].Code[0] = 0;\n\t\tDTC[i].Code[1] = 0;\n\t\tDTC[i].Code[2] = 0;\n\t&#125;\n\tCreatDtc(PARA_DTC_SUM);\n\tI2C_PageWrite(STU_DEVICEPARA_OFFSET,(uint8_t*)(&amp;DTC),sizeof(DTC));\n\tI2C_Read(STU_DEVICEPARA_OFFSET,(uint8_t*)(&amp;DTC),sizeof(DTC));\n&#125;\n\nCreatDtc  创建探测器函数\n\n\n\n\n\n\n\n\n\n//创建探测器函数\nstatic void CreatDtc(uint8_t n)\n&#123;\n\tuint8_t i,NameStrIndex,Temp,j,k;\n\tconst char str[] = \"zone-\";\n\tfor(i=0; i&lt;n; i++)\n\t&#123;\n\t\tDTC[i].ID = i+1;\n\t\tDTC[i].Mark = 1;\t\n\t\tfor(k = 0;k&lt;strlen(str);++k)\n\t\t&#123;\n\t\t\tDTC[i].Name[k]=str[k];\n\t\t&#125;\n\t\t//名称索引，就是这里的\"zone-\"后面的数字\n\t\tNameStrIndex = strlen(str);\n\t\tTemp = \ti+1;\t\n\t\tDTC[i].NameNum = Temp;\t\t\n\t\tDTC[i].Name[NameStrIndex++] = '0'+(Temp/100);\n\t\tDTC[i].Name[NameStrIndex++] = '0'+((Temp%100)/10);\n\t\tDTC[i].Name[NameStrIndex++] = '0'+((Temp%100)%10);\n\t\tfor(j=NameStrIndex; j&lt;16; j++)\n\t\t&#123;\n\t\t\t//把没用到的名字字节清零\n\t\t\tDTC[i].Name[j] = 0;\t\t\t\t\t\n\t\t&#125;\n\t\tDTC[i].DTCType = DTC_DOOR;\n\t\tDTC[i].ZoneType = ZONE_TYP_1ST;\n\t\tDTC[i].Code[0] = 0x0C;\n\t\tDTC[i].Code[1] = 0xBB;\n\t\tDTC[i].Code[2] = 0xAA;\t\t\t\n\t&#125;\n&#125;\n\nParaCheck  参数检测函数\n\n\n\n\n\n\n\n\n\n//参数检查\nstatic uint8_t ParaCheck(void)\n&#123;\n\tuint8_t i;\n\tuint8_t error = 0;\n\tif(DTC[0].ID != 1)\n\t&#123;\n\t\terror = 1;\n\t&#125;\n\tfor(i=0; i&lt;PARA_DTC_SUM; i++)\n\t&#123;\n\t\tif(DTC[i].ID >= PARA_DTC_SUM)\n\t\t&#123;\n\t\t\terror = 1;\n\t\t&#125;\n\t\tif(DTC[i].Mark > 1)\n\t\t&#123;\n\t\t\terror = 1;\n\t\t&#125;\n\t\tif(DTC[i].NameNum > PARA_DTC_SUM)\n\t\t&#123;\n\t\t\terror = 1;\n\t\t&#125;\n\t\t \n\t\tif(DTC[i].DTCType>= DTC_TYP_SUM)\n\t\t&#123;\n\t\t\terror = 1;\n\t\t&#125;\n\t\t\n\t\tif(DTC[i].ZoneType>= STG_DEV_AT_SUM)\n\t\t&#123;\n\t\t\terror = 1;\n\t\t&#125;\t\t \n\t&#125;\t\n\treturn error;\n&#125;\n\n测试\n\n\n\n\n\n\n\n\n\nDelSpecifyDtc  删除特定的探测器\n\n\n\n\n\n\n\n\n\n//删除指定的传感器\n//pDevPara - 要删除的传感器\nvoid DelSpecifyDtc(Stu_DTC *pdPara)\n&#123;\n\tuint8_t i,id;\n\tStu_DTC* pDevPara;\n\tpDevPara = pdPara;\n\tid = pDevPara->ID-1;\n\tpDevPara->ID = 0;\n\tpDevPara->Mark = 0;\n\tpDevPara->NameNum = 0;\n\tfor(i=0; i&lt;16; i++)\n\t&#123;\n\t\tpDevPara->Name[i] = 0;\n\t&#125;\n\tpDevPara->DTCType = DTC_DOOR;\n\tpDevPara->ZoneType = ZONE_TYP_1ST;\n\tpDevPara->Code[0] = 0;\n\tpDevPara->Code[1] = 0;\n\tpDevPara->Code[2] = 0;\n\t//修改设备参数\n\tI2C_PageWrite(STU_DEVICEPARA_OFFSET+id*STU_DTC_SIZE,(uint8_t*)(pDevPara),STU_DTC_SIZE); \n\tI2C_Read(STU_DEVICEPARA_OFFSET+id*STU_DTC_SIZE,(uint8_t*)&amp;DTC[id],STU_DTC_SIZE);\n&#125;\n\nGetDtcNum  获取探测器数量\n\n\n\n\n\n\n\n\n\n//获取探测器数量\n//type - 传感器类型\nuint8_t GetDtcNum(void)\n&#123;\n\tuint8_t i,num,count;\n\tcount = 0;\n\tnum = PARA_DTC_SUM;\n\tfor(i=0;i&lt;num; i++)\n\t&#123;\n\t\tif(DTC[i].Mark)\t\t\t\t//判断设备是否已学习\n\t\t&#123;\t\t\n\t\t\tcount++;\n\t\t&#125;\n\t&#125;\n\treturn count;\n&#125;\n\nAddDtc  添加探测器\n\n\n\n\n\n\n\n\n\n//传感器添加,返回探测器ID,返回0xFF则学习失败\nuint8_t AddDtc(Stu_DTC *pDevPara)\n&#123;\n\tStu_DTC DevPara;\n\tuint8_t i,j,Temp,NameStrIndex,k;\n\tconst char str[] = \"zone-\";\n\tNameStrIndex = 0;\n\tTemp = 0;\t\n\tfor(i=0; i&lt;PARA_DTC_SUM; i++)\n\t&#123;\n\t\tif(DTC[i].Mark &amp;&amp; \n\t\t(DTC[i].Code[1]==pDevPara->Code[1]) &amp;&amp;\n\t\t(DTC[i].Code[2]==pDevPara->Code[2]))\t\t\t//判断探测器是否存在\n\t\t&#123;\t\t\t\t\n\t\t\treturn (i);\t\t\t\t\t\t\t\t\t//探测器已存在，也提示配对成功\n\t\t&#125;\n\t&#125;\n\tfor(i=0; i&lt;PARA_DTC_SUM; i++)\n\t&#123;\n\t\tif(!DTC[i].Mark)\n\t\t&#123;\n\t\t\tfor(k = 0;k&lt;strlen(str);++k)\n\t\t\t&#123;\n\t\t\t\tDevPara.Name[k] = str[k];\n\t\t\t&#125;\n\t\t\tNameStrIndex = strlen(str);\n\t\t\tTemp = \ti+1;\t\t\t\t\n\t\t\tDevPara.Name[NameStrIndex++] = '0'+(Temp/100);\n\t\t\tDevPara.Name[NameStrIndex++] = '0'+((Temp%100)/10);\n\t\t\tDevPara.Name[NameStrIndex++] = '0'+((Temp%100)%10);\n\t\t\t\n\t\t\tfor(j=NameStrIndex; j&lt;16; j++)\n\t\t\t&#123;\n\t\t\t\tDevPara.Name[j] = 0;\t\t\t\t\t//把没用到的名字字节清零\n\t\t\t&#125;\n\t\t\tDevPara.ID = i+1;\n\t\t\tDevPara.Mark = 1;\n\t\t\tDevPara.NameNum = Temp;\t\t\t\n\t\t\tDevPara.DTCType = pDevPara->DTCType;\n\t\t\tDevPara.ZoneType = pDevPara->ZoneType;\t\t\t\n\t\t\tDevPara.Code[0] = pDevPara->Code[0];\n\t\t\tDevPara.Code[1] = pDevPara->Code[1];\n\t\t\tDevPara.Code[2] = pDevPara->Code[2];\n\t\t\tI2C_PageWrite(STU_DEVICEPARA_OFFSET+i*STU_DTC_SIZE,(uint8_t*)(&amp;DevPara),sizeof(DevPara)); //新设备信息写入EEPROM\n\t\t\tI2C_Read(STU_DEVICEPARA_OFFSET+i*STU_DTC_SIZE,(uint8_t*)&amp;DTC[i],STU_DTC_SIZE);\n\t\t\treturn (i);\t\t\t\t\t\t\t//学习成功，返回探测器的存储下标\n\t\t&#125;\n\t&#125;\n\treturn 0xFF;\t\t\t//学习失败\n&#125;\n\nDtcMatching  探测器匹配\n\n\n\n\n\n\n\n\n这里就是RFD匹配\n\n//RFD匹配，返回0xFF匹配失败，探测器不存在,匹配成功返回探测器ID\nuint8_t DtcMatching(uint8_t *pCode)\n&#123;\n\tuint8_t i=0;\n\tfor(i=0; i&lt;PARA_DTC_SUM; i++)\n\t&#123;\n\t\tif(DTC[i].Mark &amp;&amp; \n\t\t(DTC[i].Code[1]==pCode[1]) &amp;&amp;\n\t\t(DTC[i].Code[2]==pCode[2]))\t\t\t//判断探测器是否存在\n\t\t&#123;\t\t\t \n\t\t\treturn (DTC[i].ID);\n\t\t&#125; \n\t&#125;\n\treturn 0xFF;\n&#125;\n\nCheckPresenceofDtc  检查探测器是否存在\n\n\n\n\n\n\n\n\n\n//检查DTC是否存在，0不存在，1存在\nuint8_t CheckPresenceofDtc(uint8_t i)\n&#123;\n\tuint8_t result = 0;\n\tif(i &lt; PARA_DTC_SUM)\t//防溢出检测\n\t&#123;\n\t\tif(DTC[i].Mark)\n\t\t&#123;\n\t\t\tresult = 1;\n\t\t&#125;\n\t&#125;\t\n\treturn result;\n&#125;\n\nGetDtcID  获取探测器ID\n\n\n\n\n\n\n\n\n\n//获取指定探测器的ID,idx-探测器结构体数组下表\nuint8_t GetDtcID(uint8_t idx)\n&#123;\n\tuint8_t result = 0;\n\tif(idx &lt; PARA_DTC_SUM)\t//防溢出检测\n\t&#123;\n\t\tresult = DTC[idx].ID;\n\t&#125;\n\treturn result;\n&#125;\n\nGetDtcStu  获取探测器结构体数据\n\n\n\n\n\n\n\n\n\n//获取指定探测器的结构体数据,*pdDevPara-外部结构体指针，id-要获取的探测器ID\nvoid GetDtcStu(Stu_DTC *pdDevPara,uint8_t idx)\n&#123;\n\tuint8_t i; \n\tif(idx >= PARA_DTC_SUM)\t\t\n\t&#123;\n\t\treturn;\t\t\t//id异常\n\t&#125;\t\n\tpdDevPara->ID = DTC[idx].ID;\t\n\tpdDevPara->Mark = DTC[idx].Mark ;\n\tpdDevPara->NameNum = DTC[idx].NameNum;\t\n\tfor(i=0; i&lt;16; i++)\n\t&#123;\n\t\tpdDevPara->Name[i] = DTC[idx].Name[i];\n\t&#125;\n\tpdDevPara->DTCType = DTC[idx].DTCType;\n\tpdDevPara->ZoneType = DTC[idx].ZoneType;\t \n\tpdDevPara->Code[0] = DTC[idx].Code[0];\n\tpdDevPara->Code[1] = DTC[idx].Code[1];\n\tpdDevPara->Code[2] = DTC[idx].Code[2];\n&#125;\n\nSetDtcAbt  修改探测器属性attribute\n\n\n\n\n\n\n\n\n\n//修改探测器属性,id->指定探测器ID psDevPara->探测器属性结构体\nvoid SetDtcAbt(uint8_t id,Stu_DTC *psDevPara)\n&#123;\n\tunsigned char i;\n\tif(id >= PARA_DTC_SUM)\t\t\n\t&#123;\n\t\treturn;\t\t\t//id异常\n\t&#125;\n\tDTC[id].ID = psDevPara->ID;\n\tDTC[id].Mark = psDevPara->Mark ;\n\tDTC[id].NameNum =  psDevPara->NameNum;\n\t\n\tfor(i=0; i&lt;16; i++)\n\t&#123;\n\t\tDTC[id].Name[i] = psDevPara->Name[i];\n\t&#125;\n\tDTC[id].DTCType = psDevPara->DTCType;\n\tDTC[id].ZoneType = psDevPara->ZoneType;\n\tDTC[id].Code[0] = psDevPara->Code[0];\n\tDTC[id].Code[1] = psDevPara->Code[1];\n\tDTC[id].Code[2] = psDevPara->Code[2];\t\n\tI2C_PageWrite(STU_DEVICEPARA_OFFSET+id*STU_DTC_SIZE,(uint8_t*)psDevPara,STU_DTC_SIZE); //新设备信息写入EEPROM\n\tI2C_Read(STU_DEVICEPARA_OFFSET+id*STU_DTC_SIZE,(uint8_t*)&amp;DTC[id],STU_DTC_SIZE);\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n二级标题三级标题四级标题五级标题六级标题","slug":"wifi主机/wifi主机第七部分  资源存储地","date":"2020-08-15T10:49:36.000Z","categories_index":"单片机","tags_index":"STM32,主机","author_index":"虫子"},{"id":"c6db4d1ad0c97adc524f1401c6716083","title":"WIFI主机-催眠师手札","content":"WIFI主机\n\n\n\n\n\n\n\n\n有些函数名后面写的时候会改一下名字，方面整体记忆。比如Systick_ms改为hal_SystickCoreClockInit\n项目中的一些细节\n\n\n\n\n\n\n\n\n\n\nGPIO\n\n\n\n\n\n\n\n\n我们wifi主机采用的信号是STM32F103C8T6，封装就是LQFP48 ，flash大小就是64K,GPIO就相当于STC15单片机里面的IO口，比如P1，P2，而在STM32中就被命名为PA，PC等等，我们这个型号有48个引脚PA，PB各15个\n\n\n\n\n\n系统定时器\n\n\n\n\n\n\n\n\nSystick是一个24位的系统节拍定时器，SysTick—系统定时器是属于内核的一个定时器，一个 24bit 的向下递减的计数器，计数器每计数一次的时间为 1&#x2F;SYSCLK，一般我们设置系统时钟 SYSCLK 等于 72M。当重装载数值寄存器的值递减到 0 的时候，系统定时器就产生一次中断，以此循环往复。\nSystick的作用：为操作系统任务调度（比如RTOS）提供一个有节奏的定时节拍，也可以用于普通定时。\n\ncounter在时钟的驱动下，从reload初值开始往下递减计数到0，产生中断和置位COUNTFLAG标志。然后又从reload值开始重新递减计数，如此循环。\nSysTick寄存器结构体在固件库文件：core_cm3.h中定义\n\nSysTick配置库函数在固件库文件：core_cm3.h中定义\n\nstatic __INLINE uint32_t SysTick_Config(uint32_t ticks)\n&#123; \n  //判断tick的值是否大于2^24，如果大于则不符合规则\n  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */\n  \n  //初始化重装载(reload)寄存器的值\t\n  SysTick->LOAD  = (ticks &amp; SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */\n  //配置中断优先级，配置15，默认为最低的优先级\n  NVIC_SetPriority (SysTick_IRQn, (1&lt;&lt;__NVIC_PRIO_BITS) - 1);  /* set Priority for Cortex-M0 System Interrupts */\n  //配置counter计数器的值\n  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */\n  //配置systick的时钟是72M\n  //使能中断\n  //使能systick\n  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk | \n                   SysTick_CTRL_TICKINT_Msk   | \n                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */\n  return (0);                                                  /* Function successful */\n&#125;\n\nSysTick中断优先级\n\n\n\n\n\n\n\n\n有一个问题就是SysTick是属于内核里面的外设，他的中断优先级跟片上外设的中断优先级相比，哪个高？？？是内核必然高于片上吗？\n不是的，STM32里面无论是内核还是外设都是使用4个二进制位来表示中断优先级；中断优先级的分组对内核和外设同样适用。当比较的时候，只需要把内核外设的中断优先级的四个位按照外设的中断优先级来分组来解析即可，即人为的分出抢占优先级和子优先级\nsystick中断优先级配置的是scb-&gt;shprx寄存器；而外设的中断优先级配置的是nvic-&gt;iprx，有优先级分组，有抢占优先级和子优先级的说法。\n\n\n\n定时器定时器功能\n\n\n\n\n\n\n\n\n定时、输出比较、输入捕获、互补输出\n定时器分类\n\n\n\n\n\n\n\n\n基本定时器、通用定时器、高级定时器\n基本定时器:只有定时功能\n\n通用定时器：具备定时，输出比较，输入捕获\n高级定时器：包含基本定时器和通用定时器的所有功能\n\n\n\n定时器资源\n\n\n\n\n\n\n\n\nF103系列有2个高级定时器TIM1和TIM8、4个通用定时器TIM2&#x2F;3&#x2F;4&#x2F;5、2个基本定时器TIM6和TIM7\n基本定时器\n\n\n\n\n\n\n\n\n\n时钟源\n\n\n\n\n\n\n\n\n\n时钟源来自RCC的TIMx_CLK（属于内部的CK_INT）\n2-TIMx_CLK等于多少呢？如何确定？72M，这个看RCC时钟树\n\n控制器\n\n\n\n\n\n\n\n\n\n控制器用于控制定时器的：复位、使能、计数、触发DAC\n涉及到的寄存器为：CR1&#x2F;2、DIER、EGR、SR\n\n\n时基（定时器的心脏）\n\n\n\n\n\n\n\n\n定时器最主要的就是时基部分：包括 预分频器、计数器、自动重装载寄存器。\n预分频器:也叫PSC，对时钟进行分频的\n\n16位的预分频器PSC对内部时钟CK_PSC进行分频之后，得到计数器时钟CK_CNT=CK_PSC/(PSC+1)\n计数器CNT在计数器时钟的驱动下开始计数，计数一次的时间为1/CK_CNT,那么他的周期是不是不要再乘上ARR，而我们的计数是从0开始计数的，所以我们ARR还要加一，所以周期是(1/CK_CNT)*(ARR+1)\n\n计数器、自动重装载寄存器:计数器CNT，自动重装载寄存器ARR\n定时器使能(CEN 置 1)后，计数器 CNT在CK_CNT 驱动下计数，当 TCNT 值与 ARR 的设定值相等时就自动生成事件并 CNT 自动清零，然后自动重新开始计数，如此重复以上过程。\n影子寄存器\n\n\n\n\n\n\n\n\n\n\nPSC和ARR都有影子寄存器，功能框图上有个影子\n\n影子寄存器的存在起到一个&#x3D;&#x3D;缓冲的作用&#x3D;&#x3D;，用户值-&gt;寄存器-&gt;影子寄存器-&gt;起作用，如果不使用影子寄存器则用户值在写到寄存器之后则里面起作用。\n&#x3D;&#x3D;ARR影子，TIMx_CR1:APRE位控制&#x3D;&#x3D;\n\n\n定时时间的计算\n\n\n\n\n\n\n\n\n\nPSC &#x3D; 72-1，定时器频率&#x3D;72M&#x2F;(PSC+1)&#x3D;1MHZ     &#x3D;&#x3D;(我来说说为啥PSC要减一加一，首先我们计数是从0开始计数的，所以0也是算一个的，比如我们要计10个数，那么我们计到9就行，计到10就是11个多一个了；PSC+1就是加那个0的计数)&#x3D;&#x3D;\nARR &#x3D; 1000-1，从0计数到999，则计了1000次\n中断周期T &#x3D; 1000 *1&#x2F;1000000 &#x3D; 1mS\n\n时基初始化结构体\n\n\n\n\n\n\n\n\n\n//时基初始化结构体\ntypedef struct\n&#123;\n  //分频因子\n  uint16_t TIM_Prescaler;     \n  //计数模式，基本定时器只能向上\n  uint16_t TIM_CounterMode;  \n  //自动重装载值\n  uint16_t TIM_Period;           \n  //外部输入时钟分频因子，基本定时器没有\n  uint16_t TIM_ClockDivision;     \n  //重复计数器，基本定时器没有，高级定时器专有\n  uint8_t TIM_RepetitionCounter;  \n&#125; TIM_TimeBaseInitTypeDef; \n\n\n\n\n\n\n\n\n\n\n比较一个难受的是C8T6的定时器只有1-4没有基本定时器，导致我在中断源那边一直报错，明明我是在另一个板子上有用，咋C8T6不行了呢，然后查了手册是没有基本定时器的，那么我们WIFI主机就不用基本定时器就用1个高级和3个通用的，那么下面的高级才是高潮部分，上面的基本就是前戏。\n\n\n高级定时器\n\n\n\n\n\n\n\n\n\n时钟源\n\n\n\n\n\n\n\n\n这里先说一下时钟源百分之99用内部的，其他3个基本不用，下面三个当做了解，有地方错了，有点迷糊\n\n\n\n\n\n\n\n\n\n\n内部时钟源CK_INT\n外部时钟模式1—外部的GPIO Tix（x&#x3D;1 2 3 4）\n外部时钟模式2—外部的GPIO ETR\n内部触发输入\n\n内部时钟源\n\n\n\n\n\n\n\n\n\n内部时钟源来自RCC的TIMx_CLK\nTIMx_CLK等于多少呢？如何确定？\n\n\n外部时钟模式1\n\n\n\n\n\n\n\n\n\n时钟信号输入引脚\n\n\n\n\n\n\n\n\n\n外部的GPIO TIx，对应：TIMx_CH1&#x2F;2&#x2F;3&#x2F;4\nTIM_CCMRx 的位 CCxS[1:0]配置，其中 CCMR1 控制 TI1&#x2F;2， CCMR2 控制 TI3&#x2F;4\n\n滤波器\n\n\n\n\n\n\n\n\n\n如果来自外部的时钟信号的频率过高或者混杂有高频干扰信号的话，我们就需要使用滤波器对 ETRP 信号重新采样，来达到降频或者去除高频干扰的目的\n由TIMx_CCMRx 的位 ICxF[3:0]配置\n\n边沿检测\n\n\n\n\n\n\n\n\n\n边沿检测的信号来自于滤波器的输出，在成为触发信号之前，需要进行边沿检测，决定是上升沿有效还是下降沿有效。\n由 TIMx_CCER 的位 CCxP 和 CCxNP 配置\n\n触发选择\n\n\n\n\n\n\n\n\n\n当使用外部时钟模式 1 时，触发源有两个，一个是滤波后的定时器输入 1（ TI1FP1）和滤波后的定时器输入 2（ TI2FP2）\n由 TIMx_SMCR 的位 TS[2:0]配置\n\n使能计数器\n\n\n\n\n\n\n\n\n\n经过上面的 5 个步骤之后， 最后我们只需使能计数器开始计数，外部时钟模式 1 的配置就算完成。\n使能计数器由 TIMx_CR1 的位 CEN 配置。\n\n外部时钟模式2\n\n\n\n\n\n\n\n\n\n时钟信号输入引脚\n\n\n\n\n\n\n\n\n当使用外部时钟模式 2 的时候，时钟信号来自于定时器的特定输入通道 TIMx_ETR，只有 1 个。\n外部触发极性\n\n\n\n\n\n\n\n\n\n来自 ETR 引脚输入的信号可以选择为上升沿或者下降沿有效\n具体的由 TIMx_SMCR的位 ETP 配置\n\n外部触发预分频器\n\n\n\n\n\n\n\n\n\n由于 ETRP 的信号的频率不能超过 TIMx_CLK（ 180M）的 1&#x2F;4，当触发信号的频率很高的情况下，就必须使用分频器来降频\n具体的由 TIMx_SMCR 的位 ETPS[1:0]配置\n\n滤波器\n\n\n\n\n\n\n\n\n\n如果 ETRP 的信号的频率过高或者混杂有高频干扰信号的，需要使用滤波器对 ETRP 信号重新采样，来达到降频或者去除高频干扰的目的\n具体的由 TIMx_SMCR 的位 ETF[3:0]配置，其中的 fDTS 是由内部时钟 CK_INT 分频得到，具体的由 TIMx_CR1 的位CKD[1:0]配置\n\n从模式选择\n\n\n\n\n\n\n\n\n\n经过滤波器滤波的信号连接到 ETRF 引脚后，触发信号成为外部时钟模式 2 的输入，最终等于 CK_PSC，然后驱动计数器 CNT 计数。\n具体的配置 TIMx_SMCR 的位 ECE 为 1即可选择外部时钟模式 2\n\n使能计数器\n\n\n\n\n\n\n\n\n\n经过上面的 5 个步骤之后， 最后我们只需使能计数器开始计数，外部时钟模式 2 的配置就算完成\n使能计数器由 TIMx_CR1 的位 CEN 配置。\n\n内部触发输入\n\n\n\n\n\n\n\n\n\n内部触发输入是使用一个定时器作为另一个定时器的预分频器。硬件上高级控制定时器和通用定时器在内部连接在一起，可以实现定时器同步或级联。\n由TIMx_SMCR 的位 TS[2:0]配置\n\n\n\n控制器\n\n\n\n\n\n\n\n\n\n控制器就是用来控制的，发送命令的\nCR1、CR2、SMCR、CCER，主要学习这几个寄存器即可。\n\n时基单元\n\n\n\n\n\n\n\n\n\n时基单元的组成\n\n\n\n\n\n\n\n\n\n16位的预分频器 PSC，PSC\n16位的计数器CNT， CNT\n8位的重复计数器RCR，RCR（高级定时器独有）\n16位的自动重装载寄存器ARR，ARR\n\n\n\n\n\n输入捕获\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n输入通道\n\n\n\n\n\n\n\n\n当使用需要被测量的信号从定时器的外部引脚 TIMx_CH1&#x2F;2&#x2F;3&#x2F;4 进入，通常叫 TI1&#x2F;2&#x2F;3&#x2F;4，在后面的捕获讲解中对于要被测量的信号我们都以 TIx 为标准叫法。\n输入滤波和边沿检测\n\n\n\n\n\n\n\n\n\n捕获通道\n\n\n\n\n\n\n\n\n\n预分频器\n\n\n\n\n\n\n\n\n\nICx 的输出信号会经过一个预分频器，用于决定发生多少个事件时进行一次捕获。\n具体的由寄存器 CCMRx 的位 ICxPSC 配置，如果希望捕获信号的每一个边沿，则不分频。\n\n捕获寄存器\n\n\n\n\n\n\n\n\n\n输出比较\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n输出比较寄存器\n\n\n\n\n\n\n\n\n\n死区发生器\n\n\n\n\n\n\n\n\n\n带死区插入的半桥驱动电路\n\n\n\n\n\n\n\n\n\n带死区插入的互补输出波形图\n\n\n\n\n\n\n\n\n\n输出控制\n\n\n\n\n\n\n\n\n\n输出引脚\n\n\n\n\n\n\n\n\n\n输入捕获的应用\n\n\n\n\n\n\n\n\n测量脉宽和频率\n\nPWM输入模式\n\n\n\n输出比较模式总共有 8 种，常用的是PWM模式。\n由寄存器 CCMRx 的位 OCxM[2:0]配置。\n\n\n\n代码\n\n\n\n\n\n\n\n\n首先我们选好脚，这里我们用高级定时器\nPWM互补输出实验，带死区时间，带刹车控制\n\n\n\n\n\n\n\n\n互补需要两个脚，死区可以软件配置，刹车还需要一个脚。我们只能用高级定时器1了，没有8\n\n\n二级标题三级标题四级标题五级标题六级标题","slug":"wifi主机/wifi主机第一部分  催眠师手札","date":"2020-08-15T10:49:36.000Z","categories_index":"单片机","tags_index":"STM32,主机","author_index":"虫子"},{"id":"199547ff1b7fb284f5e822193d2b7a56","title":"保护模式","content":"保护模式x86 CPU的三种模式x86 CPU有3种模式：实模式、保护模式和虚拟8086模式\n现在的操作系统大多都是处于保护模式下\n\n\n\n\n实模式\n保护模式\n虚拟8086模式\n\n\n\n内存寻址方式\n段式寻址\n支持内存分页和虚拟内存\n段式寻址\n\n\n寻址范围\n任意寻址\n有限\n任意寻址\n\n\n举例系统\ndos系统\nWindows系统\n？\n\n\n上面只是简单列举了三种模式的一些区别，具体细节不作深入\n只需要明确一点：保护模式相比于其它两种模式，根本在于进程内存受到了保护\n\nx86和x64想必不少人会疑问，现在大多数计算机都是x64的了，为什么还在讲x86？\n因为x64是向下兼容x86的\n\nx86：由Intel推出的一种复杂指令集,能够生产支持这种指令集CPU公司主要是Intel和AMD\nx64：AMD在1999年的时候，拓展了这套指令集，称为x86-64,后改名为AMD64,Intel也兼容了这个产品，称为Intel 64.但AMD64和Intel64，几乎是一样的，所以在很多资料中统称为x64\n\n\n什么是保护模式保护模式是基于安全性和稳定性的考量而产生的一种CPU模式\n\n保护模式的两大特点前面说过保护模式区别于其它两种模式的根本是在进程内存上\n所以保护模式的两大特点也是基于内存的：\n\n段的机制（内存分段）\n页的机制（内存分页）\n\n\n为什么要学习保护模式因为现在的Window系统都是基于保护模式运作的\n所以学习保护模式后才能真正地理解内核是如何运作的\n并且通过保护模式的知识，可以实现 提权操作（在应用层做到内核层才能做的事）\n不了解保护模式，就相当于写的程序不过是在调用WinAPI而已：在应用层(ring3)调用应用层API，在内核层(ring0)调用内核层API\n并且由于保护模式对进程内存的保护，在学习它之后，能够对内存有进一步的认识\n\n参考书籍英特尔®64和IA-32体系结构软件开发人员手册合并卷\n详细说明本文档包含以下内容：\n第1卷：介绍支持IA-32和Intel®64体系结构的处理器的体系结构和编程环境。\n第2卷：包括完整的指令集参考AZ。描述说明的格式，并提供说明的参考页。\n第3卷：包括完整的系统编程指南，第1、2、3和4部分。描述了Intel®64和IA-32体系结构的操作系统支持环境，包括：内存管理，保护，任务管理，中断和异常处理，多处理器支持，热和电源管理功能，调试，性能监控，系统管理模式，虚拟机扩展（VMX）指令，英特尔®虚拟化技术（英特尔®VT）和英特尔®软件保护扩展（英特尔®SGX） ）。\n第4卷：描述了支持IA-32和Intel®64体系结构的处理器的特定于模型的寄存器。\n","slug":"保护模式介绍","date":"2020-08-15T10:49:36.000Z","categories_index":"Cate","tags_index":"Tag","author_index":"虫子"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"调用门调用门的作用调用门可以用来提权，通过提权可以实现访问高地址空间等RING0（内核）层才能进行的操作\n\n调用门和长调用关系回顾先前的笔记可知：\n长调用CALL FAR CS:EIP指令要调用的地址是由CS段选择子查GDT得到的调用门 段描述符得来的，后面的EIP不发挥作用\n\n调用门执行流程\n根据CS的值 查GDT，找到对应的段描述符 这个描述符是一个调用门\n在调用门描述符中存储另一个代码段的选择子\n选择子指向的段 段.Base + 偏移地址 就是真正要执行的地址\n\n\n调用门描述符对比段描述符\n\n调用门描述符结构\n\n当一个段描述符是一个调用门描述符时，有以下特征：\n\nS位为0，表示该段描述符为系统段描述符（调用门描述符属于系统段描述符）\nType域为1100，表示该段描述符为32位调用门\n低16位到31位由原本的基地址变为存储一个段选择子，该段选择子才和代码真正要调用的地址相关\n真正要调用的地址 &#x3D; 段选择子所指向的段.Base + 32位的段中偏移 （段中偏移分为两部分：高位31-16位和低位15-0位）\n段.Base默认为0，故真正要调用的地址 &#x3D; 32位的段中偏移\n\n\n给出段描述符和调用门描述符各部分的对比（上半部分为段描述符，下半部分为调用门描述符）：\n\n\n\n数据位\n31-24\n23\n22\n21\n20\n19-16\n15\n14-13\n12\n11-8\n7-0\n\n\n\n\n含义\nBase\nG\nD&#x2F;B\n0\nAVL\nSeg.Limit\nP\nDPL\nS\nType\nBase\n\n\n\n解释\n基地址\n粒度\n默认操作大小\n固定为0\n用于系统软件使用\n段大小限制\n有效位\n特权等级\n描述符类型\n段类型\n基地址\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n数据位\n31-16\n\n\n\n\n\n15\n14-13\n12\n11-8\n7-5\n4-0\n\n\n含义\noffset\n\n\n\n\n\nP\nDPL\nS\nType\n无\nparam.count\n\n\n解释\n段中偏移\n\n\n\n\n\n有效位\n特权等级\n值为0\n值为1100\n值为000\n参数计数\n\n\n\n\n\n\n数据位\n31-16\n15-0\n\n\n\n含义\nBase Adress\nSegment Limit\n\n\n解释\n基地址\n段大小限制\n\n\n\n\n\n\n\n数据位\n31-16\n15-0\n\n\n含义\nselector\noffset\n\n\n解释\n段选择子\n段中偏移\n\n\n\n构造无参调用门描述符了解了调用门描述符的结构后，尝试自己构造一个无参的调用门描述符，如下：\n\n\n\n数据位\n31-16\n\n\n\n\n\n15\n14-13\n12\n11-8\n7-5\n4-0\n\n\n\n含义\noffset\n\n\n\n\n\nP\nDPL\nS\nType\n无\nparam\n\n\n解释\n段中偏移\n\n\n\n\n\n有效位\n特权等级\n值为0\n值为1100\n值为000\n参数\n\n\n值（二进制）\n0\n\n\n\n\n\n1\n11\n0\n1100\n000\n0000\n\n\n\n\n\n数据位\n31-16\n15-0\n\n\n\n含义\nselector\noffset\n\n\n解释\n段选择子\n段中偏移\n\n\n值（十六进制）\n0x0008\n0\n\n\n得到调用门描述符为：0000EC00&#96;00080000\n段中偏移暂时不明确要调用的代码段，先置0\n\n示例代码接下来给出一段演示代码：\n 复制代码 隐藏代码#include &lt;Windows.h&gt;\n#include &lt;stdio.h&gt;\n\n __declspec(naked) void callGate()&#123;\n         _asm&#123;\n                 int 3                                &#x2F;&#x2F;软中断\n                 retf                                &#x2F;&#x2F;注意这里长调用对应长返回\n         &#125;\n &#125;\n\nint main()&#123;\n\n        char buff[6];\n        &#x2F;&#x2F;*(DWORD*)&amp;buff[0]&#x3D; 0x12345678;        &#x2F;&#x2F;低地址32位为0x12345678，EIP已废弃，故随便填即可\n        &#x2F;&#x2F;*(DWORD*)&amp;buff[4]&#x3D;0x48;                        &#x2F;&#x2F;高地址16位为0x48，段选择子\n\n        &#x2F;&#x2F;也可以换作这种写法\n        _asm&#123;\n                mov dword ptr ds:[buff],0x12345678        &#x2F;&#x2F;低32位赋值废弃EIP\n                lea eax,dword ptr ds:[buff]                        &#x2F;&#x2F;将buff地址给EAX\n                add eax,4                                                        &#x2F;&#x2F;地址+4，即得到高地址\n                mov word ptr ds:[eax],0x48                        &#x2F;&#x2F;高16位赋值段选择子selector\n        &#125;\n\n        &#x2F;&#x2F;使用 调用门\n        _asm&#123;\n                call fword ptr ds:[buff]                        &#x2F;&#x2F;fword 数据宽度为6字节\n        &#125;\n        return 0;\n&#125;\n\n代码说明代码十分简单，主要分为两部分：\n\ncallGate：调用门真正要调用的函数，先软中断，然后长返回\nmain：先构造一个CS:EIP，这里为0x48:0x12345678，然后使用调用门\n\n\n关于构造CS:EIP，可以观察到赋值后buff在内存中的存储情况：\n\n可以看到CS:EIP在内存中由高地址到低地址存储，为0x004812345678\n\n将门描述符写入GDT在代码中，CS的也就是段选择子的值为0x48，该选择子指向的GDT的地址为要写入的地址\n关于Selector和GDT地址的对应关系在保护模式笔记三 段描述符和段选择子中已经说明过了，这里不再赘述\n\n确定门描述符在写入GDT前，还需要确定要写入的值，前面已经构造好了的门描述符为：0x0000EC00&#96;00080000\n但其段中偏移还未确定，于是使用VC++ 6.0查看要调用的代码的地址：\n进入debug模式，中断后，选中callGate函数，然后右键→Go to Disassembly（查看反汇编）\n\n\n\n可以得到要调用的函数的地址为0x00401020\n\n将得到的要调用的函数地址填入门描述符中对应的offset得到：\n\n原：0000EC00&#96;00080000\n现：0040EC00&#96;00081020\n\n\n于是得到确定的门描述符为0040EC00&#96;00081020\n\n写入门描述符确定完门描述符和要写入的地址后，就可以将其写入GDT了，操作如下：\n指令如下：\n 复制代码 隐藏代码r gdtr                                查看gdtr\ndq 0x8003f000                以qword查看地址，这里的地址为上面得到的gdtr地址\neq 8003f048 0040EC00&#96;00081020                写入门描述符\ndq 0x8003f000                查看是否写入成功\n\n\n过程图如下：\n\n\n执行代码执行代码结果如下：\nWindbg获取到了代码中的int 3断点\n\n可以看到此时中断的地址正是门描述符中的偏移地址（要调用的地址 &#x3D; 段.Base+Offset，Base默认为0，故要调用的地址就直接等于门描述符中的offset）\n\n原本的Ring3（应用）层的int 3断点不会被Windbg所捕获，但这里通过门描述符提权后变为了Ring0（内核层）权限，故会引起Windbg的捕获\n可以查看此时的寄存器情况：\n 复制代码 隐藏代码\nr\n\n\n此时的CS正是前面构造的门描述符中的selector（选择子）\n\n接下来继续单步执行\n 复制代码 隐藏代码\nt\n\n\n可以看到int 3的下一行代码位retf，也就是callGate函数里的代码中的下一行，由此可以确定调用成功\n\n对比执行前后寄存器前面只提到了CS段寄存器的变化，现在来总览对比执行前后寄存器的变化：\n执行前寄存器情况在使用调用门的汇编语句处下断点，断下后得到：\n\n\n得到此时的寄存器情况：\n\n\n\n寄存器\n值\n\n\n\nESP\n12FF2C\n\n\nEBP\n12FF80\n\n\nCS\n1B\n\n\nDS\n23\n\n\nES\n23\n\n\nSS\n23\n\n\nFS\n3B\n\n\nGS\n0\n\n\n\n执行后寄存器情况\n\n\n得到此时的寄存器情况：\n\n\n\n寄存器\n值\n\n\n\nESP\nB1026DD0\n\n\nEBP\n12FF80\n\n\nCS\n08\n\n\nDS\n23\n\n\nES\n23\n\n\nSS\n10\n\n\nFS\n30\n\n\nGS\n0\n\n\n\n变化对比\n\n\n寄存器\n执行前值\n执行后值\n是否变化\n\n\n\nESP\n12FF2C\nB1026DD0\n√\n\n\nEBP\n12FF80\n12FF80\n×\n\n\nCS\n1B\n08\n√\n\n\nDS\n23\n23\n×\n\n\nES\n23\n23\n×\n\n\nSS\n23\n10\n√\n\n\nFS\n3B\n30\n√\n\n\nGS\n0\n0\n×\n\n\n可以得出变化的寄存器有：ESP、CS、SS、FS\n通过调用门提权后，前后寄存器的变化涉及到TSS，这里先记录下变化，具体细节留作之后\n\n构造有参调用门描述符示例代码 复制代码 隐藏代码#include &lt;Windows.h&gt;\n#include &lt;stdio.h&gt;\n\nint a,b,c;\n\n __declspec(naked) void callGate()&#123;\n         _asm&#123;\n                pushad                                                        &#x2F;&#x2F;将所有32位通用寄存器压入堆栈\n        pushfd                                                        &#x2F;&#x2F;将32位标志寄存器EFLFAGS压入堆栈\n        &#x2F;&#x2F;关于为何是通过ESP+XXX寻址详见后续的堆栈情况说明\n                mov eax,[esp+0x24+0x8+0x8]                &#x2F;&#x2F;从堆栈中取出第一个参数\n                mov dword ptr ds:[a],eax                &#x2F;&#x2F;将取出的参数赋值给全局变量a\n                mov eax,[esp+0x24+0x8+0x4]                &#x2F;&#x2F;从堆栈中取出第二个参数\n                mov dword ptr ds:[b],eax                &#x2F;&#x2F;将取出的参数赋值给全局变量b\n        mov eax,[esp+0x24+8+0]                        &#x2F;&#x2F;从堆栈中取出第三个参数\n                mov dword ptr ds:[c],eax                &#x2F;&#x2F;将取出的参数赋值给全局变量c\n                popfd                                                        &#x2F;&#x2F;将所有32位通用寄存器出栈\n                popad                                                        &#x2F;&#x2F;将所有32位标志寄存器EFLFAGS出栈\n                retf 0xC&#x2F;&#x2F;注意这里长调用对应长返回，堆栈平衡 0xC&#x3D;12&#x3D;3*4&#x3D;参数个数*参数的数据宽度（单位字节）\n         &#125;\n &#125;\n\nint main()&#123;\n\n        char buff[6];\n        &#x2F;&#x2F;*(DWORD*)&amp;buff[0]&#x3D; 0x12345678;        &#x2F;&#x2F;低地址32位为0x12345678，EIP已废弃，故随便填即可\n        &#x2F;&#x2F;*(DWORD*)&amp;buff[4]&#x3D;0x48;                        &#x2F;&#x2F;高地址16位为0x48，段选择子\n\n        &#x2F;&#x2F;也可以换作这种写法\n        _asm&#123;\n                mov dword ptr ds:[buff],0x12345678        &#x2F;&#x2F;低32位赋值废弃EIP\n                lea eax,dword ptr ds:[buff]                        &#x2F;&#x2F;将buff地址给EAX\n                add eax,4                                                        &#x2F;&#x2F;地址+4，即得到高地址\n                mov word ptr ds:[eax],0x48                        &#x2F;&#x2F;高16位赋值段选择子selector\n        &#125;\n\n        &#x2F;&#x2F;使用 调用门\n        _asm&#123;\n                push 1\n                push 2\n                push 3\n                call fword ptr ds:[buff]                        &#x2F;&#x2F;fword 数据宽度为6字节\n        &#125;\n        printf(&quot;%X\\t%X\\t%X\\n&quot;,a,b,c);\n        return 0;\n&#125;\n\n\n代码说明与构造无参调用门描述符相比，主要变化为：\n\n在使用调用门前压入了三个参数：1、2、3\n调用代码作用为：①保护现场（压入所有通用寄存器和标志寄存器）；②从堆栈中取出对应的参数；③将取出的参数赋值给对应的全局变量\n调用代码最后要平衡堆栈，ret 0xC      0xC&#x3D;12&#x3D;34&#x3D;参数个数参数的数据宽度（单位字节）\n在调用结束后，输出调用后被赋值的全局变量，验证参数是否成功传递\n\n\n堆栈情况说明堆栈调用情况按执行流程顺序依次说明：\n执行前(压入参数后)\n记录下此时的堆栈情况：\n\n\n\n地址\n相对栈顶地址\n值\n说明\n\n\n\n0012FF20\nESP\n3\n压入的第三个参数\n\n\n0012FF24\nESP+4\n2\n压入的第二个参数\n\n\n0012FF28\nESP+8\n1\n压入的第一个参数\n\n\n\n切换到调用代码后\n记录下此时的堆栈情况：\n\n\n\n地址\n相对栈顶地址\n值\n说明\n\n\n\nB9CAFDC4\nESP\n0040D4E8\n执行后要返回的地址\n\n\nB9CAFDC8\nESP+0x4\n1B\n执行后要恢复的段选择子:CS\n\n\nB9CAFDCC\nESP+0x8\n3\n压入的第三个参数\n\n\nB9CAFDD0\nESP+0xC\n2\n压入的第二个参数\n\n\nB9CAFDD4\nESP+0x10\n1\n压入的第一个参数\n\n\nB9CAFDD8\nESP+0x14\n0012FF20\n执行后要恢复的堆栈寄存器:ESP\n\n\nB9CAFDDC\nESP+0x18\n23\n执行后要恢复的段选择子:SS\n\n\n\n保存通用寄存器组后\n记录下此时的堆栈情况：\n\n\n\n地址\n相对栈顶地址\n值\n说明\n\n\n\nB9CAFDA4～B9CAFDC0\nESP～ESP+0x1C\n略\n通用寄存器组\n\n\nB9CAFDC4\nESP+0x20\n0040D4E8\n执行后要返回的地址\n\n\nB9CAFDC8\nESP+0x20+0x4\n1B\n执行后要恢复的段选择子:CS\n\n\nB9CAFDCC\nESP+0x20+0x8\n3\n压入的第三个参数\n\n\nB9CAFDD0\nESP+0x20+0xC\n2\n压入的第二个参数\n\n\nB9CAFDD4\nESP+0x20+0x10\n1\n压入的第一个参数\n\n\nB9CAFDD8\nESP+0x20+0x14\n0012FF20\n执行后要恢复的堆栈寄存器:ESP\n\n\nB9CAFDDC\nESP+0x20+0x18\n23\n执行后要恢复的段选择子:SS\n\n\n\n保存标志寄存器后\n记录下此时的堆栈情况：\n\n\n\n地址\n相对栈顶地址\n值\n说明\n\n\n\nB9CAFDA0\nESP\n0x202\n标志寄存器\n\n\nB9CAFDA4～B9CAFDC0\nESP+0x4～ESP+0x4+0x1C\n略\n通用寄存器组\n\n\nB9CAFDC4\nESP+0x4+0x20\n0040D4E8\n执行后要返回的地址\n\n\nB9CAFDC8\nESP+0x4+0x20+0x4\n1B\n执行后要恢复的段选择子:CS\n\n\nB9CAFDCC\nESP+0x4+0x20+0x8\n3\n压入的第三个参数\n\n\nB9CAFDD0\nESP+0x4+0x20+0xC\n2\n压入的第二个参数\n\n\nB9CAFDD4\nESP+0x4+0x20+0x10\n1\n压入的第一个参数\n\n\nB9CAFDD8\nESP+0x4+0x20+0x14\n0012FF20\n执行后要恢复的堆栈寄存器:ESP\n\n\nB9CAFDDC\nESP+0x4+0x20+0x18\n23\n执行后要恢复的段选择子:SS\n\n\n\n将门描述符写入GDT确定门描述符先确定段中偏移：进入debug模式，中断后，选中callGate函数，然后右键→Go to Disassembly（查看反汇编）\n\n\n\n可以得到要调用的函数的地址为0x0040D480\n\n将得到的要调用的函数地址填入门描述符中对应的offset得到：\n\n原：0000EC00&#96;00080000\n现：0040EC00&#96;0008D480\n\n因为此次调用门描述符需要传递三个参数，故修改为：\n0040EC03&#96;0008D480\nPS：修改了门描述符结构中的param.count，如不熟悉可回顾上面的 调用门描述符结构\n\n于是得到确定的门描述符为0040EC03&#96;0008D480\n\n写入门描述符确定完门描述符和要写入的地址后，就可以将其写入GDT了，操作如下：\n指令如下：\n 复制代码 隐藏代码r gdtr                                查看gdtr\ndq 8003f000                以qword查看地址，这里的地址为上面得到的gdtr地址\neq 8003f048 0040EC03&#96;0008D480                写入门描述符\ndq 8003f000                查看是否写入成功\n\n\n过程图如下：\n\n\n执行代码执行代码结果如下：\n\n代码执行后，能够正确地输出三个参数，构造有参调用门描述符成功\n\n总结\n当通过门，权限不变的时候，只会PUSH两个值：①CS（新的CS的值由调用门决定） ；②返回地址\n当通过门，权限改变的时候，会PUSH四个值：①SS；② ESP；③ CS ；④ 返回地址  （新的CS的值由调用门决定 新的SS和ESP由TSS提供）\n通过门调用时，要执行代码的地址由调用门中的选择子决定；使用RETF返回时，由堆栈中压入的返回地址决定\n\n\n关于TSS的内容留作之后的笔记(*￣3￣)╭PS：写得比较匆忙，可能会有谬误之处，欢迎指出\n","slug":"调用门提权（无参+有参）","date":"2022-12-14T07:19:32.629Z","categories_index":"","tags_index":"","author_index":"虫子"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"段权限检查CPU权限分级在补充段权限检查之前，要了解CPU的权限分级\n\n\n处理器的段保护机制定义了RING0,RING1,RING2,RING3一共4个特权级别\n大多数现代操作系统将0级用于内核&#x2F;可执行程序，将3级用于应用程序\n可用于级别n的任何资源也可用于级别0到n，因此特权级别是环\n当特权较低的进程尝试访问特权较高的进程时，将向操作系统报告常规保护错误异常\n8086中的实模式程序在级别0（最高特权级别）上执行，而8086中的虚拟模式在级别3执行所有程序\n多数现代x86内核仅使用两个特权级别，即RING0和RING3\n\n\n\n\n\n\nRING0\nRING1\nRING2\nRING3\n\n\n\n通常用途\n内核\n特权代码、特权数据、特权栈\n特权代码、特权数据、特权栈\n应用程序\n\n\n级别\n最高\n第二高\n第三高\n最低\n\n\n对应层\n内核层（内核态）\n\n\n应用层（用户态）\n\n\n\n内核层在内核模式下，CPU可以执行其体系结构允许的任何操作。可以执行任何指令，启动任何I &#x2F; O操作，访问任何内存区域，使用特权指令，控制中断、修改页表、访问设备等等\n应用层硬件会对CPU操作施加某些限制。通常，某些指令是不允许的（尤其是那些指令（包括I &#x2F; O操作）可能会改变机器的全局状态），某些内存区域无法访问等。CPU的用户模式功能通常是这些指令的子集可以在内核模式下使用，但是在某些情况下，例如非本机体系结构的硬件仿真，它们可能与标准内核模式下的可用软件有显着差异\n\n应用层切换内核层应用程序的代码运行在最低运行级别上ring3上，不能做受限操作\n如果要做受限操作，比如要访问磁盘，写文件，那就要通过执行系统调用（函数），执行系统调用的时候，CPU的运行级别会发生从ring3到ring0的切换，并跳转到系统调用对应的内核代码位置执行，这样内核就为你完成了设备访问，完成之后再从ring0返回ring3。这个过程也称作用户态和内核态的切换\n\nCPU权限分级的作用RING设计的初衷是将系统权限与程序分离出来，使之能够让OS更好的管理当前系统资源，也使得系统更加稳定\n举个很常见的例子：\n普通的应用程序崩溃一般是程序未响应或者停止运行，并不会影响系统的正常运行\n但当驱动程序出现问题后，动辄 BSOD（蓝屏死机）\n\n判断程序特权级别了解了CPU的权限分级后，再来了解 如何查看程序处于几环\n这涉及到了CPL(Current Privilege Level) ：当前特权级别\nCPL是段寄存器CS和SS的段选择子的后两位\n在保护模式笔记三 段描述符和段选择子中已经说明了段选择子的结构\n\n\n\n\nIndex\nTI\nRPL\n\n\n\n含义\n索引\n表指示器\n请求特权等级\n\n\n全称\nIndex\nTable Indicator\nRequested Privilege Level\n\n\n数据宽度\n13位\n1位\n2位\n\n\n对比可知，当段寄存器为CS和SS时，其段选择子的RPL就是CPL\n\n通过OD附加应用程序后查看其段寄存器：\n\n\n\n\n\n段寄存器\n段选择子(Selector)\n二进制段选择子\n二进制RPL\n十进制RPL\n\n\n\nES\n23\n0010 0011\n11\n3\n\n\nCS\n1B\n0001 1011\n11（CPL）\n3（CPL）\n\n\nSS\n23\n0010 0011\n11（CPL）\n3（CPL）\n\n\nDS\n23\n0010 0011\n11\n3\n\n\nFS\n3B\n0011 1011\n11\n3\n\n\n根据CS和SS的段选择子可以得到CPL为3，印证了应用程序的CPU权限分级为RING3\n\nEPL(有效特权级别)上面提到了CPL（当前特权级别）和RPL（请求特权级别）\n所谓的有效特权级别EPL(Effective Privilege Level)，顾名思义就是最终的确定可否执行的特权\nEPL &#x3D; max(RPL,CPL)\n即 EPL 等于 RPL和CPL的最大值，EPL为RPL和CPL中较低的权限\n\nDPL(描述符特权级别)关于DPL，在保护模式笔记四 段描述符结构中已经略微说明了，现在展开细说\nDPL的作用DPL存储在段描述符中，规定了访问该段所需要的特权级别是什么；即 如果想要加载某个段描述符，就必须具备对应的特权级别\nDPL权限检查当加载一个段描述符时，首先CPU要判断其P位（有效位），如果该段描述符有效，则继续进行DPL权限检查\n所谓的DPL权限检查 就是 判断 DPL是否满足：EPL&#x3D;max(RPL,CPL)&lt;&#x3D;DPL是否成立\n只有当EPL&lt;&#x3D;DPL时，权限检查才通过，段描述符才能够被加载到段寄存器中\n\n\n\nRPL\nCPL\nEPL\nDPL\n权限检查是否通过\n\n\n\n0\n0\n0\n0\n√\n\n\n0\n0\n0\n3\n√\n\n\n0\n3\n3\n0\n×\n\n\n0\n3\n3\n3\n√\n\n\n3\n0\n3\n0\n×\n\n\n3\n0\n3\n3\n√\n\n\n3\n3\n3\n0\n×\n\n\n3\n3\n3\n3\n√\n\n\n\n总结\n\n\n\nRPL\nCPL\nEPL\nDPL\n\n\n\n含义\n请求特权级别\n当前特权级别\n有效特权级别\n描述符特权级别\n\n\n说明\n用什么权限去访问一个段\nCPU当权的权限级别\nmax(RPL,CPL)\n访问该段所需要的特权级别\n\n\n","slug":"段权限检查","date":"2022-12-14T07:19:32.621Z","categories_index":"","tags_index":"","author_index":"虫子"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"段描述符引出问题首先要解决的就是上个笔记遗留下来的问题：\n 复制代码 隐藏代码mov bx,ds                &#x2F;&#x2F;将段寄存器ds的Selector部分保存到bx（ecx的低16位）\nmov ax,cs                &#x2F;&#x2F;将段寄存器cs的Selector部分保存到ax（eax的低16位）\nmov ds,ax                &#x2F;&#x2F;将先前读出来的段寄存器去写ds这个段寄存器，也就是用cs段寄存器覆盖ds段寄存器\n\n写寄存器是对整个96位的段寄存器进行修改，但是这里只给出了16位的段选择子Selector，剩下的80位呢\n\n在回答问题之前，还需要了解两个结构：GDT（全局描述符表）和 LDT（局部描述符表）\n为什么要了解这两张表？\n因为当执行类似前面对段寄存器进行修改的指令：MOV DS,AX时，CPU会先查表，根据AX的值（段选择子）来决定查找GDT还是LDT\n但在Windows中LDT并没有被使用，于是AX的值(段选择子)是用来决定查询表中的哪个位置\n\nGDT什么是GDTGDT全称：Global Descriptor Table，为全局描述符表，表中存储的数据项为段描述符\n\nGDT的数量一个处理器对应一个GDT\n\n定位GDT大致了解了GDT是一张表，接下来则要定位到这张表，查看其内容\n想要定位GDT表的位置，可以通过gdtr寄存器来定位\ngdtr寄存器存储了GDT表的起始位置和GDT表的大小\n\n通过windbg定位GDT通过在windbg中输入下列指令查看有关GDT的信息：\n 复制代码 隐藏代码r gdtr      &#x2F;&#x2F;读取gdt表的起始位置\nr gdtl      &#x2F;&#x2F;读取gdt表的大小\n\n\n\n\n得到了：\n\n\n\n\nGDT表的起始位置\nGDT表的大小\n\n\n\n值\n0x8003f000\n0x3ff\n\n\n数据宽度\nDWORD(4字节)\nWORD(2字节)\n\n\n\n得到了GDT表的起始位置后，就可以查看GDT表的内容了：\n 复制代码 隐藏代码\ndq 0x8003f000\n\n\n\n段描述符知道了查询的表为GDT后，再说说GDT表存储的数据项：段描述符\n\n什么是段描述符段描述符顾名思义就是用来描述段的信息的，每个段对应一个段描述符\n\n段描述符的数据宽度每个段描述符的数据宽度为：64位&#x3D;8字节（QWORD）\n\n定位段描述符通过段选择子可以定位到对应的段描述符\n如何定位，则要先了解段选择子的结构\n\n段选择子什么是段选择子段选择子顾名思义就是用来选择段的，通过段选择子可以定位到对应的段描述符\n\n段选择子的结构\n\n\n\n\n\nIndex\nTI\nRPL\n\n\n\n含义\n索引\n表指示器\n请求特权等级\n\n\n全称\nIndex\nTable Indicator\nRequested Privilege Level\n\n\n数据宽度\n13位\n1位\n2位\n\n\n\nIndex索引，真正用来索引段描述符的数据\n\nTI表指示器，用来确定选择GDT（全局描述符表）还是LDT（局部描述符表）\n\n\n\n\nTI&#x3D;&#x3D;0\nTI&#x3D;&#x3D;1\n\n\n\n选择的表\nGDT\nLDT\n\n\n在Windows上并不使用LDT表，故TI恒等于0\n\nRPL请求的特权等级，会和请求的段描述符的特权等级进行比较，留作后续补充说明\n\n根据段选择子定位段描述符了解了段选择子的结构后，就可以通过段选择子来定位段描述符了\n例子：以段选择子 &#x3D; 0x001B为例\n首先将段选择子转换为二进制 ： 0000 0000 0001 1011\n将其按段选择子的结构填入：\n\n\n\n\nIndex\nTI\nRPL\n\n\n\n二进制值\n0000 0000 0001 1\n0\n11\n\n\n十进制值\n3\n0\n3\n\n\n含义\n索引为3\n查询GDT表\n请求特权等级为3\n\n\n得到的索引为3\n拿到索引之后就可以定位对应的段描述符了\n对应的段描述符地址 &#x3D; GDT表首地址 + 索引× 段描述符长度 &#x3D; GDT表首地址 + 索引 × 8（注意这里的单位为字节，64位&#x3D;8字节）\n所以：对应的段描述符地址 &#x3D; 0x8003f000 + 3×8&#x3D; 0x8003f000 + 24 &#x3D; 0x8003f000 + 0x18 &#x3D; 0x8003f018\n\n\n加载段描述符至段寄存器除了MOV指令，还可以使用LES、LSS、LDS、LFS、LGS指令修改寄存器.\nCS不能通过上述的指令进行修改，CS为代码段，CS的改变会导致EIP的改变，要改CS，必须要保证CS与EIP一起改，在后续的笔记会提到\n\n下面以lds为例子，观察指令执行前后寄存器的变化\n 复制代码 隐藏代码#include &lt;stdio.h&gt;\n#include &lt;windows.h&gt;\n\nchar buffer[6]&#x3D;&#123;0x44,0x33,0x22,0x11,0x1B,0x00&#125;;\n\nint main()&#123;\n\n    _asm&#123;\n        push ds\n        lds eax,fword ptr ds:[buffer]   &#x2F;&#x2F;fword为6字节\n        pop ds\n\n    &#125;\n        return 0;\n&#125;\n\n\n下断点观察\n\n执行前\n\n执行后\n\n对比执行前后\n\n\n\nEAX\nDS\n\n\n\n执行前\n0xCCCCCCCC\n0x23\n\n\n执行后\n0x11223344\n0x1B\n\n\n\n得出指令功能LDS指令格式为：LDS OPRD1,OPRD2\nOPRD1用来接收OPRD2的低(OPRD-2)字节\nOPRD2的高2字节为段选择子，通过段选择子修改DS\n其它指令：LES、LSS、LFS、LGS也是一样的格式，只不过修改的段寄存器不同罢了\n\n内存寻址关系一览图下面给出内存寻址的流程中，GDT、段描述符、段选择子的关系图：\n\n\n以MOV EAX,DWORD PTR DS:[0x123456]为例\n根据DS获得Segment Selector（段选择子）：0x23（在 保护模式笔记二 段寄存器中获得的，不同机器可能不同）\n根据地址获得Offset(偏移)：0x123456\n然后通过段选择子查询GDT（全局描述符表）得到对应的Segment Descriptor（段描述符）\n通过段描述符可以得到Base（基地址）&#x3D; 0 （DS段寄存器的Base为0）\n最终要访问的内存地址为：Base+Offset &#x3D; 0+0x123456&#x3D;0x123456（期间也会根据段描述符进行一系列校验，这里暂且不提）\n\n说明该篇笔记主要介绍了如何通过段选择子定位到对应的段描述符并补充了段选择子的结构和修改段寄存器的指令\n但关于段描述符的结构还没有深入介绍\n前面引出的问题也尚未完全解决，通过前面的学习得知段寄存器剩下的80位是通过段描述符来填充的\n但是段描述符的长度只有64位，如何填充80位？\n这些都留作之后的笔记再作说明(づ￣ 3￣)づ\n","slug":"段描述符和段选择子","date":"2022-12-14T07:19:32.617Z","categories_index":"","tags_index":"","author_index":"虫子"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"段寄存器什么是段寄存器在先前的逆向基础笔记五 标志寄存器中，有提到过段寄存器的概念\n当使用汇编来操作一个内存地址时，就会涉及到段寄存器，只不过先前并没有太过在意\n如：\n 复制代码 隐藏代码\nmov dword ptr ds:[0x123456],eax\n\n注意汇编语句中的 ds，它就是一个段寄存器\n实际上真正读取的内存地址为：ds.base+0x123456\n\n段寄存器有哪些段寄存器共8个： CS DS ES SS FS GS LDTR TR\nCS代码段寄存器，用于存放代码段的段基址\nDS数据段寄存器，用于存放数据段的段基址\nES附加段寄存器，用于存放附加段的段基址\nSS堆栈段寄存器，用于存放堆栈段的段基址，指示堆栈段区域的位置\nFS附加段寄存器，F为上一个附加段寄存器字母E后的字母，没有对应的名称\n指向一种被称为线程信息块（TIB）的结构，这种结构是由内核在创建线程时创建的，用于支持操作系统相关功能、服务和API\nGS附加段寄存器，G为上一个附加段寄存器字母F后的字母，没有对应的名称\n在32位Windows上GS保留供将来使用\n在x64模式下，FS和GS段寄存器已交换\nWin64使用GS的原因是该FS寄存器用于32位兼容性层（称为Wow64）\n32位应用程序永远不会导致GS更改，而64位应用程序永远不会导致FS更改\n注意，在Win64和Wow64中GS是非零的，这可以用来检测一个32位应用程序是否在64位Windows中运行，在一个“真正“的32位Windows中GS总是零\nIDTR中断描述符表寄存器，用于存放中断描述符表IDT的32位线性基地址和16位表长度值\nTR任务寄存器，用于存放当前任务TSS段的16位段选择符、32位基地址、16位段长度和描述符属性值\n\n段寄存器的结构\n\n\n组成\nBase\nLimit\nAttribute\nSelector\n\n\n\n数据宽度\n32位\n32位\n16位\n16位\n\n\n是否可见\n不可见\n不可见\n不可见\n可见\n\n\n描述\n基地址（当前段的起始地址）\n大小限制（当前段的整个长度）\n属性（当前段是否可读可写可执行）\n段选择子\n\n\n\n 复制代码 隐藏代码struct Segment&#123;\n    WORD Selector;\n    WORD Attribute;\n    DWORD Base;\n    DWORD Limit;\n&#125;\n\n\n段寄存器的属性拿OD随便载入一个程序，观察寄存器窗口：\n\n得到了当前的计算机的段寄存器信息（不同计算机段寄存器信息不一定相同）\n\n\n\n\n段寄存器\nSelector\nAttribute\nBase\nLimit\n\n\n\nES\n0023\n可读、可写\n0\n0xFFFFFFFF\n\n\nCS\n001B\n可读、可执行\n0\n0xFFFFFFFF\n\n\nSS\n0023\n可读、可写\n0\n0xFFFFFFFF\n\n\nDS\n0023\n可读、可写\n0\n0xFFFFFFFF\n\n\nFS\n003B\n可读、可写\n0x7FFDE000\n0xFFF\n\n\nGS\n-\n-\n-\n-\n\n\n段寄存器的读写对于段寄存器可以使用MOV指令进行读写（LDTR和TR除外）\n读段寄存器 复制代码 隐藏代码#include &lt;stdio.h&gt;\n#include &lt;windows.h&gt;\nint main()&#123;\n    WORD selector&#x3D;0;\n    _asm&#123;\n        mov selector, es\n    &#125;\n    printf(&quot;%x\\n&quot;,selector);\n    return 0;\n&#125;\n\n对段寄存器的读操作只能读取段寄存器的16位Selector部分（可见部分）\n\n运行结果\n能够正确地读出es段寄存器的selector\n\n写段寄存器 复制代码 隐藏代码#include &lt;stdio.h&gt;\n#include &lt;windows.h&gt;\nWORD data&#x3D;0x0610;\nWORD readData&#x3D;0;\n__declspec(naked) void fuction()&#123;\n     __asm&#123;\n                &#x2F;&#x2F;保留调用前堆栈\n                push ebp\n                &#x2F;&#x2F;提升堆栈\n                mov ebp,esp\n                sub esp,0x40\n                &#x2F;&#x2F;保护现场\n                push ebx\n                push esi\n                push edi\n                &#x2F;&#x2F;初始化提升的堆栈，填充缓冲区\n                mov eax,0xCCCCCCCC\n                mov ecx,0x10\n                lea edi,dword ptr ds:[ebp-0x40]\n                rep stosd\n                &#x2F;&#x2F;函数核心功能\n\n                push ds         &#x2F;&#x2F;保存ds段寄存器\n                mov ax,cs       &#x2F;&#x2F;将cs段寄存器的段选择子赋值给ax\n                mov ds,ax       &#x2F;&#x2F;使用cs段寄存器覆盖ds段寄存器\n                mov ax,word ptr ds:[data]       &#x2F;&#x2F;使用修改后的段寄存器ds读取，这里相当于mov ax,word ptr cs:[data]\n                pop ds          &#x2F;&#x2F;还原ds段寄存器\n                mov readData,ax &#x2F;&#x2F;将读出来的数据赋值给变量\n\n                &#x2F;&#x2F;恢复现场\n                pop edi\n                pop esi\n                pop ebx\n\n                &#x2F;&#x2F;降低堆栈\n                mov esp,ebp\n                pop ebp                \n\n                &#x2F;&#x2F;返回\n                ret \n        &#125;        \n&#125;\n\nint main()&#123;\n\n        fuction();\n        printf(&quot;%X\\n&quot;,readData);\n\n        return 0;\n&#125;\n\n\n运行结果\n可以看到代码是能够正常执行，并且输出对应的data\n\n说明上述代码使用了裸函数，避免了编译器的干扰；关于裸函数可以回顾：逆向基础笔记九 C语言内联汇编和调用协定\n截取出关键代码：\n 复制代码 隐藏代码push ds         &#x2F;&#x2F;保存ds段寄存器\nmov ax,cs       &#x2F;&#x2F;将cs段寄存器的段选择子赋值给ax\nmov ds,ax       &#x2F;&#x2F;使用cs段寄存器覆盖ds段寄存器\nmov ax,word ptr ds:[data]       &#x2F;&#x2F;使用修改后的段寄存器ds读取，这里相当于mov ax,word ptr cs:[data]\npop ds          &#x2F;&#x2F;还原ds段寄存器\nmov readData,ax &#x2F;&#x2F;将读出来的数据赋值给变量\n\n\n代码注释如上，就是个简单的覆盖段寄存器的操作\n\n为什么明明替换了段寄存器，仍然能够正常运行呢？\n首先要注意到，替换和被替换的段寄存器分别是：cs和ds；它们的base是相同的都为0，因此所访问的内存自然也是相同的\n再来看权限问题：无论是cs还是ds，它们都具有可读的权限；这里也只对数据进行了读操作，于是可以正常运行\n如果这里将读取data的代码修改为写data的代码，则会报错：\n 复制代码 隐藏代码mov ax,word ptr ds:[data]   &#x2F;&#x2F;使用cs段寄存器覆盖过的ds段寄存器，读取data\n&#x2F;&#x2F;将上面的代码修改为：\nmov word ptr ds:[data],ax   &#x2F;&#x2F;使用cs段寄存器覆盖过的ds段寄存器，修改data\n\n为什么会报错？因为此时的ds段寄存器已经被覆盖为了cs段寄存器，而cs段寄存器的权限为可读、可执行，没有可写的权限，所以会报错\n报错截图：\n\n可以看到，此时的data的地址明明是有效的，先前也验证了可以正确读取，但是在这里就会报错：Acccess Violation（非法访问）\n就这里就是因为段寄存器权限不足导致的，也是为什么先前都是使用ds段寄存器来赋值，而不是用cs段寄存器\n 复制代码 隐藏代码mov word ptr ds:[address],data  &#x2F;&#x2F;使用ds段寄存器修改数据，可以正常修改\nmov word ptr cs:[address],data &#x2F;&#x2F;使用cs段寄存器修改数据，会报错\n\n\n和前面对段寄存器的读操作不同，写寄存器是对整个96位的段寄存器进行修改\n但是这里明明只给出了16位的段选择子Selector，剩下的80位呢？\n这个就段描述符有关了，这里暂且不谈，留作之后自会知晓，先记住写寄存器是对整个段寄存器进行修改即可\n\n验证Limit在前面的读写中，或多或少都验证了段寄存器的几个属性：Base、Selector、Attribute\n现在最后验证一下Limit\n 复制代码 隐藏代码#include &lt;stdio.h&gt;\n#include &lt;windows.h&gt;\nint main()&#123;\n\n    unsigned char base;\n    _asm&#123;   \n\n        mov al,fs:[0x1000]      &#x2F;&#x2F;超过limit:0xfff，无法正常运行\n        mov base,al\n    &#125;\n    printf(&quot;%x\\n&quot;,base);\n    return 0;\n&#125;\n\n\n\n 复制代码 隐藏代码#include &lt;stdio.h&gt;\n#include &lt;windows.h&gt;\nint main()&#123;\n\n    unsigned char base;\n    _asm&#123;   \n\n        mov al,fs:[0xfff]       &#x2F;&#x2F;在临界点可以正常运行\n        mov base,al\n    &#125;\n    printf(&quot;%x\\n&quot;,base);\n    return 0;\n&#125;\n\n\n\n总结\n段寄存器共96位，其中16位为可见部分，后80位为不可见部分\n不同计算机段寄存器信息不一定相同\nFS和GS两个段寄存器分别在32位程序和64位程序发挥作用\n\n","slug":"段寄存器","date":"2022-12-14T07:19:32.614Z","categories_index":"","tags_index":"","author_index":"虫子"},{"id":"f73a8e23e6f6f669cf99c7dba8fa0722","title":"","content":"","slug":"中断门和IDT(中断描述符表)","date":"2022-12-14T07:19:32.604Z","categories_index":"","tags_index":"","author_index":"虫子"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n2.（4.0分） In this and succeeding meetings the of attention was primarily on the manpower involved, with some discussion of the public expenditure costs.A focusB absenceC minimumD authority\n","slug":"hello-world","date":"2022-12-14T07:19:32.599Z","categories_index":"","tags_index":"","author_index":"虫子"},{"id":"7bcb9e1af25ded2b038f5286bb791f16","title":"第一篇博客","content":"","slug":"第一篇博客","date":"2022-12-13T16:26:03.000Z","categories_index":"","tags_index":"","author_index":"虫子"},{"id":"a9e5c50c2e33194989c356519407f89c","title":"WIFI主机-高端技巧","content":"WIFI主机\n\n\n\n\n\n\n\n\n到了这里中断就要深入了解，定时器高端玩法。。。。\n这里我们带着一个问题去，就是玩过STC的单片机大家都是知道中断是有一个中断向量入口的，但是STM32中断函数我们是不是没有interrupt这个向量入口。那么他是如何触发中断的，我们下面就会看看中断向量表。\n中断中断简介\n\n\n\n\n\n\n\n\nSTM32 中断非常强大，每个外设都可以产生中断，&#x3D;&#x3D;异常就是中断，中断就是异常。&#x3D;&#x3D;\n中断类型\n\n\n\n\n\n\n\n\n系统异常，体现在内核水平\n外部中断，体现在外设水平\n具体看STM32F10xxx产品(小容量、中容量和大容量)的向量表&#x3D;&#x3D;(中断向量表)&#x3D;&#x3D;\n\n我们可以看到复位Reset优先级是最高的，不管其他程序怎么跑，只要一复位那边就重新运行了\nNVIC\n\n\n\n\n\n\n\n\nNVIC ：嵌套向量中断控制器，属于内核外设，管理着包括内核和片上所有外设的中断相关的功能。\n两个重要的库文件：core_cm3.h和misc.h\nNVIC寄存器简介，core_cm3.h定义\n\n中断优先级的定义\n\n\n\n\n\n\n\n\n优先级设定：NVIC-&gt;IPRx\n\n优先级分组：SCB-&gt;AIRCR:PRIGROUP[10:8]\n\n主优先级也叫着抢占优先级\n中断编程顺序\n\n\n\n\n\n\n\n\n1-使能中断请求\n2-配置中断优先级分组\n3-配置NVIC寄存器，初始化NVIC_InitTypeDef;\n4-编写中断服务函数\n\n编写中断服务函数\n\n\n\n\n\n\n\n\n这里就是我们开始需要解决的问题\n1-中断服务函数名要怎么写？写错了怎么办？\n2-中断服务函数要写在什么地方？\n\n中断服务函数的话就写在…it.c这个文件里面，方面查阅优先级\nEXTI\n\n\n\n\n\n\n\n\nEXTI：External interrupt / event controller\n外部中断&#x2F;事件控制器\nEXTI功能框图\n\nEXTI初始化结构体\n\n\n\n\n\n\n\n\n\n定时器矩阵什么是定时器矩阵\n我们在产品开发当中，经常会碰到一些不同的定时要求，比如说按键消抖，LED做一些每秒闪1次，每几秒闪几次，还有其他乱七八糟的定时需求。\n那定时器矩阵就是解决这些有不同定时需求的痛点。\nLED定时、按键定时、其他功能定时的集合就叫定时器矩阵\n定时器矩阵原理\n\n\n\n\n\n\n\n\n\n为了保证定时精确性，一般会使用单片机定时器，给定时器矩阵一个基准定时。类似于systick，比如说50us中断一次，这样能满足绝大多数定时要求。\n比如说让LED每秒闪1次，那就需要500ms改变一次LED控制引脚电平。那根据单片机定时器50us基准定时，500ms的话就需要中断500000&#x2F;50&#x3D;10000次。\n再比如说按键扫描定时需要10ms执行一次，那10000&#x2F;50&#x3D;200，单片机定时器中断200次就执行一次按键扫描。有的定时器是从程序开始运行到结束都需要循环定时的，比如说按键扫描。但有些是一次性的，比如说我想让灯亮2秒后自动熄灭，这种定时器就没必要让它一直计数浪费资源。所以，我们需要可以灵活创建，用完可删，任意定时的定时器矩阵功能。那接下来我们会把这些功能用C语言的高级技巧来封装下，让它显得更人性化，使用起来更方便。\n定时器矩阵程序实战\n\n\n\n\n\n\n\n\n\n创建一个定时器结构体\n编写定时器初始化函数 hal_timerInit\n编写创建定时器函数 hal_CreatTimer\n编写定时器中断函数 Hal_TimerHandle，把这个函数放在单片机定时器中断里\n编写定时器复位函数hal_ResetTimer\n编写其他辅助函数:  控制定时器动作函数hal_CtrlTimerAction;  删除定时器函数hal_DeleteTimer  获取定时器状态函数 hal_GetTimerState\n\n定时器初始化函数  hal_timerInit\n\n\n\n\n\n\n\n\n\n//创建定时器结构体数组\nvolatile Stu_TimerTypedef Stu_Timer[T_SUM];\n\n//现在才是我们通用定时器初始化函数\n//为了以后方便移植将GENERAL_TIM_Init名字改为hal_TimeInit\nvoid hal_TimeInit()\n&#123;\n\tuint8_t i;\n\t//通用定时器中断配置\n\tGENERAL_TIM_NVIC_Config();\n\t//通用定时器配置\n\tGENERAL_TIM_Config();\n\t//轮询定时器\n\tfor(i = 0;i&lt;T_SUM;++i)\n\t&#123;\n\t\tStu_Timer[i].state = T_STA_STOP;    //先把定时器设置为停止\n\t\tStu_Timer[i].CurrentCount = 0;      //当前计时值为0\t\n\t\tStu_Timer[i].Period = 0;            //定时周期设置0\n\t\tStu_Timer[i].func = 0;              //函数指针先指向空\n\t&#125;\n&#125;\n\n创建定时器函数 hal_CreatTimer\n\n\n\n\n\n\n\n\n\n/*******************************************************************************\n* Function Name  : hal_CreatTimer(TIMER_ID_TYPEDEF id,void (*proc)(void), unsigned short Period,unsigned char state)\n* Description    : 创建定时器 \n* Input          : - id：定时器ID\n*\t\t\t\t   - (*proc)() 函数指针 \n*\t\t\t\t   - Period 定时周期，单位50us\n* \t\t\t\t   - state 定时器初始状态\n* Output         : None\n* Return         : None\n* Attention\t\t \t : None\n*******************************************************************************/\nvoid hal_CreatTimer(TIMER_ID_TYPEDEF id,void (*proc)(void), unsigned short Period,TIMER_STATE_TYPEDEF state)\n&#123;\t\n\tStu_Timer[id].state = state;\n \n\tStu_Timer[id].CurrentCount = 0;\n\tStu_Timer[id].Period = Period;\n\tStu_Timer[id].func = proc;\n&#125;\n\n\n定时器中断函数 Hal_TimerHandle\n\n\n\n\n\n\n\n\n\n/*******************************************************************************\n* Function Name  : static void Hal_TimerHandle(void)\n* Description    : 定时器中断计时函数\n* Input          : None\n* Output         : None\n* Return         : None\n* Attention\t\t : None\n*******************************************************************************/\nstatic void Hal_TimerHandle(void)\n&#123;\n\tunsigned char i;\n\t \n\tfor(i=0; i&lt;T_SUM; i++)\n\t&#123;\n\t\tif((Stu_Timer[i].func) &amp;&amp; (Stu_Timer[i].state==T_STA_START))\n\t\t&#123;\t\n\t\t\t\tStu_Timer[i].CurrentCount++;\n\t\t\t if(Stu_Timer[i].CurrentCount >= Stu_Timer[i].Period)\n\t\t\t &#123;\n\t\t\t\t Stu_Timer[i].state = T_STA_STOP;\n\t\t\t\t Stu_Timer[i].CurrentCount = Stu_Timer[i].CurrentCount;\n\t\t\t\tStu_Timer[i].func();\n\t\t\t&#125;\n \n\t\t&#125;\n\t\t\n\t&#125;\n&#125;\n\n定时器复位函数hal_ResetTimer\n\n\n\n\n\n\n\n\n\n/*******************************************************************************\n* Function Name  : hal_ResetTimer(TIMER_ID_TYPEDEF id,TIMER_STATE_TYPEDEF sta)\n* Description    : 复位定时器状态和计时时间\n* Input          : - id：定时器ID\n*\t\t\t       - sta 定时器状态\n* Output         : None\n* Return         : None\n* Attention\t\t \t : None\n*******************************************************************************/\nTIMER_RESULT_TYPEDEF hal_ResetTimer(TIMER_ID_TYPEDEF id,TIMER_STATE_TYPEDEF sta)\n&#123;\n\tif(Stu_Timer[id].func)\t\t//判断定时器是否存在\n\t&#123;\n\t\tStu_Timer[id].state = sta;\n\t\tStu_Timer[id].CurrentCount = 0;\n\t\t \n\t\treturn T_SUCCESS;\n\t&#125;else\n\t&#123;\n\t\treturn T_FAIL;\n\t&#125;\n&#125;\n\n控制定时器动作函数hal_CtrlTimerAction\n\n\n\n\n\n\n\n\n\n/*******************************************************************************\n* Function Name  : unsigned char hal_CtrlTimerAction(TIMER_ID_TYPEDEF id,TIMER_STATE_TYPEDEF sta)\n* Description    : 控制定时器动作 \n* Input          : - id：定时器ID\n*\t\t\t\t   - sta 定时器状态\n* Output         : None\n* Return         : None\n* Attention\t\t \t : None\n*******************************************************************************/\nTIMER_RESULT_TYPEDEF hal_CtrlTimerAction(TIMER_ID_TYPEDEF id,TIMER_STATE_TYPEDEF sta)\n&#123;\n\tif(Stu_Timer[id].func)\t\t//判断定时器是否存在\n\t&#123;\n\t\tStu_Timer[id].state = sta;\n\t\treturn T_SUCCESS;\n\t&#125;else\n\t&#123;\n\t\treturn T_FAIL;\n\t&#125;\n&#125;\n\n删除定时器函数hal_DeleteTimer  \n\n\n\n\n\n\n\n\n\n/*******************************************************************************\n* Function Name  : hal_DeleteTimer(TIMER_ID_TYPEDEF id)\n* Description    : 删除定时器 \n* Input          : - id：定时器ID\n*\t\t\t\t\t\t\t\t \n* Output         : None\n* Return         : None\n* Attention\t\t \t : None\n*******************************************************************************/\nTIMER_RESULT_TYPEDEF hal_DeleteTimer(TIMER_ID_TYPEDEF id)\n&#123;\n\tif(Stu_Timer[id].func)\n\t&#123;\n\t\tStu_Timer[id].state = T_STA_STOP;\n\t \n\t\tStu_Timer[id].CurrentCount = 0;\n\t\t//Stu_Timer[id].Period = 0;\n\t\tStu_Timer[id].func = 0;\n\t\treturn T_SUCCESS;\n\t&#125;else\n\t&#123;\n\t\treturn T_FAIL;\n\t&#125;\n&#125;\n\n获取定时器状态函数 hal_GetTimerState \n\n\n\n\n\n\n\n\n\n&#x2F;*******************************************************************************\n* Function Name  : TIMER_STATE_RESULT_TYPEDEF\thal_GetTimerState(TIMER_ID_TYPEDEF id)\n* Description    : 获取定时器状态\n* Input          : - id：定时器ID\n*\t\t\t\t   - sta 定时器状态\n* Output         : None\n* Return         : None\n* Attention\t\t \t : None\n*******************************************************************************&#x2F;\nTIMER_STATE_TYPEDEF\thal_GetTimerState(TIMER_ID_TYPEDEF id)\n&#123;\n\tif(Stu_Timer[id].func)\t\t&#x2F;&#x2F;判断定时器是否存在\n\t&#123;\n\t\treturn Stu_Timer[id].state;\n\t \n\t&#125;else\n\t&#123;\n\t\treturn T_STA_INVAILD;\n\t&#125;\n&#125;\n\n定时器矩阵实战\n\n\n\n\n\n\n\n\n上面定时器矩阵代码讲解好了，就进入实战\n创建一个定时器，让LED每秒闪1次\n&#x3D;&#x3D;注意点&#x3D;&#x3D;\n\n使用前必须先创建和添加定时器。\n如果需要循环定时，定时回调函数结束后要调用hal_ResetTimer让定时器复位启动\n\n\n定时器矩阵超级大bug\n\n\n\n\n\n\n\n\n\n现在是错误代码跑出正确的现象\n\n所以我们调试一波\n\n\n 网上这种故障的类似解决\n\n\n\n\n\n\n\n\n我们平时的项目，可能会遇到死机的情况，通过在线调试，或者**消息，怎么可能会发现，怎么进入了HardFault_Handler中断呢？\n这种“硬故障”是我们常见的一种故障，导致硬故障的原因也有很多，这里针对Cortex-M3说说Fault故障相关的内容\nFault故障种类\nFault故障的种类有很多，拿本文Cortex-M3来说，主要有：\nHardFault：硬故障\nMemManager：存储器管理故障\nBusFault：总线故障\nUsageFault：用法故障\n\n\n\n硬(hard)fault\n-1\n所有被除能的fault，都将“上访”(escalation)成硬fault，只要FAULTTMASK没有置位，硬fault服务例程就被强制执行。fault被除能的原因包括被禁用，或者FAULTMASK被置位\n\n\n\nMemManager fault\n可编程\n存储器管理fault，MPU访问犯规以及访问非法位置均可引发，企图在非执行区取值也会引发此fault\n\n\n总线 fault\n可编程\n从总线系统收到了错误响应，原因可以是预取流产(Abort)或数据流产，或者企图访问协处理器\n\n\n用法(usage) fault\n可编程\n由于程序错误导致的异常，通常是使用一条无效指令，或者是非法的状态转换，例如尝试切换到ARM状态\n\n\n&#x3D;&#x3D;比如 在stm32f10x_it.c源代码中，有这样的中断入口&#x3D;&#x3D;\n/**\n  * @brief  This function handles Hard Fault exception.\n  * @param  None\n  * @retval None\n  */\nvoid HardFault_Handler(void)\n&#123;\n  /* Go to infinite loop when Hard Fault exception occurs */\n  while (1)\n  &#123;\n  &#125;\n&#125;\n\n/**\n  * @brief  This function handles Memory Manage exception.\n  * @param  None\n  * @retval None\n  */\nvoid MemManage_Handler(void)\n&#123;\n  /* Go to infinite loop when Memory Manage exception occurs */\n  while (1)\n  &#123;\n  &#125;\n&#125;\n\n/**\n  * @brief  This function handles Bus Fault exception.\n  * @param  None\n  * @retval None\n  */\n\nvoid BusFault_Handler(void)\n&#123;\n  /* Go to infinite loop when Bus Fault exception occurs */\n  while (1)\n  &#123;\n  &#125;\n&#125;\n\n/**\n  * @brief  This function handles Usage Fault exception.\n  * @param  None\n  * @retval None\n  */\nvoid UsageFault_Handler(void)\n&#123;\n  /* Go to infinite loop when Usage Fault exception occurs */\n  while (1)\n  &#123;\n  &#125;\n&#125;\n\nFault故障描述\n\n\n\n\n\n\n\n\n每一种Fault故障的产生，都肯定是有一定原因的，如果你代码产生了Fault故障中断，说明代码某些地方引起了Fault故障\n1.HardFault：硬故障\n\n\n\n\n\n\n\n\n我们发现硬故障是一种“不可编程”的故障，因为存储器管理故障，总线故障，用法故障如果不能得到执行，就上访为硬故障\n比如在取向量时产生的总线故障也按会硬件故障进行处理，所以，你会发现出现故障，很多时候都是硬故障\n&#x3D;&#x3D;硬故障状态寄存器描述&#x3D;&#x3D;\n\n\n\n位段\n名称\n类型\n复位值\n描述\n\n\n\n31\nDEBUGEVT\nR&#x2F;Wc\n0\n硬fault因调试事件而产生\n\n\n30\nFORCED\nR&#x2F;Wc\n0\n硬fault是总线fault，存储器管理fault或是用法fault上访的结果\n\n\n29:2\n-\n-\n-\n-\n\n\n1\nVECTBL\nR&#x2F;Wc\n0\n硬fault是在取向量时发生的\n\n\n0\n–\n-\n-\n-\n\n\n通过状态寄存器你会发现产生硬故障的原因有以上几种\n2.MemManager：存储器管理故障\n\n\n\n\n\n\n\n\n存储器管理故障通常与MPU(内存保护单元)有关，之前给大家分享过MPU相关的文章《什么是Cortex-M内核的MPU》\n通常就是我们说的“内存越界”就会导致存储器管理故障，细说引起该故障的诱因有：\n访问了MPU设置区域覆盖范围之外的地址\n往只读region写数据\n用户级下访问了只允许在特权下访问的地址\n存储器管理故障状态寄存器\n\n\n\n位段\n名称\n类型\n复位值\n描述\n\n\n\n7\nMMARVALID\n-\n0\n&#x3D;1时表示MMAR有效\n\n\n6:5\n-\n-\n-\n-\n\n\n4\nMSTKERR\nR&#x2F;Wc\n0\n入栈时发生错误\n\n\n3\nMUNSTKERR\nR&#x2F;Wc\n0\n出栈时发生错误\n\n\n2\n-\n-\n-\n-\n\n\n1\nDACCVIOL\nR&#x2F;Wc\n0\n数据访问违例\n\n\n0\nIACCVIOL\nR&#x2F;Wc\n0\n取指访问违例\n\n\n通过状态寄存器你会发现引起该故障的一些原因\n3.BusFault：总线故障\n\n\n\n\n\n\n\n\n总线故障，顾名思义就是对“总线”操作出现问题，导致的故障\n比如：当AHB接口上正在传送数据时，如果回复了一个错误信号(error response),则会产生总线故障\n产生中线故障的场合\n取指，通常被称作“预取流产”\n数据读&#x2F;写，通常被称为“数据流产”\n触发总线故障的动作\n中断处理起始阶段的堆栈PUSH动作，称为入栈错误\n中断处理收尾阶段的堆栈POP动作，称为出栈错误\n\n同样，通过总线故障状态寄存器了解产生的原因\n\n\n\n位段\n名称\n类型\n复位值\n描述\n\n\n\n7\nBFARVALID\n-\n0\n&#x3D;1时表示BFAR有效\n\n\n6:5\n-\n-\n-\n-\n\n\n4\nSTKERR\nR&#x2F;Wc\n0\n入栈时发生错误\n\n\n3\nUNSTKERR\nR&#x2F;Wc\n0\n出栈时发生错误\n\n\n2\nIMPRECISERR\nR&#x2F;Wc\n0\n不精确的数据访问违例(violation)\n\n\n1\nPRECISERR\nR&#x2F;Wc\n0\n精确的数据访问违例\n\n\n0\nIBUSERR\nR&#x2F;Wc\n0\n取指时的访问违例\n\n\n4.UsageFault：用法故障\n\n\n\n\n\n\n\n\n用法故障相对不常见，出现该故障通常是进行了“未对齐访问操作”，其他导致该故障问题很少见\n比如：执行了未定义的指令，除数为0(编译器都会避免)，无效的中断返回等这些情况比较少见\n用法故障状态寄存器\n\n\n\n位段\n名称\n类型\n复位值\n描述\n\n\n\n9\nDIBYZERO\nR&#x2F;Wc\n0\n表示除法运算时除数为零(只有在DIV_O_TRP置位时才会发生)\n\n\n8\nUNALIGNED\nR&#x2F;Wc\n0\n未对齐访问导致的fault\n\n\n7:4\n-\n-\n-\n-\n\n\n3\nNOCP\nR&#x2F;Wc\n0\n试图执行协处理器相关命令\n\n\n2\nINVPC\nR&#x2F;Wc\n0\n在异常返回时试图非法的加载EXC_RETURN到PC。包括非法的指令，非法的上下文以及非法的EXC_RETURN值。The return PC指向的指令试图设置PC的值(要理解此位的含义，还需学习后面的讨论中断级异常的文章)\n\n\n1\nINVSTSTE\nR&#x2F;Wc\n0\n试图切入ARM状态\n\n\n0\nUNDEFINSTR\nR&#x2F;Wc\n0\n执行的指针及其编码是未定义的–解码不能\n\n\n如何应对故障\n不知道大家平时有没有进行有效的避免，这里简单说几点应对故障的措施\n1.通过故障状态寄存器的值来判定程序错误\n在故障中断函数中，读取故障的状态(上面描述了状态寄存器)，比如硬故障\nvoid HardFault_Handler(void)\n&#123;\n    //读取装态寄存器，打印寄存器，判断什么原因引起故障\n    printf(\"状态X信息\");\n    while(1);&#123;&#125;\n&#125;\n//如果不想死机状态，可以在中断里面软复位\n\n\n\n\n\n\n\n\n\n\n2.提前对代码进行分析，预判\n比如：通过代码静态分析工具，对代码进行分析，查找bug\nLED特效\n\n\n\n\n\n\n\n\n就是我们在产品开发当中，经常会碰到一些对LED有不同闪烁效果的功能，有时候一个LED灯效果都会搞到你头疼，所以我们需要不一样的方法\n LED多种特效实现原理\n\n\n\n\n\n\n\n\n我们从另外一个角度去思考，其实可以解决很多问题，就是先思考输出波形，然后再把波形转换成数据，因为不管是单片机还是任何处理器，最终处理的肯定是数据。\n举个例子\n比如说我要控制LED灯每秒闪一次，那控制LED灯那个单片机引脚对应的波形如下\n\n那我们再举个复杂点的，让LED每隔5秒快闪2次，以此循环，那么波形如下\n\n代码实战看别人代码段思路\n\n\n\n\n\n\n\n\n\n先熟悉所实现功能\n从函数调用作为入口，我们这个程序只需要调用一个函数，然后传入要控制的设备类型，(LED还是蜂鸣器)type，然后实现的效果命令cmd，最后一个参数是否清楚队列里的命令，立即执行当下命令LedMsgInput(LED1,LED_BLINK2,1);``LedMsgInput(BUZ,LED_DARK,1);\n分析LedMsgInput函数体的代码实现\n分析其他具有连带关系的函数或者变量或者数组\n\nLedMsgInput 特效设备消息输入函数\n\n\n\n\n\n\n\n\n\n/********************************************************************************************************\n*  @函数名   LedMsgInput\t\t\t\t\t                                                           \n*  @描述     特效设备消息输入函数\t\t\t\t\t\t\t\t                                     \n*  @参数     type-特效设备   cmd-特效命令   clr-1立即执行 0稍后执行，先放到消息队列里面\n*  @返回值   无   \n*  @注意     无\n********************************************************************************************************/\nvoid LedMsgInput(unsigned char type,LED_EFFECT_TEPEDEF cmd,unsigned char clr)\n&#123;\t\n\tunsigned char  bLedCMD;\n\tif(type >= LED_SUM)\n\t&#123;\n\t\treturn;\n\t&#125;\n\tbLedCMD = cmd;\n\tif(clr)\n\t&#123;\n\t\tQueueEmpty(LedCmdBuff[type]);\n\t\tLedLoadFlag[type] = 0;\n\t\t \n\t&#125;\n\tQueueDataIn(LedCmdBuff[type],&amp;bLedCMD,1);\t\n&#125;\n\nhal_LedProc 小灯任务函数\n\n\n\n\n\n\n\n\n数据丢到消息队列里面必须还要取，我们把消息放到队列里面仅仅是数据，还没有变成特效，也就是我们还要放到任务里面\n\n但是还是没有控制led，还是一些数据处理\nvoid hal_LedProc(void)\n&#123;\n\tunsigned char i;\n\tunsigned char cmd;\n\tfor(i=0; i&lt;LED_SUM; i++)\n\t&#123;\n\t\t\n\t\tif((QueueDataLen(LedCmdBuff[i])>0) &amp;&amp; (LedLoadFlag[i]==0))\n\t\t&#123;\n\t\t\t\tQueueDataOut(LedCmdBuff[i], &amp;cmd);\n\t\t\t\tLedLoadFlag[i] = 1;\n\t\t\t\tswitch(cmd)\n\t\t\t\t&#123;\n\t\t\t\t\tcase LED_DARK:\n\t\t\t\t\t\tpLed[i] = Led_Dark;\n\t\t\t\t\t\tLedTimer[i] = *(pLed[i]+1);\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase LED_LIGHT:\n\t\t\t\t\t\tpLed[i] = Led_Light;\n\t\t\t\t\t\tLedTimer[i] = *(pLed[i]+1);\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase LED_LIGHT_100MS:\n\t\t\t\t\t\tpLed[i] = Led_Light100ms;\n\t\t\t\t\t\tLedTimer[i] = *(pLed[i]+1);\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase LED_BLINK1:\n\t\t\t\t\t\tpLed[i] = Led_Blink1;\n\t\t\t\t\t\tLedTimer[i] = *(pLed[i]+1);\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase LED_BLINK2:\n\t\t\t\t\t\tpLed[i] = Led_Blink2;\n\t\t\t\t\t\tLedTimer[i] = *(pLed[i]+1);\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase LED_BLINK3:\n\t\t\t\t\t\tpLed[i] = Led_Blink3;\n\t\t\t\t\t\tLedTimer[i] = *(pLed[i]+1);\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase LED_BLINK4:\n\t\t\t\t\t\tpLed[i] = Led_Blink4;\n\t\t\t\t\t\tLedTimer[i] = *(pLed[i]+1);\n\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:break;\t\t\t\t\t \n\t\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\nhal_LedHandle 小灯处理函数  也就是这里的特效处理\n\n\n\n\n\n\n\n\n那么我们控制在哪里处理，在自己的小灯定时器处理函数里面，到时间就控制就行\n\n//led处理函数传给定时器的函数指针\nstatic void hal_LedHandle()\n&#123;\n\tunsigned char i;\n\tfor(i=0; i&lt;LED_SUM; i++)\n\t&#123;\n\t\tif(LedTimer[i])\n\t\t&#123;\n\t\t\tLedTimer[i]--;\n\t\t&#125;\n\t\tif(!LedTimer[i])\n\t\t&#123;\n\t\t\t//定时时间到\n\t\t\t//Led_Light[] = &#123;1,10,LED_EFFECT_END&#125;;\n\t\t\tif(*(pLed[i]+2) == LED_EFFECT_END)\n\t\t\t&#123;\n\t\t\t\t\tLedLoadFlag[i] = 0;\n\t\t\t&#125;else\n\t\t\t&#123;\n\t\t\t\tpLed[i] += 2;\n\t\t\t\tif(*pLed[i] == LED_EFFECT_AGN)\n\t\t\t\t&#123;\n\t\t\t\t\t//Led_Blink1[] = &#123;1,10,0,10,LED_EFFECT_AGN,2&#125;;\n\t\t\t\t\tpLed[i] = pLed[i] - (*(pLed[i]+1) * 2);\n\t\t\t\t&#125;\n\t\t\t\tLedTimer[i] = *(pLed[i]+1);\n\t\t\t&#125;\n\t\t&#125;\n\t\thal_LedDrive[i](*pLed[i]);\n\t&#125;\n\thal_ResetTimer(T_LED,T_STA_START);\n&#125;\n\nhal_LedInit led初始化函数\n\n\n\n\n\n\n\n\n\nvoid hal_LedInit(void)\n&#123;\n\tunsigned char i;\n\thal_ledConfig();\n\thal_CreatTimer(T_LED,hal_LedHandle,200,T_STA_START);\n\t\n\tfor(i=0; i&lt;LED_SUM; i++)\n\t&#123;\n\t\tLedLoadFlag[i] = 0;\n\t\tpLed[i] = (unsigned short *)Led_Dark;\n\t\tLedTimer[i] = *(pLed[i]+1);\n\t\tQueueEmpty(LedCmdBuff[i]);\n\t&#125;\n\tLedMsgInput(LED1,LED_BLINK2,1);\n\tLedMsgInput(BUZ,LED_DARK,1);\n&#125;\n\n上面一些重要函数的补充吧\n\n\n\n\n\n\n\n\n\n模块化编程思维，LED和蜂鸣器作为硬件驱动，最好是直接通过一个函数就能控制制定的设备完成制定的效果，硬件驱动层.c文件和应用层.c文件完全可以独立，互不干扰。\n波形数据数组\n重申enum的作用\n加static关键词定义的变量或者函数代表只能在该.c文件里使用，作用就是为了增加代码可读性，很直观的看的出哪些变量或者函数是在该.c文件内部使用的，便于后期代码的分析和调试。\n\n","slug":"wifi主机/wifi主机第三部分  高端手法","date":"2020-08-15T10:49:36.000Z","categories_index":"单片机","tags_index":"STM32,主机","author_index":"虫子"},{"id":"91f6d7c8b6037035fbfa6686cc2db239","title":"WIFI主机-宗师","content":"WIFI主机\n\n\n\n\n\n\n\n\n这一篇与主机无关，完全就是瓶颈突破\nMDK的编译过程及文件类型全解\n\n\n\n\n\n\n\n\n我们已经非常熟练地使用MDK创建应用程序了，平时使用MDK编写源代码，然后编译生成机器码，再把机器码下载到STM32芯片上运行，但是这个编译、下载的过程MDK究竟做了什么工作？它编译后生成的各种文件又有什么作用？这里将对这些过程进行讲解，了解编译及下载过程有助于理解芯片的工作原理，这些知识对制作IAP(bootloader)以及读写控制器内部FLASH的应用时非常重要。\n编译过程\n\n\n\n\n\n\n\n\n这个是vs和linux那边的编译过程\n\n现在是MDK的编译过程，它与其它编译器的工作过程是类似的\n\n编译\n\n\n\n\n\n\n\n\n MDK软件使用的编译器是armcc和armasm，它们根据每个c&#x2F;c++和汇编源文件编译成对应的以“.o”为后缀名的对象文件(Object Code，也称目标文件)，其内容主要是从源文件编译得到的机器码，包含了代码、数据以及调试使用的信息\n链接\n\n\n\n\n\n\n\n\n 链接器armlink把各个.o文件及库文件链接成一个映像文件“.axf”或“.elf”\n格式转换\n\n\n\n\n\n\n\n\n一般来说Windows或Linux系统使用链接器直接生成可执行映像文件elf后，内核根据该文件的信息加载后，就可以运行程序了，但在单片机平台上，需要把该文件的内容加载到芯片上，所以还需要对链接器生成的elf映像文件利用格式转换器fromelf转换成“.bin”或“.hex”文件，交给下载器下载到芯片的FLASH或ROM中\n具体工程中的编译过程\n\n\n\n\n\n\n\n\n\n程序的组成、存储与运行\n\n\n\n\n\n\n\n\nCODE 、RO 、RW 、ZI Data 域及堆栈空间\n在工程的编译提示输出信息中有一个语句“Program Size：Code&#x3D;xx RO-data&#x3D;xx RW-data&#x3D;xx ZI-data&#x3D;xx”，它说明了程序各个域的大小，编译后，应用程序中所有具有同一性质的数据(包括代码)被归到一个域，程序在存储或运行的时候，不同的域会呈现不同的状态，这些域的意义如下\nCode\n\n\n\n\n\n\n\n\n 即代码域，它指的是编译器生成的机器指令，这些内容被存储到ROM区。\nRO-data \n\n\n\n\n\n\n\n\nRead Only data，即只读数据域，它指程序中用到的只读数据，这些数据被存储在ROM区，因而程序不能修改其内容。例如C语言中const关键字定义的变量就是典型的RO-data\nRW-data \n\n\n\n\n\n\n\n\nRead Write data，即可读写数据域，它指初始化为“非0值”的可读写数据，程序刚运行时，这些数据具有非0的初始值，且运行的时候它们会常驻在RAM区，因而应用程序可以修改其内容。例如C语言中使用定义的全局变量，且定义时赋予“非0值”给该变量进行初始化。\nZI-data \n\n\n\n\n\n\n\n\nZero Initialie data，即0初始化数据，它指初始化为“0值”的可读写数据域，它与RW-data的区别是程序刚运行时这些数据初始值全都为0，而后续运行过程与RW-data的性质一样，它们也常驻在RAM区，因而应用程序可以更改其内容。例如C语言中使用定义的全局变量，且定义时赋予“0值”给该变量进行初始化(若定义该变量时没有赋予初始值，编译器会把它当ZI-data来对待，初始化为0)；\nZI-data 的栈空间(Stack) 及堆空间(Heap) \n\n\n\n\n\n\n\n\n 在C语言中，函数内部定义的局部变量属于栈空间，进入函数的时候从向栈空间申请内存给局部变量，退出时释放局部变量，归还内存空间。而使用malloc动态分配的变量属于堆空间。在程序中的栈空间和堆空间都是属于ZI-data区域的，这些空间都会被初始值化为0值。编译器给出的ZI-data占用的空间值中包含了堆栈的大小(经实际测试，若程序中完全没有使用malloc动态申请堆空间，编译器会优化，不把堆空间计算在内)。\n\n\n\n\n\n\n\n\n\n\n\nRW-data和ZI-data它们仅仅是初始值不一样而已，为什么编译器非要把它们区分开？这就涉及到程序的存储状态了，应用程序具有静止状态和运行状态\n静止态的程序被存储在非易失存储器中，如STM32的内部FLASH，因而系统掉电后也能正常保存\n但是当程序在运行状态的时候，程序常常需要修改一些暂存数据，由于运行速度的要求，这些数据往往存放在内存中(RAM)，掉电后这些数据会丢失\n\n图中的左侧是应用程序的存储状态，右侧是运行状态，而上方是RAM存储器区域，下方是ROM存储器区域\n程序在存储状态时，RO节(RO section)及RW节都被保存在ROM区。当程序开始运行时，内核直接从ROM中读取代码，并且在执行主体代码前，会先执行一段加载代码，它把RW节数据从ROM复制到RAM， 并且在RAM加入ZI节，ZI节的数据都被初始化为0。加载完后RAM区准备完毕，正式开始执行主体程序。\n编译生成的RW-data的数据属于图中的RW节，ZI-data的数据属于图中的ZI节。是否需要掉电保存，这就是把RW-data与ZI-data区别开来的原因，因为在RAM创建数据的时候，默认值为0，但如果有的数据要求初值非0，那就需要使用ROM记录该初始值，运行时再复制到RAM\nSTM32的RO区域不需要加载到SRAM，内核直接从FLASH读取指令运行。计算机系统的应用程序运行过程很类似，不过计算机系统的程序在存储状态时位于硬盘，执行的时候甚至会把上述的RO区域(代码、只读数据)加载到内存，加快运行速度，还有虚拟内存管理单元(MMU)辅助加载数据，使得可以运行比物理内存还大的应用程序。而STM32没有MMU，所以无法支持Linux和Windows系统。\n当程序存储到STM32芯片的内部FLASH时(即ROM区)，它占用的空间是Code、RO-data及RW-data的总和，所以如果这些内容比STM32芯片的FLASH空间大，程序就无法被正常保存了。当程序在执行的时候，需要占用内部SRAM空间(即RAM区)，占用的空间包括RW-data和ZI-data。\n\n\n\n\n\n\n\n\n\n\n在MDK中，我们建立的工程一般会选择芯片型号，选择后就有确定的FLASH及SRAM大小，若代码超出了芯片的存储器的极限，编译器会提示错误，这时就需要裁剪程序了，裁剪时可针对超出的区域来优化\n编译工具链\n\n\n\n\n\n\n\n\n在前面编译过程中，MDK调用了各种编译工具，平时我们直接配置MDK，不需要学习如何使用它们，但了解它们是非常有好处的。\n若希望使用MDK编译生成bin文件的，需要在MDK中输入指令控制fromelf工具；在本章后面讲解AXF及O文件的时候，需要利用fromelf工具查看其文件信息，这都是无法直接通过MDK做到的\n设置环境变量\n\n\n\n\n\n\n\n\n调用这些编译工具，需要用到Windows的“命令行提示符工具”，为了让命令行方便地找到这些工具，我们先把工具链的目录添加到系统的环境变量中。\n添加到 路径到PATH\n\narmcc\n\n\n\n\n\n\n\n\narmcc用于把c&#x2F;c++文件编译成ARM指令代码，编译后会输出ELF格式的O文件(对象、目标文件)，在命令行中输入“armcc”回车可调用该工具，它会打印帮助说明\n\narmasm\n\n\n\n\n\n\n\n\n\narmlink\n\n\n\n\n\n\n\n\narmlink是链接器，它把各个O文件链接组合在一起生成ELF格式的AXF文件，AXF文件是可执行的，下载器把该文件中的指令代码下载到芯片后，该芯片就能运行程序了；利用armlink还可以控制程序存储到指定的ROM或RAM地址。在MDK中可在“Option for Target-&gt;Linker”页面配置armlink选项：\n\narmar\n\n\n\n\n\n\n\n\narmar工具用于把工程打包成库文件\n\nfromelf\n\n\n\n\n\n\n\n\nfromelf可根据axf文件生成hex\n\n这边就别想了，我是wintogo，这个fromelf打不开\nMDK工程的文件类型\n\n\n\n\n\n\n\n\n\n\no 、axf 及elf 文件\n\n\n\n\n\n\n\n\n.o、.elf、*.axf、*.bin及*.hex文件都存储了编译器根据源代码生成的机器码，根据应用场合的不同，它们又有所区别。\nELF是Executable and Linking Format的缩写，译为可执行链接格式，该格式用于记录目标文件的内容。在Linux及Windows系统下都有使用该格式的文件(或类似格式)用于记录应用程序的内容，告诉操作系统如何链接、加载及执行该应用程序。\n目标文件主要有如下三种类型\n&#x3D;&#x3D;可重定位的文件(Relocatable File)&#x3D;&#x3D;包含基础代码和数据，但它的代码及数据都没有指定绝对地址，因此它适合于与其他目标文件链接来创建可执行文件或者共享目标文件。 这种文件一般由编译器根据源代码生成\n例如MDK的armcc和armasm生成的*.o文件就是这一类，另外还有Linux的*.o 文件，Windows的 *.obj文件。\n&#x3D;&#x3D;可执行文件(Executable File)&#x3D;&#x3D;它包含适合于执行的程序，它内部组织的代码数据都有固定的地址(或相对于基地址的偏移)，系统可根据这些地址信息把程序加载到内存执行。这种文件一般由链接器根据可重定位文件链接而成，它主要是组织各个可重定位文件，给它们的代码及数据一一打上地址标号，固定其在程序内部的位置，链接后，程序内部各种代码及数据段不可再重定位(即不能再参与链接器的链接)。\n例如MDK的armlink生成的*.elf及*.axf文件，(使用gcc编译工具可生成*.elf文件，用armlink生成的是*.axf文件，*.axf文件在*.elf之外，增加了调试使用的信息，其余区别不大，后面我们仅讲解*.axf文件)，另外还有Linux的&#x2F;bin&#x2F;bash文件，Windows的*.exe文件\n&#x3D;&#x3D;共享目标文件(Shared Object File)&#x3D;&#x3D;它的定义比较难理解，我们直接举例，MDK生成的*.lib文件就属于共享目标文件，它可以继续参与链接，加入到可执行文件之中。另外，Linux的.so，如&#x2F;lib&#x2F; glibc-2.5.so，Windows的DLL都属于这一类\no 文件与axf文件的关系\n根据上面的分类，我们了解到，*.axf文件是由多个*.o文件链接而成的，而*.o文件由相应的源文件编译而成，一个源文件对应一个*.o文件。它们的关系如下：\n\n图中的中间代表的是armlink链接器，在它的右侧是输入链接器的*.o文件，左侧是它输出的*axf文件\n可以看到，由于都使用ELF文件格式，*.o与*.axf文件的结构是类似的，它们包含ELF文件头、程序头、节区(section)以及节区头部表。各个部分的功能说明如下：\nELF文件头用来描述整个文件的组织，例如数据的大小端格式，程序头、节区头在文件中的位置等\n程序头告诉系统如何加载程序，例如程序主体存储在本文件的哪个位置，程序的大小，程序要加载到内存什么地址等等。MDK的可重定位文件*.o不包含这部分内容，因为它还不是可执行文件，而armlink输出的*axf文件就包含该内容了\n节区是*.o文件的独立数据区域，它包含提供给链接视图使用的大量信息，如指令(Code)、数据(RO、RW、ZI-data)、符号表(函数、变量名等)、重定位信息等，例如每个由C语言定义的函数在*.o文件中都会有一个独立的节区\n存储在最后的节区头则包含了本文件节区的信息，如节区名称、大小等等\n总的来说，链接器把各个*.o文件的节区归类、排列，根据目标器件的情况编排地址生成输出，汇总到*.axf文件\n例如：“wifi主机”工程中在“bsp_led.c”文件中有一个LED_GPIO_Config函数，而它内部调用了“stm32f10x_gpio.c”的GPIO_Init函数，经过armcc编译后，LED_GPIO_Config及GPIO_Iint函数都成了指令代码，分别存储在bsp_led.o及stm32f10x_gpio.o文件中，这些指令在*.o文件都没有指定地址，仅包含了内容、大小以及调用的链接信息，而经过链接器后，链接器给它们都分配了特定的地址，并且把地址根据调用指向链接起来。\n\nELF 文件头\n\n\n\n\n\n\n\n\n接下来可以看看具体文件的内容，使用fromelf文件可以查看*.o、*.axf及*.lib文件的ELF信息。使用命令行，切换到文件所在的目录，输入“fromelf –text –vbsp_led.o”命令，可控制输出bsp_led.o的详细信息，利用“-c、-z”等选项还可输出反汇编指令文件、代码及数据文件等信息，可亲手尝试一下\n5集向后重新二级标题三级标题四级标题五级标题六级标题","slug":"wifi主机/wifi主机第九部分  宗师一方","date":"2020-08-15T10:49:36.000Z","categories_index":"单片机","tags_index":"STM32,主机","author_index":"虫子"},{"id":"9408b3862e11e4a86797ea35062d7f6a","title":"WIFI主机-轻量内核","content":"WIFI主机\n\n\n\n\n\n\n\n\n这篇是自己写的轻量级内核移植，之前的我都是裸机开发，不咋地，现在被内核深深的吸引。\n为什么要学习程序架构1.提高程序的稳定性\n\n\n\n\n\n\n\n\n我们在做产品就像建房子，一定要把”地基”打好，当然地基包括软件和硬件部分，硬件没问题的情况下，一个好的程序架构就是一个好的”地基”\n在好的架构基础上，我们能轻松地实现那些让人很头痛的功能，不然程序一复杂，你会发现有很多功能上的冲突，最后导致代码重写，非常蛋疼\n2.轻松解决产品开发当中常见痛点\n\n\n\n\n\n\n\n\n比如说有几个按键、需要实现短按、短按释放、长按、长按释放功能。比如说有几个LED灯，要实现多种闪烁效果，比如说隔2秒闪1次，隔5秒闪3次等等。比如说有大量串口数据收发，如何实现不丢一个字节？\n\n\n\n\n\n\n\n\n\n总之一句话：写复杂的产品程序，一定要有好的程序架构做支撑！就像用ucos，rtos系统，其实就是解决你程序架构的问题。\n内核移植\n\n\n\n\n\n\n\n\n移植流程\n\n拷贝OS_System.c和OS_Sysem.h文件到工程目录并添加到keil工程里\n把void OS_ClockInterruptHandle(void)放在stm32的systick 10ms秒中断函数里，为系统提供一个时钟节拍基准。\n调用OS_CPUInterruptCBSRegister(CPUInterrupt_CallBack_t pCPUInterruptCtrlCBS)函数，传入开关stm32总中断控制函数。\n\n\n\n上面唯一需要注意的是就是要注意编写单片机总中断函数\n开关中断在操作系统里一般称为&#x3D;&#x3D;临界&#x3D;&#x3D;，作用就是防止操作数据的时候，数据被意外改变导致不可预知的BUG,我们单片机程序在跑的时候，可能会被中断打断，然后先去执行中断里的程序。在执行中断里的程序的时候又可能会被优先级更高的中断打断，这个时候又去执行优先级更高的中断程序了。如果这3个地方都有对同一个指针或者变量进行操作，就很有可能出现不可预知的问题。而程序大了以后，这种情况又是难免的。\n创建任务，测试移植是否成功\n\n\n\n\n\n\n\n\n计算机永远第一步是打印hello world,而我们嵌入式永远的第一步就是点灯\n我们这里测试的是每2秒LED_WIFI反转一下\n那么我们就需要创建任务了\n\n系统执行流程\n\n系统任务结构体OS_TaskTypeDef\n任务初始化函数OS_TaskInit\n任务创建函数OS_CreatTask\n任务调度函数OS_ClockInterruptHandle\n开始任务函数OS_Start\n\n\n\n\n\n\n\n\n\n\n我们通过板子小灯已经发现我们移植成功了\n这个程序架构内核最大的作用：\n\n\n\n\n\n\n\n\n1.能为每个任务分配单独的执行频率，一般都是10ms，最小也是10ms，当然可根据需要改成1ms。这样的话一些不需要经常执行的任务，就可以把调度时间调长一点，释放CPU的资源。这里的任务指的就是函数，比如说Led处理函数，按键处理函数，RFD解码函数等等。\n2.提供了产品开发当中常用的算法：队列。\n内核队列队列的作用\n\n\n\n\n\n\n\n\n队列简单来说就是开辟一个数组(内存空间)，然后有一个队列头指针pHead和一个队列尾指针pTail。\n杭哥是链表讲队列的，我们这边用数组\n为什么一个数组存储要搞这么复杂？目的是为了设定一个数据存储和读取规则，数据在这个数组里面遵循先进先出的规则，不能插队。\n这样做最大的好处就是，数据不会丢失\n比如说我们做串口通讯的时候，通常是一帧数据过来，然后在串口中断里接收数据，同时在while(1)循环里解析和处理数据\n这种方式可能会出现一个问题，就是while(1)循环里的串口数据还没解析完，又有一帧新的数据过来，那老的数据就会被覆盖掉(这就是”插队”)，这个时候队列就发挥作用了。\n串口中断直接把接收的字节数据都丢进队列里，while(1)不断从队列里取数据，只要队列够大，基本不存在丢包和插队的问题。\n队列清空函数\n\n\n\n\n\n\n\n\n\n/********************************************************************************************************\n*  @函数名   S_QueueEmpty\n*  @描述     清空一个队列\n*  @参数     Head-队列头地址,  Tail-队列尾地址,   HBuff-队列缓存数组首地址\n*  @返回值   无\n*  @注意    无\n********************************************************************************************************/\nvoid S_QueueEmpty(unsigned char** Head, unsigned char** Tail, unsigned char* HBuff)\n&#123;\n\t*Head = HBuff;\n\t*Tail = HBuff;\n&#125;\n\n入队函数\n\n\n\n\n\n\n\n\n\n/********************************************************************************************************\n*  @函数名   S_QueueDataIn\n*  @描述     输入一个字节数据进队列\n*  @参数     Head-队列头地址,  Tail-队列尾地址,   HBuff-队列缓存数组首地址  Size-对列大小\n*            HData-入队的数据首地址      DataSize-入队数据的大小\n*  @返回值   无\n*  @注意     无\n********************************************************************************************************/\nvoid S_QueueDataPush(unsigned char** Head, unsigned char** Tail, unsigned char* HBuff, unsigned short Size, unsigned char* HData, unsigned short DataSize)\n&#123;\n\tunsigned short num;\n\tunsigned char IptStatus;\t\n\tfor (num = 0; num &lt; DataSize; num++, HData++)\n\t&#123;\n\t\t**Tail = *HData;\n\t\t(*Tail)++;\n\t\tif (*Tail == HBuff + Size)\n\t\t\t*Tail = HBuff;\n\t\tif (*Tail == *Head)\n\t\t&#123;\n\t\t\tif (++(*Head) == HBuff + Size)\n\t\t\t\t*Head = HBuff;\n\t\t&#125;\n\t&#125;\n&#125;\n\n出队函数\n\n\n\n\n\n\n\n\n\n/********************************************************************************************************\n*  @函数名   S_QueueDataPop\n*  @描述     从队列里取出一个数据\n*  @参数     Head-队列头地址,  Tail-队列尾地址,   HBuff-队列缓存   Size-对列大小   Data-出队数据指针\n*  @返回值   取出的数据\n*  @注意     无\n********************************************************************************************************/\nunsigned char S_QueueDataPop(unsigned char** Head, unsigned char** Tail, unsigned char* HBuff, unsigned short Size, unsigned char* Data)\n&#123;\n\tunsigned char back = 0;\n\tunsigned char IptStatus;\n\t\n\t*Data = 0;\n\tif (*Tail != *Head)\n\t&#123;\n\t\t*Data = **Head;\n\t\tback = 1;\n\t\tif (++(*Head) == HBuff + Size)\n\t\t\t*Head = HBuff;\n\t&#125;\n    \n\treturn back;\n&#125;\n\n队长函数\n\n\n\n\n\n\n\n\n\n/********************************************************************************************************\n*  @函数名   S_QueueDataSize\n*  @描述     判断队列里数据的长度\n*  @参数     Head-队列头地址,  Tail-队列尾地址,   Size-对列长度\n*  @返回值   队列里有数据个数\n*  @注意     无\n********************************************************************************************************/\nunsigned short S_QueueDataSize(unsigned char** Head, unsigned char** Tail, unsigned short Size)\n&#123;\n\tif (*Tail > *Head)\n\t\treturn *Tail - *Head;\n\tif (*Tail &lt; *Head)\n\t\treturn *Tail + Size - *Head;\n\treturn 0;\n&#125;\n\n宏函数\n\n\n\n\n\n\n\n\n\n#define QueueEmpty(x)\t         S_QueueEmpty((unsigned char**)&amp;(x).Head,(unsigned char**)&amp;(x).Tail,(unsigned char*)(x).Buff) \n#define QueueDataPush(x,y,z)     S_QueueDataPush((unsigned char**)&amp;(x).Head,(unsigned char**)&amp;(x).Tail,(unsigned char*)(x).Buff,sizeof((x).Buff),(y),(z))\n#define QueueDataPop(x,y)        S_QueueDataPop((unsigned char**)&amp;(x).Head,(unsigned char**)&amp;(x).Tail,(unsigned char*)(x).Buff,sizeof((x).Buff),(y)) \n#define QueueDataSize(x)\t     S_QueueDataSize((unsigned char**)&amp;(x).Head,(unsigned char**)&amp;(x).Tail,sizeof((x).Buff))  \n\n\n现在在keil里面测试\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n到现在就可以结束了，这个内核仅仅只有百分之10的功能，灵活度也不怎么高，以后试试内存管理，要是这个添加进去了就会有量的改变。好期待呀。\n二级标题三级标题四级标题五级标题六级标题","slug":"wifi主机/wifi主机第二部分  自建轻量内核","date":"2020-08-15T10:49:36.000Z","categories_index":"单片机","tags_index":"STM32,主机","author_index":"虫子"},{"id":"cc1ca5f7b232d316a6eb483fac865b2d","title":"WIFI主机-打通域界","content":"WIFI主机\n\n\n\n\n\n\n\n\n现在才是产品阶段\n433M无线通讯的一些常识\n\n\n\n\n\n\n\n\n我们这个主机是防盗报警主机，所以必须要配合周边传感器形成一道防御网络，比如说门磁传感器装在大门，开门后，门磁探测器触发然后通过433MHz频段的无线发送一组数据给主机，然后主机接收到就报警。\n为什么要用无线\n因为免去了布线的麻烦，但也伴随着一些问题，比如说同频干扰，安全性等，但是综合考虑还是无线的比较适用\n为什么选用433M频率\n常用频段有非常多种，315&#x2F;433&#x2F;868,2.4G，433M成本低廉，距离远，穿墙能力强，缺点就是传输速率小，通常只适合做一些无线数据量小的产品，比如说只需要传输几个字节的。而且数据传输也是透明的，数据容易被破解，安全性比较差。但是大多数环境下都能正常使用，也有一些用Lora做的，功耗更低，但成本高些\n无线接收模块简介\n\n\n\n\n\n\n\n\n为什么要用433M无线接收模块\n数据通过无线传输，如果是发送数据就需要把单片机输出的&#x3D;&#x3D;数字信号转换成电磁波&#x3D;&#x3D;进行传播\n如果是接收数据的话，就需要把这种&#x3D;&#x3D;电磁波转换成数字信号&#x3D;&#x3D;，而接收模块就是帮你把&#x3D;&#x3D;电磁波转换成数字信号&#x3D;&#x3D;输出，用很高的性价比简化你的硬件电路，然后用单片机来把&#x3D;&#x3D;数字信号解码还原真实的数据&#x3D;&#x3D;\n\n\n我们通过433M接收模块引脚定义可以看到，最终模块处理好的数据就是通过一个DAT引脚输出的\n我们通过原理图可以看到，433M模块2,3脚其实是连在一起的，然后接到单片机PA11引脚。所以首先从硬件上可以判断出，是通过433M模块是用单口通讯来传输数据的。\n\nEV1527和2262编码\n\n\n\n\n\n\n\n\n不管是电磁波也好，还是433M接收模块输出的数字信号也好，这都只是一种传输数据的物理层媒介。就像人都能通过声音去和别人交流，但是除了有声音以外，你们语言(中文、英文)还得相同才能表达出彼此的想法\n那无线传输也是这样，有了传输渠道，那数据过去之后，双方还得有统一的数据格式，这样才能正确的还原原始数据\n而EV1527和2262就是一种无线通讯的数据格式\nEV1527和2262都有专门的芯片去实现这种数据格式，但是我们产品为了节约成本，采用软解码\nEV1527和2262数据格式\n\n\n\n\n\n\n\n\n同步头+24Bit数据+结束位\n结束位一般不解码，所以我们一般关注同步头和24Bit数据\n同步头：\n首先是&#x3D;&#x3D;4LCK&#x3D;&#x3D;的高电平脉宽，时间一般是&#x3D;&#x3D;400us&#x3D;&#x3D;，然后是&#x3D;&#x3D;124LCK&#x3D;&#x3D;低电平脉宽，时间一般是&#x3D;&#x3D;12.4ms&#x3D;&#x3D;高电平和低电平是&#x3D;&#x3D;31倍&#x3D;&#x3D;的关系\n24Bit数据定义：总共3个字节，前20位是地址码，后面4位是数据码\n比如&#x3D;&#x3D;0xAA 0xBB 0xC2&#x3D;&#x3D;AABBC是地址码，2是数据码\n地址码每个探测器唯一，相同的探测器地址码不同，数据码相同，比如说门磁开门是0x0A，关门0x0B等等。\n我们数据传输的时候，是一个个Bit这样去传输的，用不同的脉宽代表Bit”0”和Bit”1”\n\n\n\n这个时间可能不同的厂家做出来的探测器各不同，但是专业的都知道高低电平是遵循3倍的关系\n那数据位一共是需要传输3个字节，也就是24个Bit\n还有最后一个结束位，一般不解码\nEV1527和2262编码有什么区别\n\n\n\n\n\n\n\n\n两种编码方式就是地址位和数据位的区别。\nEV1527是20个Bit的地址码，4个Bit的数据码。2262是16个Bit的地址码，8个Bit的数据码。\nEV1527牺牲了数据码位数，增加了地址码位数，减少了不同设备的重复几率。\n2262牺牲了地址码位数，增加了数据码位数。\n一帧数据的波形图\n\n\n\n\n\n\n\n\n\n多帧数据的波形图\n\n\n\n\n\n\n\n\n\n做探测器的时候，一般触发一次要发15-20帧数据，根据主机来调节，理论上帧数越多主机越容易接收到，但是发的数据帧越多功耗也越大，也更占用频段，可能会干扰到其他探测器触发后发送的数据\n一般触发一次要发15-20帧数据，因为数据最终通过电磁波传播，存在太多不确定性。比如同频干扰，环境影响等等，&#x3D;&#x3D;数据从电磁波解码成数字信号&#x3D;&#x3D;到单片机的时候，前面几帧可能都是不完整的，所以你如果只发1帧甚至几帧数据的话，基本上灵敏度非常低，经常接收不到\n具体发多少帧，一般是根据主机来调节，如果主机程序写的好的话，通常15帧足以，理论上帧数越多主机越容易接收到，但是发的数据帧越多功耗也越大，也更占用频段，可能会干扰到其他探测器触发后发送的数据。\n代码实现思路\n\n\n\n\n\n\n\n\n把串行输入的编码数据帧，还原成编码之前的状态，读取其中的地址码和按键码，称之为&#x3D;&#x3D;解码&#x3D;&#x3D;。\n数据帧都是由&#x3D;&#x3D;同步头&#x3D;&#x3D;开始，然后是 &#x3D;&#x3D;24位&#x3D;&#x3D;的数据码，并且此数据帧在门磁探测器、遥控器等按键的过程中是重复出现的，我们首先要判断同步码，判断出了同步码，就知道数据码是从那一位开始了。对于一款量产的无线探测器来说，他的编码是固定值，也就是说它发射的数据帧的脉冲宽度是不变的，所以我们可以通过测量高低脉冲宽度的方式来分辨同步码、逻辑“1”、逻辑“0”\n具体的方法是这样的，首先启用定时器，定时器产生一个50us的定时中断。在中断程序中，我们读取数据输入引脚的状态，如果为高电平，就在高电平状态累加计数，反之就在低电平状态计数，当电平发生上升沿变化的时候，判断接收到的高低电平宽度的值是否符合同步信号的要求，如果符合就进入数据位的接收，以同样的方式判断逻辑“1”或逻辑“0”。如果接收过程中出现不符合要求的电平状态，就退出接收，为了增加可靠性和灵敏度，我们一般要求做容错机制，就是除了判断高低电平脉宽以外，还要算它们高低电平脉宽的倍数，把它范围适当加大，比如说&#x3D;&#x3D;实际是3倍。那我们可以设置成2-5倍&#x3D;&#x3D;，这样能最大程度满足灵敏度的需求，但是范围也不能调太广，否则会产生误报，这个都是根据产品量产验证后得来的经验和数据。\n代码实战RF解码流程：\n\n\n\n\n\n\n\n\n\n配置无线接收GPIO为输入模式\n创建50us定时器中断，并在中断函数里读取无线接收GPIO电平存起来丢进队列。\n创建一个RF解码任务，轮训任务里对电平队列里的数据进行解析\n\n解码任务数据解析流程\n\n\n\n\n\n\n\n\n\n先把队列电平&#x3D;&#x3D;数据取出&#x3D;&#x3D;，把高低电平脉宽时间都计算出来丢进&#x3D;&#x3D;脉宽队列&#x3D;&#x3D;。\n解析脉宽队列数据，开始判断同步头。\n如果同步头判断成功，则进入真正的RF数据解析，根据脉宽来判断是Bit”1”或者Bit”0”。\n连续接收到24个Bit有效数据后把数据整合成到数据里，数组大小是3个字节。\n通过回调函数把数据传递给应用层。\n\nhal_RFDConfig  RFD底层配置函数\n\n\n\n\n\n\n\n\n\n//RFD底层IO口配置函数\nstatic void hal_RFDConfig(void)\n&#123;\n\tGPIO_InitTypeDef GPIO_InitStructure;\t\n\t//开时钟\n\tRCC_APB2PeriphClockCmd(RFD_RX_GPIO_CLK, ENABLE);\n\t\n\tGPIO_InitStructure.GPIO_Pin = RFD_RX_PIN;\n\tGPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n\t//上拉输入，CPU可以随时读取IO口的电平状态，减少干扰\n\tGPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; \n\tGPIO_Init(RFD_RX_PORT, &amp;GPIO_InitStructure);\n&#125;\n\nhal_GetRFDIOSta  接收RFD io口电平状态函数\n\n\n\n\n\n\n\n\n\n//获取RFD接收IO口电平状态\nstatic uint8_t hal_GetRFDIOSta(void)\n&#123;\n\treturn (GPIO_ReadInputDataBit(RFD_RX_PORT, RFD_RX_PIN));\t\t\n&#125;\n\nhal_PulseAQT_Handle  RFD脉冲采集中断函数\n\n\n\n\n\n\n\n\n\n//RFD脉冲采集(Acquisition)，这个作为回调函数放在50us定时器中断里\nstatic void hal_PulseAQT_Handle(void)\n&#123;\n\tstatic uint8_t Temp, Count1 = 0;\n\tTemp &lt;&lt;= 1;\n\tif(hal_GetRFDIOSta()) \n\t\tTemp |= 0x01;  \n\telse \n\t\tTemp &amp;= 0xFE;\n\tif(++Count1 == 8)\n\t&#123;\n\t\tCount1 = 0;\n\t\tQueueDataPush(RFDBuff, &amp;Temp, 1);\n\t&#125;\n\thal_ResetTimer(T_RFD_RCV,T_STA_START);\n&#125;\n\nhal_RFDProc  RFD任务函数  (我写的函数中最恶心的一个)\n\n\n\n\n\n\n\n\n这个解码比较长，需要考虑容错率，大概200行，我除了红黑就他最恶心了\n所以分段讲解\n\n这里有一个细节就是我case RFD_READ_CLKLEN里面没有break，也就是脉宽计数结束后，直接进入下一个case\n\n\n//RFD任务函数\nvoid hal_RFDProc(void)\n&#123;\n\t//创建一个脉宽队列\n\tQueue256 ClkTimeBuff;\n\tstatic uint16_t Time1 = 0, Time2 = 0;\n\tstatic uint8_t ReadDataFlag = 0;\n\tstatic uint8_t Len, Code[3];\n\tstatic uint8_t CodeTempBuff[3];\n    //收码\n\tswitch(RFDRcvSteps)\n\t&#123;\t\t\t\n\t\tcase RFD_READ_CLKLEN:\n\t\t&#123;\n\t\t\tuint8_t Temp, Num;\n\t\t\tstatic uint8_t Dsta = 0;\n\t\t\tstatic uint16_t Count = 0;\n\t\t\tQueueEmpty(ClkTimeBuff);\n\t\t\twhile(QueueDataPop(RFDBuff, &amp;Temp))\n\t\t\t&#123;\n\t\t\t\t\tNum = 8;\t\t\t\t\n\t\t\t\t\twhile(Num--)\n\t\t\t\t\t&#123;\t\t\t\t\t\t\t\n\t\t\t\t\t\tif(Dsta)\n\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t//1\n\t\t\t\t\t\t\tif(!(Temp&amp;0x80))\t//这里检测电平是否为低，如果为低代表高电平脉宽结束\n\t\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t\tuint8_t Data;\n\t\t\t\t\t\t\t\tData = Count / 256;\t\t\t//存储高电平脉宽高字节\n\t\t\t\t\t\t\t\tData |= 0x80;\t\t\t\t//电平标志 1为高 0为低\n\t\t\t\t\t\t\t\tQueueDataPush(ClkTimeBuff, &amp;Data, 1);\n\t\t\t\t\t\t\t\tData = Count % 256;\t\t\t//存储高电平脉宽低字节\n\t\t\t\t\t\t\t\tQueueDataPush(ClkTimeBuff, &amp;Data, 1);\n\t\t\t\t\t\t\t\t//注意这里Data的值x50us等于脉宽时间\n\t\t\t\t\t\t\t\tDsta = 0;\n\t\t\t\t\t\t\t\tCount = 0;\n\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t&#125;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t//0\n\t\t\t\t\t\t\tif(Temp&amp;0x80)\t//这里检测电平是否为高，如果为高代表低电平脉宽结束\n\t\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t\tuint8_t Data;\n\t\t\t\t\t\t\t\tData = Count / 256;\t\t//存储低电平脉宽高字节\n\t\t\t\t\t\t\t\t//Data &amp;= 0xFF7F;\t\t//电平标志 1为高 0为低\n\t\t\t\t\t\t\t\tData &amp;= 0x7F;\t\t    //Bit7为脉宽电平标志,1为高 0为低\n\t\t\t\t\t\t\t\tQueueDataPush(ClkTimeBuff, &amp;Data, 1);\n\t\t\t\t\t\t\t\tData = Count % 256;\t\t//存储低电平脉宽低字节\n\t\t\t\t\t\t\t\tQueueDataPush(ClkTimeBuff, &amp;Data, 1);\t\n\t\t\t\t\t\t\t\t//注意这里Data的值x50us等于脉宽时间\n\t\t\t\t\t\t\t\tDsta = 1;\n\t\t\t\t\t\t\t\tCount = 0;\n\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t&#125;\n\t\t\t\t\t\tCount++;\n\t\t\t\t\t\tTemp &lt;&lt;= 1;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\tcase RFD_READ_DATA:\n\t\t&#123;\n\t\t\twhile(QueueDataSize(ClkTimeBuff))\t//判断有没波形数据\n\t\t\t&#123;   //读头\n\t\t\t\tif(!ReadDataFlag)\n\t\t\t\t&#123;\n\t\t\t\t\tunsigned char Temp;\n\t\t\t\t\twhile(!Time1 || !Time2)\n\t\t\t\t\t&#123;\t\t\t\t\t\n\t\t\t\t\t\tif(!Time1)\t\t\n\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t//获取第一个波形数据\n\t\t\t\t\t\t\twhile(QueueDataPop(ClkTimeBuff, &amp;Temp))\n\t\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t\t\t//Driver_GUART1SendByByter('*');\n\t\t\t\t\t\t\t\t\tif(Temp&amp;0x80)\t\t//先获取高电平波形\n\t\t\t\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t\t\t\t\tTemp &amp;= 0x7F;\n\t\t\t\t\t\t\t\t\t\t\tTime1 = Temp &lt;&lt; 8;\n\t\t\t\t\t\t\t\t\t\t\tQueueDataPop(ClkTimeBuff, &amp;Temp);\n\t\t\t\t\t\t\t\t\t\t\tTime1 += Temp;\n\t\t\t\t\t\t\t\t\t\t\tTime2 = 0;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\tQueueDataPop(ClkTimeBuff, &amp;Temp);\t\n\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t\tif(!QueueDataSize(ClkTimeBuff))\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t&#125;\t\t\t\t\n\t\t\t\t\t\tif(!Time2)\n\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t//获取低电平波形\n\t\t\t\t\t\t\tQueueDataPop(ClkTimeBuff, &amp;Temp);\n\t\t\t\t\t\t\tTime2 = Temp * 256;\n\t\t\t\t\t\t\tQueueDataPop(ClkTimeBuff, &amp;Temp);\n\t\t\t\t\t\t\tTime2 += Temp;\n\t\t\t\t\t\t\t//判断高电平*20时间，和高电平*44的时间\n\t\t\t\t\t\t\tif((Time2 >= (Time1*RFD_TITLE_CLK_MINL))\n\t\t\t\t\t\t\t&amp;&amp; (Time2 &lt;= (Time1*RFD_TITLE_CLK_MAXL)))\n\t\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t\tTime1 = 0;\n\t\t\t\t\t\t\t\tTime2 = 0;\n\t\t\t\t\t\t\t\tLen = 0;\n\t\t\t\t\t\t\t\tReadDataFlag = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t&#125;\t\t\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t\tTime1 = 0;\n\t\t\t\t\t\t\t\tTime2 = 0;\n\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t&#125;\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\t\n\t\t\t\t//读数据\t\t\n\t\t\t\tif(ReadDataFlag)\n\t\t\t\t&#123;\n\t\t\t\t\tunsigned char Temp;\n\t\t\n\t\t\t\t\tif(!Time1)\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tif(QueueDataPop(ClkTimeBuff, &amp;Temp))\n\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t//这里经过头验证后，第一个字节肯定是高电平，所以要&amp;0x7F把高电平标志位清除\n\t\t\t\t\t\t\t\tTemp &amp;= 0x7F;\n\t\t\t\t\t\t\t\tTime1 = Temp &lt;&lt; 8;\n\t\t\t\t\t\t\t\tQueueDataPop(ClkTimeBuff, &amp;Temp);\n\t\t\t\t\t\t\t\tTime1 += Temp;\n\t\t\t\t\t\t\t\tTime2 = 0;\n\t\t\t\t\t\t&#125;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t&#125;\t\t\t\n\t\t\t\t\tif(!Time2)\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tif(QueueDataPop(ClkTimeBuff, &amp;Temp))\n\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\tbool RecvSuccFlag;\n\t\t\t\t\t\t\tTime2 = Temp * 256;\n\t\t\t\t\t\t\tQueueDataPop(ClkTimeBuff, &amp;Temp);\n\t\t\t\t\t\t\tTime2 += Temp;\t\t\n\t\t\t\t\t\t\tif((Time1 > (Time2*RFD_DATA_CLK_MINL))  \n\t\t\t\t\t\t\t&amp;&amp; (Time1 &lt;= (Time2*RFD_DATA_CLK_MAXL)))\n\t\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t\tunsigned char i, c = 0x80;\n\t\t\t\t\t\t\t\t//'1'\n\t\t\t\t\t\t\t\tfor(i = 0; i &lt; Len%8; i++)\n\t\t\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t\t\tc >>= 1;\n\t\t\t\t\t\t\t\t\tc &amp;= 0x7F;\n\t\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t\t\tCode[Len/8] |= c;\n\t\t\t\t\t\t\t\tRecvSuccFlag = 1; \n\t\t\t\t\t\t\t&#125;\t\t\n\t\t\t\t\t\t\telse if((Time2 > (Time1*RFD_DATA_CLK_MINL))\n\t\t\t\t\t\t\t     &amp;&amp; (Time2 &lt;= (Time1*RFD_DATA_CLK_MAXL)))\n\t\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t\tunsigned char i, c = (unsigned char)0xFF7F;\n\t\t\t\t\t\t\t\t//'0'\n\t\t\t\t\t\t\t\tfor(i = 0; i &lt; Len%8; i++)\n\t\t\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t\t\tc >>= 1;\n\t\t\t\t\t\t\t\t\tc |= 0x0080;\n\t\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t\t\tCode[Len/8] &amp;= c;\n\t\t\t\t\t\t\t\tRecvSuccFlag = 1;\n\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t\t//error\n\t\t\t\t\t\t\t\tRecvSuccFlag = 0;\n\t\t\t\t\t\t\t\tReadDataFlag = 0;\n\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t\tTime1 = 0;\n\t\t\t\t\t\t\tTime2 = 0;\n\t\t\t\t\t\t\tif((++Len ==24)  &amp;&amp; RecvSuccFlag)\n\t\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t\tReadDataFlag = 0;\n\t\t\t\t\t\t\t\tif((CodeTempBuff[0]==Code[0])\n\t\t\t\t\t\t\t\t &amp;&amp;(CodeTempBuff[1]==Code[1])\n\t\t\t\t\t\t\t\t &amp;&amp;(CodeTempBuff[2]==Code[2]))\n\t\t\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t\t\tRFD_CodeHandle(Code);\n\t\t\t\t\t\t\t\t&#125;else\n\t\t\t\t\t\t\t\t&#123;\n\t\t\t\t\t\t\t\t\tmemcpy(CodeTempBuff, Code, 3);\n\t\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t&#125;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\t\t\n&#125;\n\nhal_RFDDecodeFlt_Handle  RFD重复码过滤处理\n\n\n\n\n\n\n\n\n创建定时器的时候丢进去\n\n//RFD重复码过滤处理，1s内有重复码的话不做重复处理，这个作为回调函数放在1s定时器中断里\nstatic void hal_RFDDecodeFlt_Handle(void)\n&#123;\t\t \n\tRFD_DecodeFltTimerOk = 1;\n&#125;\n\nRFD_CodeHandle  RFD代码过滤函数\n\n\n\n\n\n\n\n\n不仅仅有过滤作用，还有把数据传给应用层的作用\n\n\nhal_RFCRcvCBSRegister  RFD接收回调注册函数\n\n\n\n\n\n\n\n\n\n应用层RfdRcvHandle  RFD接收回调函数\n二级标题三级标题四级标题五级标题六级标题","slug":"wifi主机/wifi主机第五部分  打通界域","date":"2020-08-15T10:49:36.000Z","categories_index":"单片机","tags_index":"STM32,主机","author_index":"虫子"},{"id":"bc733f0dd5782bf3825c926b0df036f7","title":"WIFI主机-波形创建","content":"WIFI主机报警电路原理分析\n\n\n\n\n\n\n\n\n\nPA0引脚为普通IO口功能，输出低电平芯片工作，输出高电平，芯片不工作。(输出低电平三极管截止，那么CTRL就会被拉高)PB4作为复用功能，用于PWM输出从而驱动喇叭发出声音。\nPB4对应定时器3的CH1(通道1)。\n\n可以看出TIM3_CH1是重定义功能\n什么是PWM？单片机怎么输出PWM？\n\n\n\n\n\n\n\n\nPWM就是输出脉宽（即占空比）可调的方波信号。\n\n有些单片机内部的定时器有PWM输出功能，只需简单配置就能让相应的IO口输出不同频率的PWM。\n想输出一个PWM，必须知道几个关键参数：\n\n周期ARR\n占空比CCR\n计数器CNT\n\n当CNT的值小于CCR的时候，引脚输出高电平。当CNT的值大于CCR的时候，引脚输出低电平。当CNT的值等于ARR的时候，CNT重新初始化为0\n\n喇叭工作原理\n\n\n\n\n\n\n\n\n喇叭这个东西算是一个行业，所以对于开发者使用来说，正确的做法是只需要知道无源的喇叭一般是通过PWM来控制它发出声音就可以了，频率一般在2-4KHZ，不同的频率发出不同的音调。\n而报警声就是在不同的时间控制不同的频率，实现音调快速不断地切换来发出不同的声音组合，而什么样的音调组合能够发出制定的音乐又是一个新的行业。\nSTM32用定时器3实现频率可调PWM输出\n\n\n\n\n\n\n\n\nTIMx-&gt;ARR\n定时周期，也就是我们PWM的频率或者周期。\nTIMx-&gt;PSC\n预分频器，时钟源经该预分频器才是定时器计数时钟 CK_CNT，它设定 PSC 寄存器的值。计算公式为：计数器时钟频率 (fCK_CNT) 等于 fCK_PSC &#x2F; (PSC[15:0] + 1)，可实现 1 至 65536 分频。如果我们系统时钟是72M，那把PSC设置成71，最终计数器时钟就是1M，也就是1us。\nTIMx-&gt;CCR1\n脉冲宽度，用来调节PWM占空比用的，计数器CNT会与这个寄存器的值进行对比，然后控制引脚输出高电平或者低电平来实现PWM功能\n代码Beep配置\n\n\n\n\n\n\n\n\n\n//BEEP定时器和普通口配置\nstatic void hal_BEEP_TIM_Config(void)\n&#123;\n\tGPIO_InitTypeDef GPIO_InitStructure;\n\n    //输出比较通道 GPIO 初始化\n\t//先开时钟\n\tRCC_APB2PeriphClockCmd(BEEP_TIM_CH1_GPIO_CLK | RCC_APB2Periph_AFIO, ENABLE);\n    //调试复位口引脚重映射配置  把这个功能关掉\n\tGPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE);\n\t\n\tGPIO_InitStructure.GPIO_Pin =  BEEP_TIM_CH1_PIN;\n\t//复用推挽  CH1的PWM脉冲波形\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n    GPIO_Init(BEEP_TIM_CH1_PORT, &amp;GPIO_InitStructure);\n\n    //beep控制口初始化\n\t//先开时钟\n\tBEEP_EN_APBxClock_FUN(BEEP_EN_GPIO_CLK, ENABLE);\n\t\n\tGPIO_InitStructure.GPIO_Pin =  BEEP_EN_PIN;\n\t//开漏\n    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;\n    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n    GPIO_Init(BEEP_EN_PORT, &amp;GPIO_InitStructure);\n\t\n\t/*--------------------时基结构体初始化-------------------------*/\n    // 开启定时器时钟,我们这里内部时钟CK_INT=72M\n    BEEP_TIM_APBxClock_FUN(BEEP_TIM_CLK,ENABLE);\n\t//Timer3部分重映射  TIM3_CH1->PB4 把这个开下来\n\tGPIO_PinRemapConfig(GPIO_PartialRemap_TIM3, ENABLE); \n\t//决定时钟频率\n\tTIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;\n\t// 自动重装载寄存器的值，累计TIM_Period+1个频率后产生一个更新或者中断\n\t//配置自动重装载寄存器arr，决定的是信号的周期,计多少个数\n\tTIM_TimeBaseStructure.TIM_Period=BEEP_TIM_PERIOD;\t\n\t// 驱动CNT计数器的时钟 = Fck_int/(psc+1)\n\t//分频器决定的是计数器记一次的时间\n\tTIM_TimeBaseStructure.TIM_Prescaler= BEEP_TIM_PSC;\t\n\t// 时钟分频因子 ，配置死区时间时需要用到，我们这边不是控制电机，默认0\n\tTIM_TimeBaseStructure.TIM_ClockDivision=TIM_CKD_DIV1;\t\t\n\t// 计数器计数模式，设置为向上计数\n\tTIM_TimeBaseStructure.TIM_CounterMode=TIM_CounterMode_Up;\t\t\n\t// 重复计数器的值，没用到不用管  高级定时器才有，我们这里实际上没用到\n\tTIM_TimeBaseStructure.TIM_RepetitionCounter=0;\t\n\t// 初始化定时器\n\tTIM_TimeBaseInit(BEEP_TIM, &amp;TIM_TimeBaseStructure);\n\t\n\t/*--------------------输出比较结构体初始化-------------------*/\t\t\n    //决定占空比\n\tTIM_OCInitTypeDef  TIM_OCInitStructure;\n\t// 配置为PWM模式1 选择定时器模式:TIM脉冲宽度调制模式2\n\tTIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;\n\t// 输出使能\n\tTIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;\n\t// 互补输出使能  只有高级定时器才有，我们这里关闭即可\n\tTIM_OCInitStructure.TIM_OutputNState = TIM_OutputNState_Disable; \n\t// 设置占空比大小\n\tTIM_OCInitStructure.TIM_Pulse = BEEP_TIM_PULSE;\n\t// 输出通道电平极性配置，通道是否有效是通过极性配置的\n\tTIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;\n\t// 互补输出通道电平极性配置  没有互补通道这里无所谓\n\tTIM_OCInitStructure.TIM_OCNPolarity = TIM_OCNPolarity_High;\n\t// 输出通道空闲电平状态配置\n\tTIM_OCInitStructure.TIM_OCIdleState = TIM_OCIdleState_Set;\n\t// 互补输出通道空闲电平状态配置  这个只有高级定时器有  我们这无所谓\n\tTIM_OCInitStructure.TIM_OCNIdleState = TIM_OCNIdleState_Reset;\n\t//根据T指定的参数初始化外设TIM3 OC1\n\tTIM_OC1Init(BEEP_TIM, &amp;TIM_OCInitStructure);\n\t//使能TIM3在CCR1上的预装载寄存器\n\tTIM_OC1PreloadConfig(BEEP_TIM, TIM_OCPreload_Enable);\n\t\n\t\n\t//使能TIM3\n\tTIM_Cmd(BEEP_TIM, ENABLE);  \n&#125;\n\nhal_BeepPwmCtrl  喇叭pwm控制函数\n\n\n\n\n\n\n\n\n\n//喇叭PWM控制\nvoid hal_BeepPwmCtrl(uint8_t cmd)\n&#123; \n\t//1把控制脚拉低就会工作，0把控制脚拉高就会不工作\n\tcmd ? GPIO_ResetBits(BEEP_EN_PORT,BEEP_EN_PIN)\n\t    : GPIO_SetBits(BEEP_EN_PORT,BEEP_EN_PIN);\n&#125;\n\nhal_BeepPwmHandle  喇叭pwm中断函数\n\n\n\n\n\n\n\n\n\n//喇叭中断函数\nstatic void hal_BeepPwmHandle(void)\n&#123;\n\tstatic uint8_t i=0;\n\t//hal_SetBeepFreq(NoteFreqAry[i]);\n\t//改变ARR的值来改变周期\n\tTIM_SetAutoreload(TIM3,NoteFreqAry[i]);\n\t//改变CRR的值来改变占空比(我们这里一直都用周期的一半)\n\tTIM_SetCompare1(TIM3,NoteFreqAry[i]/2);\n\t//计数器清零\n\tTIM_SetCounter(TIM3,0);\n\t//6ms换一个频率\n\ti++;\n\tif(i>BP_num)\n\t&#123;\n\t\ti=0;\n\t&#125;\n\t//不要忘了重启定时器\n\thal_ResetTimer(T_BEEP,T_STA_START);\n&#125;   \n\nhal_BeepInit  喇叭初始化函数\n\n\n\n\n\n\n\n\n\n//喇叭初始化\nvoid hal_BeepInit(void)\n&#123;\n\thal_BEEP_TIM_Config();\n\t//创建一个喇叭定时器 50us*120=6ms\n\thal_CreatTimer(T_BEEP,hal_BeepPwmHandle,120,T_STA_START);\n\t//让喇叭芯片可以工作\n\thal_BeepPwmCtrl(1);\n&#125;\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n二级标题三级标题四级标题五级标题六级标题","slug":"wifi主机/wifi主机第八部分  波形创建者","date":"2020-08-15T10:49:36.000Z","categories_index":"单片机","tags_index":"STM32,主机","author_index":"虫子"},{"id":"f9f001f09edb1b9283e01c9882734988","title":"WIFI主机-高级","content":"WIFI主机\n\n\n\n\n\n\n\n\n我们c8t6有三个串口，但是用就用到了1,2\n\n通信的基本概念\n\n\n\n\n\n\n\n\n在计算机的设备与设备之间或集成电路之间常常需要进行数据传输\n并行与串行\n\n\n\n\n\n\n\n\n\n \n全双工、半双工和单工\n\n\n\n\n\n\n\n\n\n同步与异步\n\n\n\n\n\n\n\n\n\n有时钟线的基本都是同步\n\n没时钟线的基本都是异步\n在同步通讯中，数据信号所传输的内容绝大部分就是有效数据，而异步通讯中会包含有帧的各种标识符，所以同步通讯的效率更高，但是同步通讯双方的时钟允许误差较小，而异步通讯不需要时钟。\n通信的速率\n\n\n\n\n\n\n\n\nBitrate—比特率每秒钟传输的二进制位数，单位为比特每秒(bit&#x2F;s)\nBaudrate—波特率表示每秒钟传输的码元个数\n&#x3D;&#x3D;一个二进制位表示一个码元&#x3D;&#x3D;\n\n0V    ——   0 \n3.3V  ——    1\n\n&#x3D;&#x3D;两个二进制位表示一个码元&#x3D;&#x3D;\n\n0V  ——  00 \n2V  ——  01\n4V  ——  10\n6V  ——  11\n\n串口通信协议简介\n\n\n\n\n\n\n\n\n物理层规定通讯系统中具有机械、电子功能部分的特性，确保原始数据在物理媒体的传输。其实就是硬件部分。\n协议层协议层主要规定通讯逻辑，统一收发双方的数据打包、解包标准。其实就是软件部分。\n\n简单来说物理层规定我们用嘴巴还是用肢体来交流，\n协议层则规定我们用中文还是英文来交流。\n\n物理层3个串口通信的常用标准\n\n\n\n\n\n\n\n\n\nRS232标准\nUSB转串口  TTL标准\n原生的串口到串口  TTL-&gt;TTL\n\nRS-232 与 TTL 电平区别\n\n\n\n\n\n\n\n\n\n我们通常说的TTL电平是从单片机或芯片里面出来的\nRS232标准串口通讯结构图\n\n\n\n\n\n\n\n\n\n\nRS232标准串口主要用于工业设备直接通信\n电平转换芯片一般有MAX3232，SP3232\n\n\nDB9 标准的公头及母头接法\nUSB转串口通讯结构图\n\n\n\n\n\n\n\n\n\n\nUSB转串口主要用于设备跟电脑通信\n电平转换芯片一般有CH340、PL2303、CP2102、FT232\n使用的时候电脑端需要安装电平转换芯片的驱动\n\n原生的串口到串口\n\n\n\n\n\n\n\n\n\n\n原生的串口通信主要是控制器跟串口的设备或者传感器通信，不需要经过电平转换芯片来转换电平，直接就用TTL电平通信\nGPS模块、GSM模块、串口转WIFI模块、HC04蓝牙模块\n\n串口数据包的基本组成\n\n\n\n\n\n\n\n\n\n起始位：由1个逻辑 0 的数据位表示\n结束位：由 0.5、 1、 1.5 或 2 个逻辑 1 的数据位表示\n有效数据：在起始位后紧接着的就是有效数据，有效数据的长度常被约定为 5、 6、 7 或 8 位长\n校验位：可选，为的是数据的抗干扰性。\n校验方法分为：\n\n奇校验(odd)\n偶校验(even) \n0 校验(space)\n校验(mark)\n无校验(noparity)\n\n奇校验(odd) ：有效数据和校验位中“ 1”的个数为奇数\n比如一个 8 位长的有效数据为： 01101001，此时总共有 4 个“ 1”，为达到奇校验效果，校验位为“ 1”，最后传输的数据将是 8 位的有效数据加上 1 位的校验位总共 9 位\n偶校验(even) ：有效数据和校验位中“ 1”的个数为偶数\n比如一个 8 位长的有效数据为： 01101001，此时总共有 4 个“ 1”，为达到偶校验效果，校验位为“ 0”，最后传输的数据将是 8 位的有效数据加上 1 位的校验位总共 9 位\n0 校验是不管有效数据中的内容是什么，校验位总为“ 0”。\n1 校验是校验位总为“ 1”。\n无校验就是数据包中不包含校验位\n串口功能框图\n\n\n\n\n\n\n\n\n\nTX：数据发送\nRX：是数据接收\nSCLK：时钟，仅同步通信时使用\nnRTS：请求发送(Request To Send)\nnCTS：允许发送(Clear To Send)\n数据寄存器—USART_DR：9位有效，包含一个发送数据寄存器TDR和一个接收数据寄存器RDR。一个地址对应了两个物理内存\n\nUSART_CR1：M，0：8bit，1：9bit\nUSART_CR2：STOP\nUSART_CR1：PCE、PS、PEIE\nUSART_SR ：PE\nUSART_CR1：UE、TE、RE\nUSART_SR：TXE，Transmit data register empty\nUSART_CR1：TXEIE\nUSART_SR：TC，Transmission complete\nUSART_CR1：TCIE\nUSART_SR：RXNE，Read data register not empty\nUSART_CR1：RXNEIE\n波特率—每秒钟要发送多少数据      这里的数据就是二进制位\nUSART_BRR：波特率寄存器\n\nUSARTDIV：无符号的定点数\nFCK：串口的时钟，注区分APB2和APB1两条总线\n主机两个串口的用法\n\n\n\n\n\n\n\n\nUSART1的作用\n总共用到2个串口，串口1是用于产品Debug功能，主要用来监控串口2和WiFi模块的通讯数据，方便调试，目前做物联网产品基本都是通过串口来接收和发送数据，而这种一般有一个复杂通讯协议，在调试过程中肯定会有很多问题，如果能把MCU和Wifi模组的交互数据通过别的串口打印出来，那将大大提高开发效率。\nUSART2的作用\n串口2我们是用来跟WiFi模块通讯，用来远程控制和数据交互。\n\nUSART和UART的区别\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;USART&#x3D;&#x3D;(universal synchronous asynchronous receiver and transmitte): 通用同步异步收发器&#x3D;&#x3D;UART&#x3D;&#x3D;(universal asynchronous receiver and transmitter): 通用异步收发器简单来说就是USART是UART的加强版，增加了同步功能，USART除了可以串口通讯以外，还能支持和ISO7816(用于接触式IC卡)、LIN总线(用于汽车CAN总线)、IrDA(红外通讯)协议接口通讯。而UART就只能单纯使用串口通讯协议。\n串口初始结构体讲解\n\n\n\n\n\n\n\n\n\ntypedef struct\n&#123;\n  uint32_t USART_BaudRate;      //波特率 BRR\n  uint16_t USART_WordLength;    //字长 CR1_M\n  uint16_t USART_StopBits;      //停止位 CR2_STOP\n  uint16_t USART_Parity;        //校验控制 CR1_PCE、CR1_PS\n  uint16_t USART_Mode;          //模式选择CR1_TE、CR1_RE\n  // 硬件流选择 CR3_CTSE、CR3_RTSE\n  uint16_t USART_HardwareFlowControl;\n&#125; USART_InitTypeDef;\ntypedef struct\n&#123;\n  uint16_t USART_Clock;      // 同步时钟 CR2_CLKEN\n  uint16_t USART_CPOL;       // 极性 CR2_CPOL\n  uint16_t USART_CPHA;       // 相位 CR2_CPHA\n  uint16_t USART_LastBit;    //最后一个位的时钟脉冲 CR2_LBC\n&#125; USART_ClockInitTypeDef;\n\n编程时需要用到的固件库函数\n\n\n\n\n\n\n\n\n\n//串口初始化函数\nvoid USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct);\n//中断配置函数\nvoid USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState);\n//串口使能函数\nvoid USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState);\n\n//数据发送函数\nvoid USART_SendData(USART_TypeDef* USARTx, uint16_t Data);\n//数据接收函数\nuint16_t USART_ReceiveData(USART_TypeDef* USARTx);\n//中断状态位获取函数\nITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT);    \n\n撸代码编程要点\n\n\n\n\n\n\n\n\n\n初始化串口需要用到的GPIO\n初始化串口，USART_InitTypeDef\n中断配置（接收中断，中断优先级）\n使能串口\n编写发送和接收函数\n编写中断服务函数\n\nUSART1是用于Debug，主要用来打印usart2接收和发送的数据，usart2接的是wifi模组，所以usart1的作用就是用来监控mcu和wifi模组之间的交互数据用的\n串口配置函数\n\n\n\n\n\n\n\n\n\n//usart配置\nstatic void hal_usart_Config(void)\n&#123;\n\tGPIO_InitTypeDef GPIO_InitStructure;\n\tUSART_InitTypeDef USART_InitStructure;\n\n\t// 打开串口GPIO的时钟\n\tDEBUG_USART_GPIO_APBxClkCmd(DEBUG_USART_GPIO_CLK, ENABLE);\n\t\n\t// 打开串口外设的时钟\n\tDEBUG_USART_APBxClkCmd(DEBUG_USART_CLK, ENABLE);\n\n\t// 将USART Tx->PA9 的GPIO配置为推挽复用模式\n\tGPIO_InitStructure.GPIO_Pin = DEBUG_USART_TX_GPIO_PIN;\t\n\t//推挽复用\n\tGPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;\n\tGPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n\tGPIO_Init(DEBUG_USART_TX_GPIO_PORT, &amp;GPIO_InitStructure);\n\n    // 将USART Rx->PA10 的GPIO配置为浮空输入模式\n\tGPIO_InitStructure.GPIO_Pin = DEBUG_USART_RX_GPIO_PIN;\n\t//浮空输入\n\tGPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;\n\tGPIO_Init(DEBUG_USART_RX_GPIO_PORT, &amp;GPIO_InitStructure);\n\t\n\t// 配置串口的工作参数\n\t// 配置波特率\n\tUSART_InitStructure.USART_BaudRate = DEBUG_USART_BAUDRATE;\n\t// 配置 针数据字长  8位\n\tUSART_InitStructure.USART_WordLength = USART_WordLength_8b;\n\t// 配置停止位\n\tUSART_InitStructure.USART_StopBits = USART_StopBits_1;\n\t// 配置校验位\n\tUSART_InitStructure.USART_Parity = USART_Parity_No ;\n\t// 配置硬件流控制\n\tUSART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;\n\t// 配置工作模式，收发一起\n\tUSART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;\n\t// 完成串口的初始化配置\n\tUSART_Init(DEBUG_USARTx, &amp;USART_InitStructure);\n\t\n\t// 串口中断优先级配置\n\tNVIC_Configuration();\n\t\n\t// 使能串口接收中断\n\tUSART_ITConfig(DEBUG_USARTx, USART_IT_RXNE, ENABLE);\t\n\t// 关闭发送中断\n\tUSART_ITConfig(DEBUG_USARTx, USART_IT_TXE, DISABLE);\t\n\n\t// 使能串口\n\tUSART_Cmd(DEBUG_USARTx, ENABLE);\t    \n&#125;\n\n中断外设配置\n\n\n\n\n\n\n\n\n\n//中断外设配置\nstatic void NVIC_Configuration(void)\n&#123;\n  NVIC_InitTypeDef NVIC_InitStructure;\n  \n  // 嵌套向量中断控制器组选择 \n  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);\n  \n  // 配置USART为中断源\n  NVIC_InitStructure.NVIC_IRQChannel = DEBUG_USART_IRQ;\n  // 抢断优先级\n  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 3;\n  // 子优先级 \n  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;\n  //  使能中断\n  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;\n  // 初始化配置NVIC\n  NVIC_Init(&amp;NVIC_InitStructure);\n&#125;\n\nDEBUG_USART_IRQHandler  串口中断函数\n\n\n\n\n\n\n\n\n\n//usart1中断\nvoid DEBUG_USART_IRQHandler()\n&#123;\n\tuint8_t dat;\n\tif(USART_GetITStatus(DEBUG_USART,USART_IT_RXNE) != RESET)\n\t&#123;\t\t\t\t\t\t\t\n\t\tdat = USART_ReceiveData(DEBUG_USART);\n\t//\thal_DebugSendByte(dat);\n\t\t//hal_SendByte(dat);\n\t\tUSART_ClearITPendingBit(DEBUG_USART,USART_IT_RXNE);\n\t\t\n\t&#125;\n\t\n\tif(USART_GetITStatus(DEBUG_USART,USART_IT_TXE) != RESET)\n\t&#123;\n\t\t USART_ClearITPendingBit(DEBUG_USART, USART_IT_TXE);\n\t\t USART_ITConfig(DEBUG_USART, USART_IT_TXE, DISABLE); \t \n\t&#125;\n&#125;\n\nhal_DebugSendByte  串口发送字节\n\n\n\n\n\n\n\n\n\n//串口发送字节\nstatic void hal_DebugSendByte(uint8_t Dat)\n&#123;\n\t//发送单一数据\n\tUSART_SendData(DEBUG_USART, Dat);\n\t//把串口发送中断打开   只有我们主动发数据才开发送中断\n\tUSART_ITConfig(DEBUG_USART, USART_IT_TXE, ENABLE); \t\t\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n然后把我们串口二再配置一下\n\n\n\n\n\n\n\n\n\nDMA  直接存储器访问\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;DMA&#x3D;&#x3D;： Direct Memory Access，直接存储器访问。主要功能是可以把数据从一个地方搬到另外一个地方，而且不占用CPU。\n&#x3D;&#x3D;DMA1&#x3D;&#x3D;： 有7个通道，可以实现 P-&gt;M，M-&gt;P，M-&gt;M\n&#x3D;&#x3D;DMA2&#x3D;&#x3D;： 有5个通道，可以实现 P-&gt;M，M-&gt;P，M-&gt;M\n\nDMA简单来说就是把数据从一个地方搬运到另一个地方。\n\n内存到内存，比如说Flash到Sram\n外设到内存，比如说读ADC外设的值存到数组或者变量里\n内存到外设，比如说把数组或者变量的值写到串口发送寄存器里\n\n当CPU初始化这个传输动作，传输动作本身是由DMA控制器来实现和完成的。DMA传输方式无需CPU直接控制传输，所以一定程度上节约了CPU资源\n所以DMA最主要的作用有2个\n\n.减轻CPU负担\n快速搬运数据，特别是大数据的频繁搬运。\n\nDMA1请求映射\n\n\n\n\n\n\n\n\n\nDMA2请求映射\n\n\n\n\n\n\n\n\n\nADC3&#x2F;SDIO&#x2F;TIM8 的DMA请求只有大容量的单片机才有\nDMA2 控制器及相关请求仅存在于大容量产品和互联型产品中,互联网型是105，大容量是Flash大于256K。所以我们c8t6只有DMA1\n多个DMA请求一起来，怎么办？\n\n\n\n\n\n\n\n\n假如DMA1的串口1,2的发送请求同时到来，该怎么办\n\n软件阶段，DMA_CCRx：PL[1:0]。\n硬件阶段，通道编号小的优先级大，DM1的优先级高于DMA2的优先级\n\n我们使用DMA的目的\n\n\n\n\n\n\n\n\n我们的串口1(USART1)是用来监控WiFi模块和MCU(USART2)交互的数据，也就是说单片机USART2接收到和发送出去的数据都要通过USART1发送出去，这块的数据量相对来说比较多，而且时时刻刻都会有，所以我们用DMA来减轻CPU的负担，从这个需求我们可以知道使用DMA的传输方式是从&#x3D;&#x3D;内存到外设&#x3D;&#x3D;。\nUSART1的发送对应的是DMA1的通道4，所以我们只能使用DMA1通道4。\n初始化结构体\n\n\n\n\n\n\n\n\n\ntypedef struct\n&#123;\n  uint32_t DMA_PeripheralBaseAddr;   // 外设地址\n  uint32_t DMA_MemoryBaseAddr;       // 存储器地址\n  uint32_t DMA_DIR;                  // 传输方向\n  uint32_t DMA_BufferSize;           // 传输数目\n  uint32_t DMA_PeripheralInc;        // 外设地址增量模式\n  uint32_t DMA_MemoryInc;            // 存储器地址增量模式\n  uint32_t DMA_PeripheralDataSize;   // 外设数据宽度\n  uint32_t DMA_MemoryDataSize;       // 存储器数据宽度\n  uint32_t DMA_Mode;                 // 模式选择\n  uint32_t DMA_Priority;             // 通道优先级\n  uint32_t DMA_M2M;                  // 存储器到存储器模式\n&#125;DMA_InitTypeDef;\n\nhal_DMA_Config  DMA配置函数\n\n\n\n\n\n\n\n\n\n// Memory -> P (USART->DR)\nstatic void hal_DMA_Config(void)\n&#123;\n\t//创建DMA结构体\n\tDMA_InitTypeDef DMA_InitStructure;\n\t//开DMA时钟\n\tRCC_AHBPeriphClockCmd(USART_TX_DMA_CLK, ENABLE);\n\t\n\t//外设地址\n\tDMA_InitStructure.DMA_PeripheralBaseAddr = (uint64_t)(&amp;DEBUG_USART->DR);\n\t//存储器地址\n\tDMA_InitStructure.DMA_MemoryBaseAddr = (uint64_t)DebugTxDMAMapBuff;\n\t//传输方向  外设是目标地址\t\n\tDMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;\n\t\n\t//传输的数目  就是发送DMA数组的大小\n\tDMA_InitStructure.DMA_BufferSize = DEBUG_TXBUFF_SIZE_MAX;\n\t//外设地址的增量模式->不需要增\n\tDMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;\n\t//存储器(内存)地址增量模式->需要增\n\tDMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;\n\t//外设数据宽度8位\n\tDMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;\t\n\t//内存数据宽度8位\n\tDMA_InitStructure.DMA_MemoryDataSize = DMA_PeripheralDataSize_Byte;\n\t\n\t//普通缓存模式\n\tDMA_InitStructure.DMA_Mode = DMA_Mode_Normal;\n\t//高优先级\n\tDMA_InitStructure.DMA_Priority = DMA_Priority_High;\n\t//禁止DMA两个内存相互访问\n\tDMA_InitStructure.DMA_M2M = DMA_M2M_Disable;\n\t//DMA初始化 把通道4初始化\n\tDMA_Init(USART_TX_DMA_CHANNEL, &amp;DMA_InitStructure);\n\t// DMA1C4中断优先级配置\n\tNVIC_DMA1C4_Configuration();\n\t//清除传输完成标志位 \n\tDMA_ClearFlag(USART_TX_DMA_FLAG_TC);\n\t//把DMA发送完成中断打开\n\tDMA_ITConfig(USART_TX_DMA_CHANNEL,DMA_IT_TC,ENABLE);\n    //把串口DMA开起来   这个很重要\n\tUSART_DMACmd(DEBUG_USART,USART_DMAReq_Tx,ENABLE);\n\t//不使能dma\n\t//DMA_Cmd(USART_TX_DMA_CHANNEL, DISABLE);\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n NVIC_DMA1C4_Configuration  DMA1 4通道中断外设配置\n\n\n\n\n\n\n\n\n\n//DMA1 4通道中断外设配置\nstatic void NVIC_DMA1C4_Configuration(void)\n&#123;\n  NVIC_InitTypeDef NVIC_InitStructure;\n  \n  // 嵌套向量中断控制器组选择 \n  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);\n  \n  // 配置DMA1C4为中断源\n  NVIC_InitStructure.NVIC_IRQChannel = DMA1C4_IRQ;\n  // 抢断优先级\n  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 3;\n  // 子优先级 \n  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;\n  //  使能中断\n  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;\n  // 初始化配置NVIC\n  NVIC_Init(&amp;NVIC_InitStructure);\n&#125;\n\n DMA1C4_IRQHandler   DMA1通道4中断函数\n\n\n\n\n\n\n\n\n\n//DMA1通道4发送完毕中断函数\nvoid DMA1C4_IRQHandler(void)\n&#123;\n\tif(DMA_GetITStatus(DMA1_IT_TC4) != RESET)\n\t&#123;\n\t\t//发送完毕进入中断清一下中断标志\n\t\tDMA_ClearITPendingBit(DMA1_IT_TC4);\t\n\t\t//禁止DMA1C4发送中断，用到的时候再打开\n\t\tDMA_Cmd(USART_TX_DMA_CHANNEL, DISABLE);\t\t\t\t \n\t\t//空闲\n\t\tDebugIsBusy = 0;\n\t&#125;\n&#125;\n\n DMA1C4_IRQHandler   DMA1通道4中断函数\n\n\n\n\n\n\n\n\n\n//串口初始化\nvoid hal_UsartInit(void)\n&#123;\n\t//首先配置一波\n\thal_usart_Config();\n\t//DMA配置一下\n\thal_DMA_Config();\n\t//初始化的时候先把串口二的接收发送数据队列清空\n\tQueueEmpty(DebugTxMsg);\n\t//debug空闲\n\tDebugIsBusy = 0;\n&#125;\n\nhal_debugProc   debug任务函数\n\n\n\n\n\n\n\n\n\n//debug任务函数\nstatic void hal_debugProc(void)\n&#123;\n\tunsigned char i,len;\n\t//如果忙就直接返回，空闲的时候才会\n\tif(DebugIsBusy)\n\t\treturn;\n\t//把队列的长度取出来\n\tlen = QueueDataSize(DebugTxMsg);\n\tfor(i=0; i&lt;len; i++)\n\t&#123;\n\t\t//if(!DebugIsBusy)\n\t\t//&#123;\n\t\t\t//把数据放到DMA发送数组里面\n\t\t\tQueueDataPop(DebugTxMsg,&amp;DebugTxDMAMapBuff[i]);\n\t\t//\tDebugIsBusy = 1;\n\t\t//\thal_DebugSendByte(temp);\n\t\t//&#125;\n\t&#125;\n\tif(len)\n\t&#123;\n\t\t//这个是我们自己写的一个DMA使能，是让他发送数据\n\t\thal_DMAC4_Enable(len);\n\t\t//debug忙\n\t\tDebugIsBusy = 1;\n\t&#125;\n&#125;\n//启动debug usart1的DMA发送函数,size-需要发送的数据大小\nstatic void hal_DMAC4_Enable(uint64_t size)\n&#123;\n\t//我们首先把DMA关掉\n\t DMA1_Channel4->CCR &amp;= ~(1&lt;&lt;0);\n\t //然后设置传送数据的大小\n\t DMA1_Channel4->CNDTR = size;\n\t //再打开DMA\n\t DMA1_Channel4->CCR |= 1&lt;&lt;0;\n&#125;\n\nSTM32之AHB与APB总线\n\n\n\n\n\n\n\n\nAHB是高速总线，是一种系统总线，它主要负责连接处理器、DMA等一些内部接口。AHB 系统由主模块、从模块和基础结构3部分组成，整个AHB总线上的传输都由主模块发出，由从模块负责回应。APB是低速总线，它主要负责连接外围设备，它又分为APB1和APB2，它的总线架构不像 AHB支持多个主模块，在APB里面唯一的主模块就是APB 桥。APB桥就是连接AHB和APB中间的玩意。APB1最大时钟频率为36MHzAPB2最大时钟频率为72MHz\n\n二级标题三级标题四级标题五级标题六级标题","slug":"wifi主机/wifi主机第六部分  向上突破","date":"2020-08-15T10:49:36.000Z","categories_index":"单片机","tags_index":"STM32,主机","author_index":"虫子"},{"id":"d2e5b9b985b90883587f83810ef48a2e","title":"WIFI主机-APP联调","content":"WIFI主机APP和主机联调\n\n\n\n\n\n\n\n\n打通了单片机和云平台的通讯以后，接下来就要和APP联调，把功能以更友好的形式展现给用户。\nAPP也是通过云平台的DP功能定义去控制和获取我们硬件端的数据的。\n实际上1个DP点不代表只有1个功能，在APP上也可能有2个甚至多功能，具体要看APP的功能怎么定义。\n功能定义\n\n\n\n\n\n\n\n\n数据上报\n数据方向：单片机-&gt;WiFi模块-&gt;云平台-&gt;APP\n主要用来更新app上面的数据显示\n单个DP点上报函数：mcu_dp_xxxx_updata()\n所有DP点上报函数：all_data_update()\n APP实时显示主机模式(通过DP1那个功能点实现)\n触发报警后把触发的探测器名称上报云端(通过DP45那个功能点实现)\n数据下发\n数据方向：APP-&gt;云平台-&gt;WiFi模块-&gt;单片机\n主要用来远程控制硬件。\n数据下发处理函数：dp_download_xxx_handle\n改变主机防盗报警模式(通过DP1那个功能点实现)\n设备功能（DP，Data Point）主要有 6 种数据类型\n\n\n\n\n\n\n\n\n\n\n\n类型\n说明\n\n\n\nbool\n通常为开关类的 DP，例如开关、ECO 和屏显。\n\n\nenum\n通常用作有多种状态的 DP，例如工作模式、风速和风摆位置。\n\n\nvalue\n通常用作数值类型的 DP，例如设定温度值、当前温度值和电量。\n\n\nfault\n通常用于故障的上报，数据常用 bitmap 格式显示。\n\n\nstring\n通常用作字符串类型的 DP。需要以字符串形式传输的 DP 可以使用此类型。部分不便于使用 bool、enum、value 或 fault 类型的 DP，也可用此类型。\n\n\nraw\n通常用作需要透传但对数据格式无要求（明文或者加密）的数据。发送端和接收端对数据的格式、组包和解析方式需要统一。\n\n\nmcu_all_dp_update   所有dp点上报\n\n\n\n\n\n\n\n\n\n//所有dp点上报\nvoid mcu_all_dp_update()\n&#123;\n  //枚举型数据上报;\n  mcu_dp_enum_update(DPID_MASTER_MODE,pStuSystemMode->ID,STR_GATEWAY_ITSELF_ID,my_strlen(STR_GATEWAY_ITSELF_ID)); \n  //STRING型数据上报;\n  mcu_dp_string_update(DPID_ALARM_ACTIVE,\" \",sizeof(\" \"),STR_GATEWAY_ITSELF_ID,my_strlen(STR_GATEWAY_ITSELF_ID)); \n\n&#125;\n\nAPP实时显示主机模式\n\n\n\n\n\n\n\n\n\n//系统防区模式切换\nstatic void SystemMode_Change(SYSTEMMODE_TYPEDEF sysMode)\n&#123;\n\tif(sysMode &lt; SYSTEM_MODE_SUM)\t//传入的形参(模式)是否正确\n\t&#123;\n\t\tpStuSystemMode = &amp;stu_Sysmode[sysMode];\n\t\tpStuSystemMode->refreshScreenCmd = SCREEN_CMD_RESET;\n\t\t//上报主机模式\n\t\tmcu_dp_enum_update(DPID_MASTER_MODE,\n\t\t                   sysMode,STR_GATEWAY_ITSELF_ID,\n\t\t                   my_strlen(STR_GATEWAY_ITSELF_ID)); \n\t&#125;\n&#125;\n\n触发报警后把触发的探测器名称上报云端\n\n\n\n\n\n\n\n\n \n数据下发\n\n\n\n\n\n\n\n\n\n主机联网指示\n\n\n\n\n\n\n\n\n在桌面菜单左上角显示wifi连接状态。\n“N”-进入配网状态\n“W”-WIFI配置成功但未连上路由器\n“R”- WIFI配置成功且连上路由器\n“S”- WIFI已经连接上云服务器\n\n\n\n\n\n\n\n\n\n开启protocol.h文件的宏定义#define  GET_WIFI_STATUS_ENABLE\n\n通过sdk的mcu_api.c文件的get_wifi_st()函数获得wifi状态。\n\n结果会通过回调函数protocol.c文件的wifi_status_result(unsigned char result)函数获得的\n\n联网指示灯指示\n\n\n\n\n\n\n\n\n“N”-进入配网状态，指示灯每200ms快闪一次。\n“W”-WIFI配置成功但未连上路由器，指示灯每600ms闪烁一次\n“R”- WIFI配置成功且连上路由器，指示灯每秒闪烁一次\n“S”- WIFI已经连接上云服务器，指示灯常亮\n实时时间显示\n\n\n\n\n\n\n\n\n在桌面菜单最下面一行显示实时时间，时间通过云服务器去更新,格式如下。\n年-月-日 时:分 星期\n开启protocol.h文件的宏定义#define  SUPPORT_MCU_RTC_CHECK\n\n调用mcu_api.c文件的mcu_get_system_time函数去获取服务器时间。\n\n通过protocol.c文件的mcu_write_rtctime()回调函数获得最终时间数据。\n\n报警110声    主机模式切换提示音\n\n\n\n\n\n\n\n\n离家布防&#x2F;在家布防：蜂鸣器滴一声\n撤防：蜂鸣器滴滴两声\n\n按键提示音   自动熄屏\n\n\n\n\n\n\n\n\n按下S1-S6按键的时候，蜂鸣器滴一声\n无任何操作情况下30秒自动熄屏，按任意按键、无线遥控器、APP控制可触发自动亮屏\n熄屏条件\n1、 主机没在报警模式\n2、 主机没在配网菜单\n3、 没有任何按键、切换模式动作下保持30秒\n自动亮屏条件\n\n按下S1-S6任意按键\n\n切换主机模式\n\n\n设置菜单超时自动退出\n在设置菜单下，如果没任何按键操作的话，自动返回桌面菜单\n\n主机没在配网菜单\n主机不在桌面菜单\n\napp任务控制息屏\n\n\n\n\n\n\n\n\n\nvoid AppProc(void)\n&#123;\n\t//mcu_api中的wifi串口服务\n    wifi_uart_service();\n\tpModeMenu->action();\t\n\tif((pModeMenu->menuPos!=DESKTOP_MENU_POS) \n\t\t&amp;&amp;(pModeMenu->menuPos!=STG_WIFI_MENU_POS))\n\t&#123;\n\t\tSetupMenuTimeOutCnt++;\n\t\tif(SetupMenuTimeOutCnt > SETUPMENU_TIMEOUT_PERIOD)\n\t\t&#123;\n\t\t\tSetupMenuTimeOutCnt = 0;\n\t\t\t//设置上电显示的菜单界面为桌面显示\n\t\t\tpModeMenu = &amp;generalModeMenu[GNL_MENU_DESKTOP];\t\n\t\t\t//更新刷新界面标志，进入界面后刷新全界面UI\n\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RESET;\t\n\n\t\t&#125;\n\t&#125;\t\t\t\t\n\tif((pStuSystemMode->ID!=SYSTEM_MODE_ALARM)\n\t&amp;&amp; (pModeMenu->menuPos!=STG_WIFI_MENU_POS))\n\t&#123;\n\t\tPutoutScreenTiemr++;\n\t\tif(PutoutScreenTiemr > PUTOUT_SCREEN_PERIOD)\n\t\t&#123;\n\t\t\tPutoutScreenTiemr = 0;\n\t\t\t\n\t\t\t//30秒没任何操作自动熄屏\n\t\t\tScreeControl(0);\t\t\t \n\t\t&#125;\n\t&#125;\t\n&#125;\n\n按键提示音\n\n\n\n\n\n\n\n\n\n//按键回调函数\nstatic void KeyEventHandle(KEY_VALUE_TYPEDEF keys)\n&#123;\t \t\n\tif(!ScreenState)\n\t&#123;\n\t\tScreeControl(1);\n\t&#125;else\n\t&#123;\n\t\tpModeMenu->keyVal = keys;\n\t\tif((pModeMenu->menuPos!=DESKTOP_MENU_POS) \n\t\t\t&amp;&amp;(pModeMenu->menuPos!=STG_WIFI_MENU_POS))\n\t\t\t&#123;\n\t\t\t\tSetupMenuTimeOutCnt = 0;\n\t\t\t&#125;\n\t\t\tPutoutScreenTiemr = 0;\n\t&#125;\t\n\tif((keys==KEY1_CLICK)\n\t|| (keys==KEY2_CLICK)\n\t|| (keys==KEY3_CLICK)\n\t|| (keys==KEY4_CLICK)\n\t|| (keys==KEY5_CLICK)\n\t|| (keys==KEY6_CLICK))\n\t&#123;\n\t\tLedMsgInput(BUZ,LED_LIGHT_100MS,0);\n\t&#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n二级标题三级标题四级标题五级标题六级标题","slug":"wifi主机/wifi主机第十三部分  APP联调","date":"2020-08-15T10:49:36.000Z","categories_index":"单片机","tags_index":"STM32,主机","author_index":"虫子"},{"id":"441f89b58030cc5cf4d20abd25001933","title":"WIFI主机-远程","content":"WIFI主机主机实现远程控制原理\n\n\n\n\n\n\n\n\n\n传统硬件\n\n\n\n\n\n\n\n\n报警主机、指纹锁、智能插座、冰箱、电风扇、空调等等。\n传统的智能硬件一般是带单片机的\n我们传统硬件的数据，比如说电量啊、温湿度值、报警探测器的名称啊这些数据就是通过串口传输给WiFi模块，然后WiFi模块再上传到云平台的。\n这样你在云平台的网页后台就能看到，网页后台给用户体验不好，所以实际产品一般也会做APP。\nAPP从云平台去获取数据，然后显示在APP上面，当然也可以发送控制的指令给云平台。\n云平台再发送给WiFi模块，WiFi模块通过串口传输到单片机这里，单片机解析命令后执行相应的控制，比如说控制继电器吸合&#x2F;断开，LED灯亮灭等等\nWiFi模块&#x2F;模组\n\n\n\n\n\n\n\n\nWRG1(涂鸦自主研发模块)、ESP8266(乐鑫科技)、LPB100、LPT120(汉枫)、上海庆科等等。 \nWifi模块一般是现成的模块，不会自己去研发，因为这种做这种模块的测试设备贵的要几百万，一般公司承担不起，只有专门做wifi模块的厂家才会去买。 \n有些WiFi模块一般会有提供类似于STM32的固件库，如汉枫的模块，你在他们库的基础上进行二次开发，一般厂家会提供开发教程和技术指导，这块不用过于担忧，其实就跟单片机开发差不多，比较简单。 \n而我们这个报警主机使用的是涂鸦云自己研发的模块，型号WRG1，用它们模块最大的好处就是，不用改wifi模块的代码，涂鸦云直接帮你做好，对接好他们平台。 \n除此以外，他们这个模块也会帮我们做好单片机这边的通讯，一般我们数据传输的时候是有一个通讯协议的，就是按照固定的数据格式进行通讯。 \n至于整个通讯协议的解析代码，他们会帮我们做好，并且提供sdk给我们下载，我们只需要调用他们函数就能把传统硬件轻松连上他们服务器。\n云平台\n\n\n\n\n\n\n\n\n市面上云平台很多，涂鸦云、机智云、云智易、阿里云、华为云、腾讯云、百度云等等。 \n每个云接入的难度不一样，目前来说最简单的应该是涂鸦云。 \n对初学者最友好，他们什么都帮你做好，你只需要按照他们教程，把他们的代码移植到我们单片机keil工程里就行了。 \n平台也支持在线生成app，但是比较鸡肋，调试用可以，用于产品就太垃圾了。\nAPP\n\n\n\n\n\n\n\n\n我们这个报警主机用的是涂鸦云在线生成的鸡肋版APP，这个也没办法，因为做APP的费用太昂贵了，APP分为苹果版本和安卓版本。 \n如果想做好一套APP，除了2个系统版本的APP以外，还涉及到UI的设计，所以整套下来估计将近20万甚至以上。 \n不过最核心的还是把传统硬件到云平台这边的数据打通，就是单片机能把数据正常上传到云平台，云平台也能把数据传输到单片机，链路打通了，剩下的就简单了。\nSDK移植移植须知\n\n\n\n\n\n\n\n\n\nMCU SDK,是涂鸦平台根据用户创建的DP点自动生成的MCU程序架构，我们可以在此基础上进行快速开发\nMCU硬件需求，MCU SDK包对MCU硬件资源需求Flash 4Kbyte，RAM与DP点数据长度有关几十字节左右(OTA功能需大于260byte)，函数嵌套级数9级，资源不足的用户，可自行对接协议\n\n\n\n\n\n\n\n\n\n\n\n先把我们的开发资料都下载下来\n\n文件结构\n\n\n\n\n\n\n\n\n然后将我们的mcu_sdk移植到自己的主机中\n\n\n确认 protocol.h 宏定义\n\n\n\n\n\n\n\n\n定义 PID。PRODUCT_KEY 为产品 PID 宏定义。PID 即产品 ID, 为每个产品的唯一标识，可在 IoT 平台 的产品详情页面查询。\n//pid信息，服务端自动插入\n#define PRODUCT_KEY \"aono1txwiafeacmx\"    //开发平台创建产品后生成的16位字符产品唯一标识\n\n\n\n\n\n\n\n\n\n\n这里需要注意一下，就是如果PRODUCT_KEY和产品PID不一致，需要重新下载SDK包，但是基本不会出现这种情况\n\n\n\n\n\n\n\n\n\n定义版本号。MCU_VER 为软件版本，默认为 1.0.0 。若 MCU 需要 OTA 功能，需要添加新的 MCU 版本号。\n#define MCU_VER \"1.0.0\"                    //用户的软件版本,用于MCU固件升级,MCU升级版本需修改\n\n\n\n\n\n\n\n\n\n\n定义 Wi-Fi 模组工作模式。CONFIG_MODE 为配网方式，支持默认模式（热点和快连互相切换）、安全模式、防误触模式。默认即可\n//配网方式选择,默认为CONFIG_MODE_DEFAULT,只能三选一\n#define CONFIG_MODE     CONFIG_MODE_DEFAULT               //默认配网方式\n//#define CONFIG_MODE     CONFIG_MODE_LOWPOWER            //低功耗配网方式\n//#define CONFIG_MODE     CONFIG_MODE_SPECIAL             //特殊配网方式\n\n\n\n\n\n\n\n\n\n\n定义收发缓存（可选）\n\n串口接收缓存：大小受到串口数据处理被调用的频率影响。如果 MCU 对串口数据的处理较快，串口接收缓存大小可适当减小。\n串口发送缓存：大小要大于数据最长的 DP 数据长度。\n串口数据处理缓存：大小需要大于数据最长的 DP 数据长度，还要根据是否需要 OTA 功能和是否需要天气服务、天气服务类型数量和天数来调整大小，需要大于最大数据量的大小。\n\n 3:定义收发缓存:\n                    用户根据实际情况定义收发缓存的大小\n******************************************************************************/\n#ifndef SUPPORT_MCU_FIRM_UPDATE\n#define WIFI_UART_RECV_BUF_LMT         128      //串口数据接收缓存区大小,如MCU的RAM不够,可缩小\n#define WIFI_DATA_PROCESS_LMT          128      //串口数据处理缓存区大小,根据用户DP数据大小量定,建议大于24\n#else\n#define WIFI_UART_RECV_BUF_LMT         128      //串口数据接收缓存区大小,如MCU的RAM不够,可缩小\n\n\n\n\n\n\n\n\n\n\n定义模组工作方式（必选）\n如果配网按键和 LED 接在 MCU 端，即选择 模组和 MCU 配合处理 工作模式（常用），保持 WIFI_CONTROL_SELF_MODE 宏定义处于被注释状态\n//#define         WIFI_CONTROL_SELF_MODE      //wifi自处理按键及LED指示灯;如为MCU外界按键/LED指示灯请关闭该宏\n\n\n\n\n\n\n\n\n\n\n如果配网指示灯和按键是接在 Wi-Fi 模组上的，即选择 模组自处理 工作模式，开启 WIFI_CONTROL_SELF_MODE 宏定义，然后根据实际的硬件连接，将指示灯和按键所连接的 GPIO 脚位填入下面两个宏定义\n//例如：PORT为2，pin为3则代表选择GPIO C_3\n#ifdef          WIFI_CONTROL_SELF_MODE                      //模块自处理\n  #define    WF_LED_PORT   0   //wifi状态指示灯的PORT（prot选择范围：0~3[依次代表A到D]），请根据实际GPIO管脚设置\n  #define    WF_LED_PIN    0   //wifi状态指示灯的PIN（prot选择范围：0~7），请根据实际GPIO管脚设置\n  #define    WF_RESERT_KEY_PORT   0  //重置按键的PORT（prot选择范围：0~3[依次代表A到D]），请根据实际GPIO管脚设置\n  #define    WF_RESERT_KEY_PIN    0  //重置按键的PIN（prot选择范围：0~7），请根据实际GPIO管脚设置\n#endif\n\n\n\n\n\n\n\n\n\n\n开启 Wi-Fi 产测功能（可选）\nWi-Fi 产测功能默认开启。为保证最终量产效率及品质，建议开启该功能\n#define         WIFI_TEST_ENABLE                      //开启WIFI产测功能（扫描指定路由）\n\n移植 protocol.c 文件及函数调用\n\n\n\n\n\n\n\n\n\n在 MCU 串口及其他外设初始化后，调用 mcu_api.c 文件中的 wifi_protocol_init() 函数。\n将 MCU 串口单字节发送函数填入 protocol.c 文件中的 uart_transmit_output 函数内，并删除 #error\n\n\n\n\n\n\n\n\n\n\n\n\n在串口接收中断服务函数里面调用 mcu_api.c 文件内的 uart_receive_input 函数，并将接收到的字符作为参数传入\n\n\n\n\n\n\n\n\n\n\n单片机进入 while(1) 循环后调用 mcu_api.c 文件内的 wifi_uart_service() 函数。main.c\n\nJSON\n\n\n\n\n\n\n\n\nJSON（JavaScript Object Notation）是一种轻量级的数据交换格式，可使人们很容易地进行阅读和编写，同时也方便了机器进行解析和生成。JSON适用于进行数据交互的场景，如网站前台与后台之间的数据交互。 \n比如说获取产品信息指令这种格式，有字符串，有数值，他可以很轻松转换成统一的格式。 \n使用JSON的时候，需要比较大的堆和栈，所以我们需要更改STM32启动文件的堆栈大小，我统一改成2K，否则通讯不正常，因为动态分配JSON对象的时候返回分配失败。 \n栈(stack)空间，用于局部变量，函数调时现场保护和返回地址，函数的形参等。堆(heap)空间，主要用于动态内存分配，也就是说用 malloc，calloc, realloc 等函数分配的变量空间。\n\n\n配网的目的\n\n\n\n\n\n\n\n\n配网就是让wifi模块连接我们家或者公司的wifi，只有连上wifi以后wifi模块才能通过ip和端口连上远程的服务器进行远程控制。 \n就跟我们手机没有连wifi，也没有4G信号的时候，就无法上网一样\n配网模式\n\n\n\n\n\n\n\n\n目前大多数wifi模块主流的配网就是2种\n1.   AP\n2.   Smartlink\nAP\n\n\n\n\n\n\n\n\n优点：就是连接Wifi模块的热点，然后进行配网，这种配网成功率几乎90%以上，wifi模块连网比较快。\n缺点：配网流程稍微麻烦一点\nSmartlink\n\n\n\n\n\n\n\n\n优点：就是通过广播的形式配网，配网流程非常简单。\n缺点：wifi模块连网时间也比较长，成功率比AP模式低\n配网代码完善\n\n\n\n\n\n\n\n\n我们采用AP这种方式配网，我们完善设置菜单stgMenu_WifiCBS函数\n我们调用mcu_api.c里面的函数就行\n\nstgMenu_WifiCBS  wifi配网菜单处理函数\n\n\n\n\n\n\n\n\n\n我们只需要用到4种连网状态\n\nAP_STATE：AP配置状态，文案显示” Enter ap mode.”\nWIFI_NOT_CONNECTED: WIFI配置成功但未连上路由器，文案显示” Connect to wifi ok.”\nWIFI_CONNECTED: WIFI配置成功且连上路由器，文案显示” Connect to router ok.”\nWIFI_CONN_CLOUD: WIFI已经连接上云服务器，文案显示” Connect to server ok.”和”Connect success!”\n\n//wifi配网菜单处理函数\nstatic void stgMenu_WifiCBS(void)\n&#123;\n\t//AP配网步骤\n\tstatic uint8_t APStep = 0;\n\t//连接成功标志\n\tstatic uint8_t ConnectSuccess = 0;\n\t//wifi工作状态\n\tuint8_t wifiWorkState = 0;\n\tstatic uint8_t stgMainMenuSelectedPos = 0;\n\tstatic uint16_t timer = 0;\n\tuint8_t keys;\n\tif(pModeMenu->refreshScreenCmd == SCREEN_CMD_RESET)\n\t&#123;\n\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_NULL;\t\n\t\thal_Oled_Clear();\t \n\t\thal_Oled_ShowString(52,0,\"Wifi\",12,1);\t\t \n\t\thal_Oled_ShowString(0,20,\"Are you sure to\",8,1); \n\t\thal_Oled_ShowString(0,30,\"enter ap mode?\",8,1);\t\t\n\t\t//yes   no\n\t\thal_Oled_ShowString(40,48,\"Yes\",12,1); \n\t\thal_Oled_ShowString(88,48,\"No\",12,0); \t\t\n\t\thal_Oled_Refresh();\t\t\n\t\tkeys = 0xFF;\n\t\ttimer = 0;\n\t\tstgMainMenuSelectedPos = 0;\n\t&#125;\t\n\tif(pModeMenu->keyVal != 0xff)\n\t&#123;\n\t\tkeys = pModeMenu->keyVal;\n\t\tpModeMenu->keyVal = 0xFF;\t//恢复菜单按键值\t\t\n\t\tif((keys == KEY3_CLICK_RELEASE) || (keys == KEY4_CLICK_RELEASE))\n\t\t&#123;\n\t\t\tif(stgMainMenuSelectedPos == 0)\t\t\n\t\t\t&#123;\n\t\t\t\tstgMainMenuSelectedPos = 1;\n\t\t\t\thal_Oled_ClearArea(40,48,88,16);\t\t//清屏\n\t\t\t\thal_Oled_ShowString(40,48,\"Yes\",12,0); \n\t\t\t\thal_Oled_ShowString(88,48,\"No\",12,1); \n\t\t\t\thal_Oled_Refresh();\n\t\t\t&#125;else if(stgMainMenuSelectedPos == 1)\n\t\t\t&#123;\n\t\t\t\tstgMainMenuSelectedPos = 0;\n\t\t\t\thal_Oled_ClearArea(40,48,88,16);\t\t//清屏\n\t\t\t\thal_Oled_ShowString(40,48,\"Yes\",12,1); \n\t\t\t\thal_Oled_ShowString(88,48,\"No\",12,0); \n\t\t\t\thal_Oled_Refresh(); \n\t\t\t&#125;\n\t\t&#125;else if(keys == KEY5_CLICK_RELEASE)\n\t\t&#123;\n\t\t\tpModeMenu = pModeMenu->pParent;\n\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RECOVER;\n\t\t&#125;else if(keys == KEY5_LONG_PRESS)\n\t\t&#123;\n\t\t\tpModeMenu = &amp;generalModeMenu[GNL_MENU_DESKTOP];;\n\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RESET;\n\t\t&#125;\t\n\t\telse if((keys == KEY6_CLICK_RELEASE)\n\t\t&amp;&amp; (!APStep)\n\t\t&amp;&amp; (!ConnectSuccess))\n\t\t&#123;\n\t\t\t//为1的时候就是选择yes\n\t\t\tif(stgMainMenuSelectedPos)\n\t\t\t&#123;\n\t\t\t\tAPStep = 1;\n\t\t\t\t//让wifi进入AP配网模式\n\t\t\t\tmcu_set_wifi_mode(1);\t\t\n\t\t\t\thal_Oled_ClearArea(0,20,128,44);\t\t//清屏\n\t\t\t\thal_Oled_ShowString(16,30,\"Please wait..\",8,1);\n\t\t\t\thal_Oled_Refresh();\t\n\t\t\t&#125;else\n\t\t\t&#123;\n\t\t\t\tpModeMenu = pModeMenu->pParent;\n\t\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RECOVER;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\tif(APStep)\n\t&#123;\n\t\twifiWorkState = mcu_get_wifi_work_state();\n\t&#125;\n\tif(APStep == 1)\n\t&#123;\n\t\tif(wifiWorkState == AP_STATE)\n\t\t&#123;\n\t\t\thal_Oled_ClearArea(0,20,128,44);\t\t//清屏\n\t\t\thal_Oled_ShowString(0,30,\"Enter ap mode.\",8,1);\n\t\t\thal_Oled_Refresh();\n\t\t\t//灯闪烁表示正在联网\n\t\t\tLedMsgInput(LED1,LED_BLINK1,1);\n\t\t\tAPStep = 2;\n\t\t&#125;\n\t&#125;else if(APStep == 2)\n\t&#123;\n\t\tif(wifiWorkState == WIFI_NOT_CONNECTED)\n\t\t&#123;\n\t\t\thal_Oled_ClearArea(0,20,128,44);\t\t//清屏\n\t\t\thal_Oled_ShowString(0,30,\"Connect to wifi ok.\",8,1);\n\t\t\thal_Oled_Refresh();\n\t\t\t//灯慢闪\n\t\t\tLedMsgInput(LED1,LED_BLINK3,1);\n\t\t\tAPStep = 3;\t\n\t\t&#125;\n\t&#125;else if(APStep == 3)\n\t&#123;\n\t\tif(wifiWorkState == WIFI_CONNECTED)\n\t\t&#123;\n\t\t\thal_Oled_ClearArea(0,20,128,44);\t\t//清屏\n\t\t\thal_Oled_ShowString(0,30,\"Connect to router ok.\",8,1);\n\t\t\thal_Oled_Refresh();\n\t\t\tLedMsgInput(LED1,LED_BLINK4,1);\n\t\t\tAPStep = 4;\n\t\t&#125;\n\t&#125;else if(APStep == 4)\n\t&#123;\n\t\tif(wifiWorkState == WIFI_CONN_CLOUD)\n\t\t&#123;\n\t\t\thal_Oled_ClearArea(0,20,128,44);\t\t//清屏\n\t\t\thal_Oled_ShowString(0,30,\"Connect to server ok.\",8,1);\n\t\t\thal_Oled_ShowString(0,40,\"Connect success!\",8,1);\n\t\t\thal_Oled_Refresh();\n\t\t\tLedMsgInput(LED1,LED_LIGHT,1);\n\t\t\tAPStep = 0;\n\t\t\tConnectSuccess = 1;\n\t\t\ttimer = 0;\n\t\t&#125;\n\t&#125;\n\tif(ConnectSuccess)\n\t&#123;\n\t\t//连接成功延时2s让用户看到成功的字样\n\t\ttimer++;\n\t\tif(timer >200)\n\t\t&#123;\n\t\t\ttimer = 0;\n\t\t\tConnectSuccess = 0;\n\t\t\t \n\t\t\tpModeMenu = pModeMenu->pParent;\n\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RECOVER;\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n二级标题三级标题四级标题五级标题六级标题","slug":"wifi主机/wifi主机第十二部分  远程小小侠","date":"2020-08-15T10:49:36.000Z","categories_index":"单片机","tags_index":"STM32,主机","author_index":"虫子"},{"id":"e83728f7bf48a49084af17022bba25d3","title":"WIFI主机-","content":"WIFI主机\n\n\n\n\n\n\n\n\n先看看我们需要完成的所有功能\n\n桌面菜单功能\n\n\n\n\n\n\n\n\n\n菜单头文件的结构体枚举\n\n\n\n\n\n\n\n\n\n菜单初始化\n\n\n\n\n\n\n\n\n\n//菜单初始化\nvoid menuInit(void)\n&#123;\n\t//设置上电显示的菜单界面为桌面显示\n\tpModeMenu = &amp;generalModeMenu[GNL_MENU_DESKTOP];\t\n\t//更新刷新界面标志，进入界面后刷新全界面UI\n\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RESET;\t\n&#125;\n\nshowSystemTime  系统时间显示\n\n\n\n\n\n\n\n\n\n//系统时间显示\nstatic void showSystemTime(void)\n&#123;\n\tsprintf(SystemtimeToStr, \"%04d-%02d-%02d %02d:%02d %s\",\n\t                         stuSystemtime.year,\n\t                         stuSystemtime.mon,\n\t                         stuSystemtime.day,\n\t                         stuSystemtime.hour,\n\t                         stuSystemtime.min,\n\t                         stuSystemtime.week);\n\thal_Oled_ShowString(4,54,SystemtimeToStr,8,1);\t\n\thal_Oled_Refresh();\n&#125;\n\ngnlMenu_DesktopCBS  普通菜单桌面回调函数\n\n\n\n\n\n\n\n\n\n//普通菜单桌面回调函数\n static void gnlMenu_DesktopCBS(void)\n&#123;\n\tif(pModeMenu->refreshScreenCmd == SCREEN_CMD_RESET)\n\t&#123;\n\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_NULL;\n\t\tpModeMenu->keyVal = 0xFF;\t\t \n\t\thal_Oled_Clear(); \n\t\thal_Oled_ShowString(0,0,\"N\",8,1);\t\t\n\t\thal_Oled_ShowString(16,20,\"Away arm\",24,1);\n\t\tshowSystemTime();\t\t\n\t\tQueueEmpty(RFDRcvMsg);\n\t\thal_Oled_Refresh();\t\t\n\t&#125;\t\n&#125;\n\nAppProc  App任务\n\n\n\n\n\n\n\n\n\nvoid AppProc(void)\n&#123;\n\tpModeMenu->action();\t\n&#125;\n\n上面是前戏，现在才是设置主菜单\n\n\n\n\n\n\n\n\n这个由产品功能决定，一般中大型产品都会有系统设置，不一定用菜单的形式做，主要用于设置比如说一些定时时间、温度报警阈值、系统时间等等。\n市面上也有很多类似于STM32标准库这样的UI库：\n\nTouchGFX Designer\n\nEmwin\n\n串口屏\n\n\n我自己认为UI设计师实际上没有什么技术含量，所以我想学酷炫的UI就调库就行了\n使用这些图形UI的优点是能够很轻松做出酷炫的LCD显示界面，缺点是这些库比较占用单片机资源，主要是RAM和ROM，还有一些是收费的，像串口屏这种直接是一个模块，单片机通过串口去控制屏显示的内容，虽然方便，但是价格比较贵。\n\n搭建设置菜单代码框架\n\n\n\n\n\n\n\n\n我这里强调一点，现在我们菜单变多就需要先搭框架\n先把每个菜单处理函数定义出来\n\n\n\n\n\n\n\n\n设置主菜单\nstatic void stgMenu_MainMenuCBS(void)\n&#123;\n&#125;\n\n\n\n\n\n\n\n\n\n\n 探测器配对菜单处理函数\nstatic void stgMenu_LearnSensorCBS(void)\n&#123;\n&#125;\n\n\n\n\n\n\n\n\n\n\n探测器列表菜单处理函数\nstatic void stgMenu_DTCListCBS(void)\n&#123;\n&#125;\n\n\n\n\n\n\n\n\n\n\n wifi配网菜单处理函数\nstatic void stgMenu_WifiCBS(void)\n&#123;\n&#125;\n\n\n\n\n\n\n\n\n\n\n 设备信息菜单处理函数\nstatic void stgMenu_MachineInfoCBS(void)\n&#123;\n&#125;\n\n\n\n\n\n\n\n\n\n\n 恢复出厂设置菜单处理函数\nstatic void stgMenu_FactorySettingsCBS(void)\n&#123;\n&#125;\n\n定义设置菜单结构体数组并初始化\n\n\n\n\n\n\n\n\n\nmenuInit  菜单初始化\n\n\n\n\n\n\n\n\n\n//菜单双链表初始化\nstu_mode_menu* MenuDoubleListInit(void)\n&#123;\n\t//把学习传感器菜单当做哨兵位节点\n\tstu_mode_menu* phead = &amp;settingModeMenu[STG_MENU_LEARNING_SENSOR];\n\tphead->pLast = phead;\n\tphead->pNext = phead;\n\t\n\treturn phead;\n&#125;\n//菜单链表尾插\nvoid MenuDoubleListPushBack(stu_mode_menu* phead,stu_mode_menu* node)\n&#123;\n\t//我们先找到链表尾\n\tstu_mode_menu* tail = phead->pLast;\n\ttail->pNext = node;\n\tnode->pLast = tail;\n\tnode->pNext = phead;\n\tphead->pLast = node;\n&#125;\n//菜单初始化\nvoid menuInit(void)\n&#123;\n\tuint8_t\ti;\n\tMenuDoubleListInit();\n\t//主设置菜单初始化,把菜单列表形成链表形式，方便调用\n\tfor(i=STG_MENU_LEARNING_SENSOR; i&lt;STG_MENU_SUM; ++i)\n\t&#123;\n\t\tMenuDoubleListPushBack(&amp;settingModeMenu[STG_MENU_LEARNING_SENSOR],&amp;settingModeMenu[i]);\n\t\tsettingModeMenu[i].pParent = &amp;settingModeMenu[STG_MENU_MAIN_SETTING];\n\t&#125;\t\n\tpModeMenu = &amp;generalModeMenu[GNL_MENU_DESKTOP];\t//设置上电显示的菜单界面为桌面显示\n\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RESET;\t//更新刷新界面标志，进入界面后刷新全界面UI\n&#125;\n\n完善设置主菜单UI和按键功能增加菜单按键功能\n\n\n\n\n\n\n\n\n我们要在桌面菜单下长按S6(确定&#x2F;菜单)键进入设置主菜单\n\n菜单显示\n\n\n\n\n\n\n\n\n选中某个菜单选项的时候，背景是蓝色。一页显示4个菜单。\n\n功能按键\n\n\n\n\n\n\n\n\n需要考虑的几种情况\n&#x3D;&#x3D;1.选中第一个菜单的时候&#x3D;&#x3D;\n\n如果短按S1”上”按键，就要做翻页功能\n如果短按S2”下”按键，那就不需要做翻页，也就是我们不需要把4个菜单界面都重新刷新\n\n&#x3D;&#x3D;2.选中第四个菜单的时候&#x3D;&#x3D;\n\n如果短按S1”上”按键，那就不需要做翻页，也就是我们不需要把4个菜单界面都重新刷新\n如果短按S2”下”按键，就要做翻页功能\n\n&#x3D;&#x3D;3.没有选中第一或者第四个菜单的时候&#x3D;&#x3D;\n\n上按键\n如果短按S1”上”按键，那就不需要做翻页，也就是我们不需要把4个菜单界面都重新刷新。\n下按键\n如果短按S2”下”按键，那就不需要做翻页，也就是我们不需要把4个菜单界面都重新刷新\n\n\n//设置主菜单\nstatic void stgMenu_MainMenuCBS(void)\n&#123;\n\tuint8_t keys;\n\tuint8_t i;\n\tuint8_t ClrScreenFlag;\n\tstatic stu_mode_menu *pMenu;\t\t            //用来保存当前选中的菜单\n\tstatic stu_mode_menu *bpMenu=0;\t\t            //用来备份上一次菜单选项，主要用于刷屏判断\n\tstatic unsigned char stgMainMenuSelectedPos=0;\t//用来记录当前选中菜单的位置\n\tstatic stu_mode_menu *MHead,*MTail;\t\t        //这两个结构体指针是为了上下切换菜单时做翻页处理\n\tif(pModeMenu->refreshScreenCmd == SCREEN_CMD_RESET)\n\t&#123;\n\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_NULL;\n\t\tpMenu = &amp;settingModeMenu[STG_MENU_MAIN_SETTING];\n\t\thal_Oled_Clear();\n\t\thal_Oled_ShowString(37,0,pMenu->pModeType,12,1);\n\t\thal_Oled_Refresh();\n\t\tpMenu = &amp;settingModeMenu[STG_MENU_LEARNING_SENSOR];\n\t\tMHead = pMenu;\t\t\t//记录当前显示菜单第一项\n\t\tMTail = pMenu+3;\t\t//记录当前显示菜单最后一项,一页显示4行\t\t\n\t\tbpMenu = 0;\n \t\tClrScreenFlag = 1;\n\t\tstgMainMenuSelectedPos = STG_MENU_LEARNING_SENSOR;\n\t\tkeys = 0xFF;\n \t&#125;\n\tif(pModeMenu->keyVal != 0xff)\n\t&#123;\n\t\tkeys = pModeMenu->keyVal;\n\t\tpModeMenu->keyVal = 0xFF;\t//恢复菜单按键值\n\t\tswitch(keys)\n\t\t&#123;\n\t\t\tcase KEY1_CLICK:\t\t//上\t\t\t\t\n\t\t\t\tif(stgMainMenuSelectedPos == 1)\n\t\t\t\t&#123;\n\t\t\t\t\tMHead = MHead->pLast;\n\t\t\t\t\tpMenu = pMenu->pLast;\n\t\t\t\t\tMTail = MTail->pLast;\n\t\t\t\t\tstgMainMenuSelectedPos = 1;\n\t\t\t\t\tClrScreenFlag = 1;\n\t\t\t\t&#125;else\n\t\t\t\t&#123;\n\t\t\t\t\t//取消选中本菜单显示\n\t\t\t\t\thal_Oled_ShowString(0,14*stgMainMenuSelectedPos,pMenu->pModeType,8,1);\t\t\n\t\t\t\t\thal_Oled_Refresh();\n\t\t\t\t\tpMenu = pMenu->pLast;\n\t\t\t\t\tstgMainMenuSelectedPos--;\n\t\t\t\t&#125;\n\t\t\tbreak;\n\t\t\tcase KEY2_CLICK:\t\t//下\n\t\t\t\tif(stgMainMenuSelectedPos == 4)\n\t\t\t\t&#123;\n\t\t\t\t\tMHead = MHead->pNext;\t\n\t\t\t\t\tpMenu = pMenu->pNext;\n\t\t\t\t\tMTail = pMenu;\n\t\t\t\t\tstgMainMenuSelectedPos = 4;\n\t\t\t\t\tClrScreenFlag = 1;\n\t\t\t\t&#125;else\n\t\t\t\t&#123;\n\t\t\t\t\t//取消选中本菜单显示\n\t\t\t\t\thal_Oled_ShowString(0,14*stgMainMenuSelectedPos,pMenu->pModeType,8,1);\t\t\n\t\t\t\t\thal_Oled_Refresh();\n\t\t\t\t\t//切换下一个选项\n\t\t\t\t\tpMenu = pMenu->pNext;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\tstgMainMenuSelectedPos++;\n\t\t\t\t&#125;\n\t\t\tbreak;\t\t\t\n\t\t\tcase KEY5_CLICK_RELEASE:\t//取消\n\t\t\t\tpModeMenu = &amp;generalModeMenu[GNL_MENU_DESKTOP];;\n\t\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RESET;\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n\tif(bpMenu != pMenu)\n\t&#123;\n\t\tbpMenu = pMenu;\n\t\tif(ClrScreenFlag)\n\t\t&#123;\t\t\t\n\t\t\tClrScreenFlag = 0;\n\t\t\tpMenu = MHead;\n\t\t\thal_Oled_ClearArea(0,14,128,50);\t\t//清屏\n\t\t\thal_Oled_Refresh();\n\t\t\tfor(i=1; i&lt;5; i++)\n\t\t\t&#123;\n\t\t\t\thal_Oled_ShowString(0,14*i,pMenu->pModeType,8,1);\n\t\t\t\thal_Oled_Refresh();\n\t\t\t\tpMenu = pMenu->pNext;\n\t\t\t&#125; \n\t\t\tpMenu = bpMenu;\n\t\t\thal_Oled_ShowString(0,14*stgMainMenuSelectedPos,pMenu->pModeType,8,0);\n\t\t\thal_Oled_Refresh();\n\t\t&#125;else\n\t\t&#123; \n\t\t\thal_Oled_ShowString(0,14*stgMainMenuSelectedPos,pMenu->pModeType,8,0);\t\n\t\t\thal_Oled_Refresh();\n\t\t&#125;\t\t\t\t\t \n\t&#125;\n&#125;\n\nSTM32驱动OLED实现探测器配对子菜单功能stgMenu_LearnSensorCBS   探测器配对菜单\n\n\n\n\n\n\n\n\n\n//探测器配对菜单处理函数\nstatic void stgMenu_LearnSensorCBS(void)\n&#123;\n\tuint8_t keys,dat,tBuff[3];\n\tstatic uint8_t PairingComplete = 0;\n\tstatic uint16_t Timer = 0;\n\t//用于设置探测器参数时初始化探测器信息\n\tStu_DTC stuTempDevice; \t\t\n\tif(pModeMenu->refreshScreenCmd == SCREEN_CMD_RESET)\n\t&#123;\n\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_NULL;\n\t\tQueueEmpty(RFDRcvMsg);\n\t\t//pMenu = &amp;settingModeMenu[0];\n\t\thal_Oled_Clear();\n\t\thal_Oled_ShowString(28,0,\"Learning DTC\",12,1);\n\t\thal_Oled_ShowString(43,28,\"Pairing...\",8,1);\n\t\thal_Oled_Refresh();\n\t\tkeys = 0xFF;\n\t\tPairingComplete = 0; \n\t\tTimer = 0;\n\t&#125;\n\tif(QueueDataSize(RFDRcvMsg) &amp;&amp; (!PairingComplete))\n\t&#123;\n\t\tQueueDataPop(RFDRcvMsg,&amp;dat);\n\t\tif(dat == '#')\n\t\t&#123;\n\t\t\tQueueDataPop(RFDRcvMsg,&amp;tBuff[2]);\n\t\t\tQueueDataPop(RFDRcvMsg,&amp;tBuff[1]);\n\t\t\tQueueDataPop(RFDRcvMsg,&amp;tBuff[0]);\n\t\t\thal_Oled_ClearArea(0,28,128,36);\t\t//清屏\n\t\t\tstuTempDevice.Code[2] = tBuff[2];\n\t\t\tstuTempDevice.Code[1] = tBuff[1];\n\t\t\tstuTempDevice.Code[0] = tBuff[0];\n\t\t\tif((stuTempDevice.Code[0]==SENSOR_CODE_DOOR_OPEN) ||\n\t\t\t  (stuTempDevice.Code[0]==SENSOR_CODE_DOOR_CLOSE) ||\n\t\t\t  (stuTempDevice.Code[0]==SENSOR_CODE_DOOR_TAMPER)||\n\t\t\t  (stuTempDevice.Code[0]==SENSOR_CODE_DOOR_LOWPWR))\n\t\t\t&#123;\n\t\t\t\t//是无线门磁码\n\t\t\t\tstuTempDevice.DTCType = DTC_DOOR;\n\t\t\t&#125;\n\t\t\telse if((stuTempDevice.Code[0]==SENSOR_CODE_REMOTE_ENARM) ||\n\t\t\t       (stuTempDevice.Code[0]==SENSOR_CODE_REMOTE_DISARM) ||\n\t\t\t      (stuTempDevice.Code[0]==SENSOR_CODE_REMOTE_HOMEARM) ||\n\t\t\t      (stuTempDevice.Code[0]==SENSOR_CODE_REMOTE_SOS))\n\t\t\t&#123;\n\t\t\t\t//无线遥控器码\n\t\t\t\tstuTempDevice.DTCType = DTC_REMOTE;\n\t\t\t&#125;\n\t\t\telse if((stuTempDevice.Code[0]==SENSOR_CODE_PIR)||\n\t\t\t (stuTempDevice.Code[0]==SENSOR_CODE_PIR_LOWPWR)|| \n\t\t\t(stuTempDevice.Code[0]==SENSOR_CODE_PIR_TAMPER))\n\t\t\t&#123;\n\t\t\t\t//无线红外码\n\t\t\t\tstuTempDevice.DTCType = DTC_PIR;\n\t\t\t&#125;\n\t\t\tstuTempDevice.ZoneType = ZONE_TYP_1ST;\n\t\t\tif(AddDtc(&amp;stuTempDevice) != 0xFF)\n\t\t\t&#123;\n\t\t\t\tswitch(stuTempDevice.DTCType)\n\t\t\t\t&#123;\n\t\t\t\t\tcase DTC_DOOR:\n\t\t\t\t\t\thal_Oled_ShowString(34,28,\"Success!\",8,1);\n\t\t\t\t\t\thal_Oled_ShowString(16,36,\"Added door dtc..\",8,1);\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase DTC_REMOTE:\n\t\t\t\t\t\thal_Oled_ShowString(34,28,\"Success!\",8,1);\n\t\t\t\t\t\thal_Oled_ShowString(7,36,\"Added remote dtc..\",8,1);\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase DTC_PIR:\n\t\t\t\t\t\thal_Oled_ShowString(34,28,\"Success!\",8,1);\n\t\t\t\t\t\thal_Oled_ShowString(19,36,\"Added pir dtc..\",8,1);\n\t\t\t\t\tbreak;\n\t\t\t\t&#125;\n\t\t\t\thal_Oled_Refresh();\n\t\t\t\tPairingComplete = 1;\t\t//配对完成标志\n\t\t\t\tTimer = 0;\t\t \n\t\t\t&#125;else\n\t\t\t&#123;\n\t\t\t\thal_Oled_ShowString(34,28,\"Fail...\",8,1);\n\t\t\t\thal_Oled_Refresh();\n\t\t\t&#125;\t\t\t\n\t\t&#125;\t\t\n\t&#125;\t\n\tif(pModeMenu->keyVal != 0xff)\n\t&#123;\n\t\tkeys = pModeMenu->keyVal;\n\t\tpModeMenu->keyVal = 0xFF;\t//恢复菜单按键值\n\t\tswitch(keys)\n\t\t&#123;\n\t\t\tcase KEY5_CLICK_RELEASE:\t//取消\n\t\t\t\tpModeMenu = pModeMenu->pParent;\n\t\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RECOVER;\n\t\t\tbreak;\n\t\t\tcase KEY5_LONG_PRESS:\t\t//返回桌面\n\t\t\t\tpModeMenu = &amp;generalModeMenu[GNL_MENU_DESKTOP];\n\t\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RESET;\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n\tif(PairingComplete)\n\t&#123;\n\t\tTimer++;\n\t\tif(Timer > 150)//+1=10ms,10*150=1500ms=1.5s\n\t\t&#123;\n\t\t\tTimer = 0;\n\t\t\tpModeMenu = pModeMenu->pParent;\t\t\t//1.5秒时间到，自动返回父级菜单\n\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RESET;\n\t\t&#125;\n\t&#125;\n&#125;\n\nSTM32驱动OLED实现探测器列表多级子菜单功能探测器列表的作用\n\n\n\n\n\n\n\n\n\n查看目前已经配对的探测器数量\n查看指定探测器的详细属性\n编辑指定探测器的属性\n删除指定探测器\n\n\n//探测器列表菜单处理函数\nstatic void stgMenu_DTCListCBS(void)\n&#123;\n\tuint8_t keys;\n\tuint8_t i,j;\n\tuint8_t ClrScreenFlag;\n\tStu_DTC tStuDtc;\t \n\t//static Stu_DTC StuDTCtemp[PARA_DTC_SUM];\n\tstatic char DtcNameBuff[PARA_DTC_SUM][16];//这个比上面那个节省空间\n\tstatic stu_mode_menu settingMode_DTCList_Sub_Menu[PARA_DTC_SUM];\n\tstatic stu_mode_menu* pMenu;\n\t//用来备份上一次菜单选项，主要用于刷屏判断\n\tstatic stu_mode_menu* bpMenu=0;\t\t\n\t//用来记录当前选中菜单的位置\n\tstatic uint8_t stgMainMenuSelectedPos=0;\t\n\t//这两个结构是为了上下切换菜单时做翻页处理\n\tstatic stu_mode_menu* MHead,*MTail;\t\t\n\t//用来动态指示菜单下标,最终这个就是已学习探测器的总数量\t\n\tstatic uint8_t pMenuIdx=0;\t\t\n\tif(pModeMenu->refreshScreenCmd == SCREEN_CMD_RESET)\n\t&#123;\n\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_NULL;\t\t\n\t\tpMenuIdx = 0;\n\t\tstgMainMenuSelectedPos = 1;\n\t\tbpMenu = 0;\n\t\tClrScreenFlag = 1;\t\t \n\t\tkeys = 0xFF;\t\t\n\t\tpMenu = settingMode_DTCList_Sub_Menu;\t\t\n\t\thal_Oled_Clear();\n\t\thal_Oled_ShowString(40,0,\"Dtc List\",12,1);\n\t\thal_Oled_Refresh();\t\t\n\t\t//逐个判断，把配对的探测器都找出来\n\t\tfor(i=0; i&lt;PARA_DTC_SUM; i++)\n\t\t&#123;\n\t\t\tif(CheckPresenceofDtc(i))\n\t\t\t&#123;\n\t\t\t\tGetDtcStu(&amp;tStuDtc,i);\n\t\t\t\t(pMenu+pMenuIdx)->ID = pMenuIdx;\n\t\t\t\t//(pMenu+0)->ID = 0;\t\t\t\t\n\t\t\t\t(pMenu+pMenuIdx)->menuPos = STG_SUB_3_MENU_POS;\n\t\t\t\t(pMenu+pMenuIdx)->reserved = tStuDtc.ID-1;\n\t\t\t\t//StuDTCtemp[pMenuIdx].ID = tStuDtc.ID;\n\t\t\t\tfor(j=0; j&lt;16; j++)\n\t\t\t\t&#123;\n\t\t\t\t\t//StuDTCtemp[pMenuIdx].Name[j] = tStuDtc.Name[j];\n\t\t\t\t\tDtcNameBuff[pMenuIdx][j] = tStuDtc.Name[j];\n\t\t\t\t&#125;\t\t\t \n\t\t\t\t//(pMenu+pMenuIdx)->pModeType = StuDTCtemp[pMenuIdx].Name;\t\t\t\t\n\t\t\t\t(pMenu+pMenuIdx)->pModeType = DtcNameBuff[pMenuIdx];\n\t\t\t\tpMenuIdx++;\n\t\t\t&#125;\n\t\t&#125;\t\t\n\t\tif(pMenuIdx != 0)\n\t\t&#123;\n\t\t\t//有探测器存在的情况\n\t\t\tMenuDoubleListInit(&amp;settingMode_DTCList_Sub_Menu[0]);\t\t\t\n\t\t\tfor(i = 1;i &lt; pMenuIdx;++i)\n\t\t\t&#123;\n\t\t\t\tMenuDoubleListPushBack(&amp;settingMode_DTCList_Sub_Menu[0],\n\t\t\t\t                       &amp;settingMode_DTCList_Sub_Menu[i]);\n\t\t\t\tsettingMode_DTCList_Sub_Menu[i-1].pParent \n\t\t\t =  &amp;settingModeMenu[STG_MENU_MAIN_SETTING];\n\t\t\t&#125;\n\t\t&#125;else\n\t\t&#123;\n\t\t\t//没有探测器\n\t\t\tbpMenu = pMenu;\n\t\t\thal_Oled_ShowString(0,14,\" No detectors.\",8,1);\n\t\t\thal_Oled_Refresh();\n\t\t&#125;\n\t\tMHead = pMenu;\t\t\t//记录当前显示菜单第一项\n\t\tpMenuIdx &lt; 5 ? MTail = pMenu->pLast\n\t\t             : (MTail = pMenu+3);\t\t//记录当前显示菜单最后一项,一页显示4行\t\t\n\t&#125;\n\telse if(pModeMenu->refreshScreenCmd==SCREEN_CMD_RECOVER)\n\t&#123;\t\n\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_NULL;\n\t\t//恢复之前的选择位置显示\n\t\thal_Oled_Clear();\n\t\thal_Oled_ShowString(40,0,\"Dtc List\",12,1);\n\t\thal_Oled_Refresh();\n\t\tkeys = 0xFF;\n\t\tClrScreenFlag = 1;\n\t\tbpMenu = 0;\t\t\n\t&#125;\n\t\n\tif(pModeMenu->keyVal != 0xff)\n\t&#123;\n\t\tkeys = pModeMenu->keyVal;\n\t\tpModeMenu->keyVal = 0xFF;\t//恢复菜单按键值\n\t\tswitch(keys)\n\t\t&#123;\n\t\t\tcase KEY1_CLICK_RELEASE:\t\t//上\n\t\t\t\tif(pMenuIdx&lt;2)\n\t\t\t\t&#123;\n\t\t\t\t\t//只有一个菜单不做处理\n\t\t\t\t&#125;\n\t\t\t\telse if(pMenuIdx &lt; 5)\n\t\t\t\t&#123;\n\t\t\t\t\t//不清屏，直接刷新局部显示,只有一页，也就是4个探测器的时候\n\t\t\t\t\t//取消选中本菜单显示\n\t\t\t\t\thal_Oled_ShowString(0,14*stgMainMenuSelectedPos,pMenu->pModeType,8,1);\t\t\n\t\t\t\t\thal_Oled_Refresh();\n\t\t\t\t\tpMenu = pMenu->pLast;\t\t\t\t\t\n\t\t\t\t\tstgMainMenuSelectedPos ==1\t//判断是否选中的是第一行\t\n\t\t\t\t\t//头尾指针不变，只把当前菜单指向上一个\n\t\t\t\t\t?stgMainMenuSelectedPos = pMenuIdx\t\t\t\t\t\t\n\t\t\t\t\t:stgMainMenuSelectedPos--;\t\t\t\t\t\n\t\t\t\t&#125;else if(pMenuIdx > 4)\t//当前探测器超过4个\n\t\t\t\t&#123;\n\t\t\t\t\tif(stgMainMenuSelectedPos ==1)\t//判断是否选中的是第一行\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tMHead = MHead->pLast;\n\t\t\t\t\t\tpMenu = pMenu->pLast;\n\t\t\t\t\t\tMTail = MTail->pLast;\n\t\t\t\t\t\tstgMainMenuSelectedPos = 1;\n\t\t\t\t\t\tClrScreenFlag = 1;\n\t\t\t\t\t&#125;else\n\t\t\t\t\t&#123;\n\t\t\t\t\t\t//取消选中本菜单显示\n\t\t\t\t\t\thal_Oled_ShowString(0,14*stgMainMenuSelectedPos,pMenu->pModeType,8,1);\t\t\n\t\t\t\t\t\thal_Oled_Refresh();\n\t\t\t\t\t\t//切换上一个选项\n\t\t\t\t\t\tpMenu = pMenu->pLast;\n\t\t\t\t\t\tstgMainMenuSelectedPos--;\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\tbreak;\t\t\t\n\t\t\tcase KEY2_CLICK_RELEASE:\t\t//下 \n\t\t\t\tif(pMenuIdx&lt;2)\n\t\t\t\t&#123;\n\t\t\t\t\t//只有一个菜单不做处理\n\t\t\t\t&#125;\n\t\t\t\telse if(pMenuIdx &lt; 5)\n\t\t\t\t&#123;\n\t\t\t\t\t//不清屏，直接刷新局部显示,只有一页，也就是不超过4个探测器的时候\n\t\t\t\t\t//取消选中本菜单显示\n\t\t\t\t\thal_Oled_ShowString(0,14*stgMainMenuSelectedPos,pMenu->pModeType,8,1);\t\t\n\t\t\t\t\thal_Oled_Refresh();\t\t\t\t\t\n\t\t\t\t\tpMenu = pMenu->pNext;\n\t\t\t\t\tstgMainMenuSelectedPos ==pMenuIdx\t//判断是否选中的是第4行\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t?stgMainMenuSelectedPos = 1\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//切换下一个选项\n\t\t\t\t\t:stgMainMenuSelectedPos++;\t\t\t\t\t\n\t\t\t\t&#125;else if(pMenuIdx > 4)\t//当前探测器超过4个\n\t\t\t\t&#123;\n\t\t\t\t\tif(stgMainMenuSelectedPos ==4)\t//判断是否选中的是第一行\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tMHead = MHead->pNext;\t\n\t\t\t\t\t\tpMenu = pMenu->pNext;\n\t\t\t\t\t\tMTail = pMenu;\n\t\t\t\t\t\tstgMainMenuSelectedPos = 4;\n\t\t\t\t\t\tClrScreenFlag = 1;\n\t\t\t\t\t&#125;else\n\t\t\t\t\t&#123;\n\t\t\t\t\t\t//取消选中本菜单显示\n\t\t\t\t\t\thal_Oled_ShowString(0,14*stgMainMenuSelectedPos,pMenu->pModeType,8,1);\t\t\n\t\t\t\t\t\thal_Oled_Refresh();\n\t\t\t\t\t\t//切换下一个选项\n\t\t\t\t\t\tpMenu = pMenu->pNext;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tstgMainMenuSelectedPos++;\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\tbreak;\t\t\t\n\t\t\tcase KEY6_CLICK_RELEASE:\t\t\t//确定\n\t\t\t\tif(pMenuIdx>0)\n\t\t\t\t&#123;\n\t\t\t\t\tpModeMenu = &amp;DL_ZX_Review[STG_MENU_DL_ZX_REVIEW_MAIN]; \n\t\t\t\t\tpModeMenu->reserved = pMenu->reserved;\t//这里用于传递后面要查看、修改、删除探测器的ID号\n\t\t\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RESET;\n\t\t\t\t&#125;\n\t\t\tbreak;\t\t\t\n\t\t\tcase KEY5_CLICK_RELEASE:\t//取消\n\t\t\t\tpModeMenu = pModeMenu->pParent;\n\t\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RECOVER;\n\t\t\tbreak;\n\t\t\tcase KEY5_LONG_PRESS:\t\t//返回桌面\n\t\t\t\tpModeMenu = &amp;generalModeMenu[GNL_MENU_DESKTOP];;\n\t\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RESET;\n\t\t\tbreak;\t\t\t\n\t\t&#125;\n\t&#125;\t\n\tif(bpMenu != pMenu)\n\t&#123;\n\t\tbpMenu = pMenu;\n\t\tif(ClrScreenFlag)\n\t\t&#123;\n\t\t\tClrScreenFlag = 0;\n\t\t\tpMenu = MHead;\n\t\t\thal_Oled_ClearArea(0,14,128,50);\t\t//清屏\n\t\t\thal_Oled_Refresh();\n\t\t\tif(pMenuIdx &lt;4)\n\t\t\t&#123;\n\t\t\t\tfor(i=0; i&lt;pMenuIdx; i++)\n\t\t\t\t&#123;\n\t\t\t\t\thal_Oled_ShowString(0,14*(i+1),pMenu->pModeType,8,1);\n\t\t\t\t\thal_Oled_Refresh();\n\t\t\t\t\tpMenu = pMenu->pNext;\n\t\t\t\t&#125;\n\t\t\t&#125;else\n\t\t\t&#123;\n\t\t\t\tfor(i=1; i&lt;5; i++)\n\t\t\t\t&#123;\n\t\t\t\t\thal_Oled_ShowString(0,14*i,pMenu->pModeType,8,1);\n\t\t\t\t\thal_Oled_Refresh();\n\t\t\t\t\tpMenu = pMenu->pNext;\n\t\t\t\t&#125; \n\t\t\t&#125;\n\t\t\tpMenu = bpMenu;\n\t\t\thal_Oled_ShowString(0,14*stgMainMenuSelectedPos,pMenu->pModeType,8,0);\n\t\t\thal_Oled_Refresh();\n\t\t\t \n\t\t&#125;else\n\t\t&#123; \n\t\t\thal_Oled_ShowString(0,14*stgMainMenuSelectedPos,pMenu->pModeType,8,0);\t\n\t\t\thal_Oled_Refresh();\n\t\t\t\n\t\t&#125;\t\n\t&#125; \n&#125;\n\n探测器列表信息主菜单\n\n\n\n\n\n\n\n\n\n//探测器列表信息主菜单\nstatic void stgMenu_dl_ReviewMainCBS(void)\n&#123;\n\tuint8_t keys = 0xFF;\n\tuint8_t i,ClrScreenFlag=0;\n\tStu_DTC tStuDtc;\n\tstatic stu_mode_menu *MHead;\t\t//这两个结构用来方便显示，页面的头跟尾\n\tstatic stu_mode_menu *pMenu,*bpMenu=0;\t//用来记录当前选中的菜单\n\tstatic uint8_t stgMainMenuSelectedPos=0;\t\t\t\t \n\tif(pModeMenu->refreshScreenCmd == SCREEN_CMD_RESET)\n\t&#123;\t//执行页面切换时屏幕刷新显示 \n\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_NULL;\n\t\tif(CheckPresenceofDtc(pModeMenu->reserved))\n\t\t&#123;\n\t\t\tGetDtcStu(&amp;tStuDtc,pModeMenu->reserved);\t//读取探测器信息\n\t\t&#125;\n\t\thal_Oled_Clear();\n\t\thal_Oled_ShowString(40,0,tStuDtc.Name,12,1);\n\t\thal_Oled_Refresh();\n\t\tpMenu = &amp;DL_ZX_Review[1];\n\t\tstgMainMenuSelectedPos = 1;\n\t\tMHead = pMenu;\t\t\t//记录当前显示菜单第一项\n\t\tClrScreenFlag = 1;\n\t\tbpMenu = 0;\n\t\tkeys = 0xFF;\n\t&#125;else if(pModeMenu->refreshScreenCmd==SCREEN_CMD_RECOVER)\n\t&#123;\n\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_NULL;\n\t\t//恢复之前的选择位置显示\n\t\tif(CheckPresenceofDtc(pModeMenu->reserved))\n\t\t&#123;\n\t\t\tGetDtcStu(&amp;tStuDtc,pModeMenu->reserved);\t//读取探测器信息\n\t\t&#125;\n\t\thal_Oled_Clear();\n\t\thal_Oled_ShowString(40,0,tStuDtc.Name,12,1);\n\t\thal_Oled_Refresh();\n\t\tkeys = 0xFF;\n\t\tClrScreenFlag = 1;\n\t\tbpMenu = 0;\n\t&#125;\n\tif(pModeMenu->keyVal != 0xff)\n\t&#123;\n\t\tkeys = pModeMenu->keyVal;\n\t\tpModeMenu->keyVal = 0xFF;\t//恢复菜单按键值\n\t\tswitch(keys)\n\t\t&#123;\n\t\t\tcase KEY1_CLICK:\t\t//上\n\t\t\t\tif(stgMainMenuSelectedPos ==1)\n\t\t\t\t&#123;\n\t\t\t\t\tpMenu = pMenu->pLast;\n\t\t\t\t\tstgMainMenuSelectedPos = 3;\n\t\t\t\t\tClrScreenFlag = 1;\n\t\t\t\t&#125;else\n\t\t\t\t&#123;//取消选中本菜单显示\n\t\t\t\t\thal_Oled_ShowString(0,14*stgMainMenuSelectedPos,pMenu->pModeType,8,1);\t\t\n\t\t\t\t\thal_Oled_Refresh();\n\t\t\t\t\tpMenu = pMenu->pLast;\n\t\t\t\t\tstgMainMenuSelectedPos--;\n\t\t\t\t&#125;\n\t\t\tbreak;\n\t\t\tcase KEY2_CLICK:\t\t//下\n\t\t\t\tif(stgMainMenuSelectedPos ==3)\n\t\t\t\t&#123;\n\t\t\t\t\tpMenu = pMenu->pNext;\n\t\t\t\t\tstgMainMenuSelectedPos = 1;\n\t\t\t\t\tClrScreenFlag = 1;\n\t\t\t\t&#125;else\n\t\t\t\t&#123;//取消选中本菜单显示\n\t\t\t\t\thal_Oled_ShowString(0,14*stgMainMenuSelectedPos,pMenu->pModeType,8,1);\t\t\n\t\t\t\t\thal_Oled_Refresh();\n\t\t\t\t\tpMenu = pMenu->pNext;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\tstgMainMenuSelectedPos++;\n\t\t\t\t&#125;\n\t\t\tbreak;\n\t\t\tcase KEY6_CLICK_RELEASE:\n\t\t\t    //继续把指定探测器结构体数组下标传递下去\n\t\t\t\tpMenu->reserved = pModeMenu->reserved;\t\n\t\t\t\tpModeMenu = pMenu;\n\t\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RESET;\n\t\t\tbreak;\n\t\t\tcase KEY5_CLICK_RELEASE:\n\t\t\t    //这里不能直接返回父级，因为探测器个数是动态的，父级没初始化\n\t\t\t\tpModeMenu = &amp;settingModeMenu[STG_MENU_DTC_LIST];\t\n\t\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RECOVER;\n\t\t\tbreak;\n\t\t\tcase KEY5_LONG_PRESS:\n\t\t\t\tpModeMenu = &amp;generalModeMenu[GNL_MENU_DESKTOP];;\n\t\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RESET;\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n\tif(bpMenu != pMenu)\n\t&#123;\n\t\tbpMenu = pMenu;\n\t\tif(ClrScreenFlag)\n\t\t&#123;\n\t\t\tClrScreenFlag = 0;\n\t\t\tpMenu = MHead;\n\t\t\thal_Oled_ClearArea(0,14,128,50);\t\t//清屏\n\t\t\thal_Oled_Refresh();\n\t\t\tfor(i=0; i&lt;3; i++)\n\t\t\t&#123;\n\t\t\t\thal_Oled_ShowString(0,14*(i+1),pMenu->pModeType,8,1);\n\t\t\t\thal_Oled_Refresh();\n\t\t\t\tpMenu = pMenu->pNext;\n\t\t\t&#125; \n\t\t\tpMenu = bpMenu;\n\t\t\thal_Oled_ShowString(0,14*stgMainMenuSelectedPos,pMenu->pModeType,8,0);\n\t\t\thal_Oled_Refresh();\n\t\t\t \n\t\t&#125;else\n\t\t&#123; \n\t\t\thal_Oled_ShowString(0,14*stgMainMenuSelectedPos,pMenu->pModeType,8,0);\t\n\t\t\thal_Oled_Refresh();\n\t\t&#125;\t\t \n\t&#125;\n&#125;\n\n探测器列表信息查看\n\n\n\n\n\n\n\n\n\n //探测器列表信息查看\nstatic void stgMenu_dl_ReviewCBS(void)\n&#123;\n\tunsigned char keys = 0xFF;\n\tStu_DTC tStuDtc;\n\tunsigned char temp[6];\n\tif(pModeMenu->refreshScreenCmd == SCREEN_CMD_RESET)\n\t&#123;\t//执行页面切换时屏幕刷新显示 \n\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_NULL;\n\t\tif(CheckPresenceofDtc(pModeMenu->reserved))\n\t\t&#123;\n\t\t\tGetDtcStu(&amp;tStuDtc,pModeMenu->reserved);\n\t\t&#125;\n\t\thal_Oled_Clear();\n\t\thal_Oled_ShowString(40,0,pModeMenu->pModeType,12,1);\n\t\thal_Oled_ShowString(0,16,\"&lt;Name>: \",8,1); \n\t\t//&lt;Name>: 8个字符，8*6=48\n\t\thal_Oled_ShowString(48,16,tStuDtc.Name,8,1);\n\t\thal_Oled_ShowString(0,28,\"&lt;Type>: \",8,1);\n\t\tif(tStuDtc.DTCType == DTC_DOOR)\n\t\t&#123;\n\t\t\thal_Oled_ShowString(48,28,\"door dtc\",8,1);\n\t\t&#125;else if(tStuDtc.DTCType == DTC_PIR)\n\t\t&#123;\n\t\t\thal_Oled_ShowString(48,28,\"pir dtc\",8,1);\n\t\t&#125;else if(tStuDtc.DTCType == DTC_REMOTE)\n\t\t&#123;\n\t\t\thal_Oled_ShowString(48,28,\"remote\",8,1);\n\t\t&#125;\n\t\thal_Oled_ShowString(0,40,\"&lt;ZoneType>: \",8,1);\n\t\tif(tStuDtc.ZoneType == ZONE_TYP_24HOURS)\n\t\t&#123;\n\t\t\thal_Oled_ShowString(72,40,\"24 hrs\",8,1);\n\t\t&#125;else if(tStuDtc.ZoneType == ZONE_TYP_1ST)\n\t\t&#123;\n\t\t\thal_Oled_ShowString(72,40,\"1ST\",8,1);\n\t\t&#125;else if(tStuDtc.ZoneType == ZONE_TYP_2ND)\n\t\t&#123;\n\t\t\thal_Oled_ShowString(72,40,\"2ND\",8,1);\n\t\t&#125;\n\t\thal_Oled_ShowString(0,52,\"&lt;RFCode>: \",8,1);\n\t\tHexToAscii(tStuDtc.Code,temp,3);\n\t\thal_Oled_ShowChar(60,52,temp[4],8,1);\n\t\thal_Oled_ShowChar(66,52,temp[5],8,1);\n\t\thal_Oled_ShowChar(72,52,' ',8,1);\n\t\thal_Oled_ShowChar(80,52,temp[2],8,1);\n\t\thal_Oled_ShowChar(86,52,temp[3],8,1);\n\t\thal_Oled_Refresh();\n\t&#125;\n\tif(pModeMenu->keyVal != 0xff)\n\t&#123;\n\t\tkeys = pModeMenu->keyVal;\n\t\tpModeMenu->keyVal = 0xFF;\t//恢复菜单按键值\n\t\tswitch(keys)\n\t\t&#123;\n\t\t\tcase KEY5_CLICK_RELEASE:\n\t\t\t\tpModeMenu = &amp;DL_ZX_Review[STG_MENU_DL_ZX_REVIEW_MAIN];\n\t\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RECOVER;\n\t\t\tbreak;\n\t\t\tcase KEY6_CLICK_RELEASE:\n\t\t\t\tpModeMenu = &amp;DL_ZX_Review[STG_MENU_DL_ZX_REVIEW_MAIN];\n\t\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RECOVER;\n\t\t\tbreak;\n\t\t\tcase KEY5_LONG_PRESS:\n\t\t\t\tpModeMenu = &amp;generalModeMenu[GNL_MENU_DESKTOP];\n\t\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RESET;\n\t\t\tbreak;\n\t\t&#125;\n\t&#125;\n&#125;\n\n探测器编辑\n\n\n\n\n\n\n\n\n\n\n//探测器编辑\nstatic void stgMenu_dl_EditCBS(void)\n&#123;\n\tuint8_t keys = 0xFF;\n\tstatic Stu_DTC tStuDtc;\n\tstatic uint16_t timer = 0;\n\tstatic uint8_t editComplete = 0;\n\tstatic uint8_t* pDL_ZX_Edit_DTCType_Val[DTC_TYP_SUM] =\n\t&#123;\n\t\t\"door dtc\",\n\t\t\"pir dtc\",\n\t\t\"remote\",\n\t&#125;;\n\tstatic uint8_t* pDL_ZX_Edit_ZoneType_Val[STG_DEV_AT_SUM] =\n\t&#123;\n\t\t\"24 hrs\",\n\t\t\"1ST\",\n\t\t\"2ND\",\n\t&#125;;\n\tstatic uint8_t stgMainMenuSelectedPos=0;\n\tstatic uint8_t setValue = DTC_DOOR;\n\tstu_mode_menu* updateMenu;//一个临时更新菜单界面\n\tif(pModeMenu->refreshScreenCmd == SCREEN_CMD_RESET)\n\t&#123;\t//执行页面切换时屏幕刷新显示 \n\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_NULL;\n\t\tstgMainMenuSelectedPos = 0; \n\t\tif(CheckPresenceofDtc(pModeMenu->reserved))\n\t\t&#123;\n\t\t\tGetDtcStu(&amp;tStuDtc,pModeMenu->reserved);\n\t\t&#125;\n\t\tstgMainMenuSelectedPos = 0;\n\t\tsetValue = tStuDtc.DTCType;\n\t\thal_Oled_Clear();\n\t\thal_Oled_ShowString(40,0,pModeMenu->pModeType,12,1);\n\t\thal_Oled_Refresh();\n\t\thal_Oled_ShowString(0,16,\"&lt;Name>: \",8,1); \n\t\thal_Oled_ShowString(48,16,tStuDtc.Name,8,1);\n\t\thal_Oled_ShowString(0,28,\"&lt;Type>: \",8,1);\n\t\thal_Oled_Refresh();\n\t\tif(tStuDtc.DTCType == DTC_DOOR)\n\t\t&#123;\n\t\t\thal_Oled_ShowString(48,28,\"door dtc\",8,0);\n\t\t&#125;else if(tStuDtc.DTCType == DTC_PIR)\n\t\t&#123;\n\t\t\thal_Oled_ShowString(48,28,\"pir dtc\",8,0);\n\t\t&#125;else if(tStuDtc.DTCType == DTC_REMOTE)\n\t\t&#123;\n\t\t\thal_Oled_ShowString(48,28,\"remote\",8,0);\n\t\t&#125;\n\t\thal_Oled_Refresh();\n\t\thal_Oled_ShowString(0,40,\"&lt;ZoneType>: \",8,1);\n\t\thal_Oled_Refresh();\n\t\tif(tStuDtc.ZoneType == ZONE_TYP_24HOURS)\n\t\t&#123;\n\t\t\thal_Oled_ShowString(72,40,\"24 hrs\",8,1);\n\t\t&#125;else if(tStuDtc.ZoneType == ZONE_TYP_1ST)\n\t\t&#123;\n\t\t\thal_Oled_ShowString(72,40,\"1ST\",8,1);\n\t\t&#125;else if(tStuDtc.ZoneType == ZONE_TYP_2ND)\n\t\t&#123;\n\t\t\thal_Oled_ShowString(72,40,\"2ND\",8,1);\n\t\t&#125;\n\t\thal_Oled_Refresh();\n\t\teditComplete = 0;\n\t\ttimer = 0;\n\t&#125;\n\tif(pModeMenu->keyVal != 0xff)\n\t&#123;\n\t\tkeys = pModeMenu->keyVal;\n\t\tpModeMenu->keyVal = 0xFF;\t//恢复菜单按键值\n\t\tif(keys == KEY3_CLICK_RELEASE)\n\t\t&#123;\n\t\t\tif(stgMainMenuSelectedPos == 0)\t\t\n\t\t\t&#123;\n\t\t\t\t//设置Type\n\t\t\t\tif(setValue == DTC_DOOR)\n\t\t\t\t&#123;\n\t\t\t\t\tsetValue = DTC_TYP_SUM-1;\n\t\t\t\t&#125;else\n\t\t\t\t&#123;\n\t\t\t\t\tsetValue--;\n\t\t\t\t&#125;\n\t\t\t\t//更新探测器参数\n\t\t\t\ttStuDtc.DTCType = (DTC_TYPE_TYPEDEF)setValue;\t\t\t\n\t\t\t\thal_Oled_ClearArea(48,28,80,8);\t\t//清屏\n\t\t\t\thal_Oled_ShowString(48,28,pDL_ZX_Edit_DTCType_Val[setValue],8,0);\n\t\t\t\thal_Oled_Refresh();\n\t\t\t&#125;else if(stgMainMenuSelectedPos == 1)\n\t\t\t&#123;\n\t\t\t\t//设置Zone type\n\t\t\t\tif(setValue == ZONE_TYP_24HOURS)\n\t\t\t\t&#123;\n\t\t\t\t\tsetValue = STG_DEV_AT_SUM-1;\n\t\t\t\t&#125;else\n\t\t\t\t&#123;\n\t\t\t\t\tsetValue--;\n\t\t\t\t&#125;\n\t\t\t\t//更新探测器参数\n\t\t\t\ttStuDtc.ZoneType = (ZONE_TYPED_TYPEDEF)setValue;\t\t\t\n\t\t\t\thal_Oled_ClearArea(72,40,56,8);\t\t//清屏\n\t\t\t\thal_Oled_ShowString(72,40,pDL_ZX_Edit_ZoneType_Val[setValue],8,0);\n\t\t\t\thal_Oled_Refresh();\n\t\t\t&#125;\n\t\t&#125;else if(keys == KEY4_CLICK_RELEASE)\n\t\t&#123;\n\t\t\tif(stgMainMenuSelectedPos == 0)\n\t\t\t&#123;\n\t\t\t\t//设置Type\n\t\t\t\tif(setValue == (DTC_TYP_SUM-1))\n\t\t\t\t&#123;\n\t\t\t\t\tsetValue = 0;\n\t\t\t\t&#125;else\n\t\t\t\t&#123;\n\t\t\t\t\tsetValue++;\n\t\t\t\t&#125;\n\t\t\t\t//更新探测器参数\n\t\t\t\ttStuDtc.DTCType = (DTC_TYPE_TYPEDEF)setValue;\t\t\t\n\t\t\t\thal_Oled_ClearArea(48,28,80,8);\t\t//清屏\n\t\t\t\thal_Oled_ShowString(48,28,pDL_ZX_Edit_DTCType_Val[setValue],8,0);\n\t\t\t\thal_Oled_Refresh();\n\t\t\t&#125;else if(stgMainMenuSelectedPos == 1)\n\t\t\t&#123;\n\t\t\t\t//设置Zone type\n\t\t\t\tif(setValue == (STG_DEV_AT_SUM-1))\n\t\t\t\t&#123;\n\t\t\t\t\tsetValue = 0;\n\t\t\t\t&#125;else\n\t\t\t\t&#123;\n\t\t\t\t\tsetValue++;\n\t\t\t\t&#125;\n\t\t\t\t//更新探测器参数\n\t\t\t\ttStuDtc.ZoneType = (ZONE_TYPED_TYPEDEF)setValue;\t\t\t\n\t\t\t\thal_Oled_ClearArea(72,40,56,8);\t\t//清屏\n\t\t\t\thal_Oled_ShowString(72,40,pDL_ZX_Edit_ZoneType_Val[setValue],8,0);\n\t\t\t\thal_Oled_Refresh();\n\t\t\t&#125;\n\t\t&#125;else if((keys==KEY1_CLICK_RELEASE) || (keys==KEY2_CLICK_RELEASE))\n\t\t&#123;\n\t\t\tif(stgMainMenuSelectedPos == 0)\n\t\t\t&#123;\n\t\t\t\tstgMainMenuSelectedPos = 1;\n\t\t\t\tsetValue = tStuDtc.ZoneType;\n\t\t\t\thal_Oled_ClearArea(48,28,80,8);\t\t//清屏\n\t\t\t\t//恢复探测器类型未选中显示\n\t\t\t\thal_Oled_ShowString(48,28,pDL_ZX_Edit_DTCType_Val[tStuDtc.DTCType],8,1);\t\n\n\t\t\t\thal_Oled_ClearArea(72,40,56,8);\t\t//清屏\n\t\t\t\t//切换选中菜单到防区类型\n\t\t\t\thal_Oled_ShowString(72,40,pDL_ZX_Edit_ZoneType_Val[setValue],8,0);\t\t\t\n\t\t\t\thal_Oled_Refresh();\n\t\t\t&#125;else\n\t\t\t&#123;\n\t\t\t\tstgMainMenuSelectedPos = 0;\n\t\t\t\tsetValue = tStuDtc.DTCType;\n\t\t\t\thal_Oled_ClearArea(48,28,80,8);\t\t//清屏\n\t\t\t\t//切换选中菜单到探测器类型\n\t\t\t\thal_Oled_ShowString(48,28,pDL_ZX_Edit_DTCType_Val[setValue],8,0);\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\thal_Oled_ClearArea(72,40,56,8);\t\t//清屏\n\t\t\t\t//恢复探测器防区类型未选中显示\n\t\t\t\thal_Oled_ShowString(72,40,pDL_ZX_Edit_ZoneType_Val[tStuDtc.ZoneType],8,1);\t\n\t\t\t\t\n\t\t\t\thal_Oled_Refresh();\n\t\t\t&#125;\n\t\t&#125;else if(keys == KEY5_CLICK_RELEASE)\n\t\t&#123;\n\t\t\tpModeMenu = &amp;DL_ZX_Review[STG_MENU_DL_ZX_REVIEW_MAIN];\n\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RECOVER;\n\t\t\t\t \n\t\t&#125;else if(keys == KEY6_CLICK_RELEASE)\n\t\t&#123;\n\t\t\ttimer = 0;\n\t\t\t//更新探测器属性，带写入EEPROM功能\n\t\t\tSetDtcAbt(tStuDtc.ID-1,&amp;tStuDtc);\t\t\n\t\t\teditComplete = 1;\n\t\t\thal_Oled_Clear();\n\t\t\thal_Oled_ShowString(16,20,\"UPDATE..\",24,1);\n\t\t\thal_Oled_Refresh();\t \n\t\t&#125;else if(keys == KEY5_LONG_PRESS)\n\t\t&#123;\n\t\t\tpModeMenu = &amp;generalModeMenu[GNL_MENU_DESKTOP];\n\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RESET;\n\t\t&#125;\n\t&#125;\n\tif(editComplete)\n\t&#123;\n\t\ttimer++;\n\t\tif(timer > 150)\t\t//1.5秒自动退出\n\t\t&#123;\n\t\t\ttimer = 0;\n\t\t\teditComplete = 0;\n\t\t\tpModeMenu = &amp;DL_ZX_Review[STG_MENU_DL_ZX_REVIEW_MAIN];\n\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RECOVER;\n\t\t&#125;\n\t&#125;\n&#125;\n\n探测器删除\n\n\n\n\n\n\n\n\n\n//探测器删除\nstatic void stgMenu_dl_DeleteCBS(void)\n&#123;\n\tunsigned char keys = 0xFF;\n\tstatic Stu_DTC tStuDtc;\n\tstatic unsigned short timer = 0;\n\tstatic unsigned char DelComplete = 0;\n\tstatic unsigned char stgMainMenuSelectedPos=0;\n\tif(pModeMenu->refreshScreenCmd == SCREEN_CMD_RESET)\n\t&#123;\t//执行页面切换时屏幕刷新显示 \n\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_NULL;\n\t\tstgMainMenuSelectedPos = 0; \n\t\tif(CheckPresenceofDtc(pModeMenu->reserved))\n\t\t&#123;\n\t\t\tGetDtcStu(&amp;tStuDtc,pModeMenu->reserved);\n\t\t&#125;\n\t\tstgMainMenuSelectedPos = 0;\n\t\thal_Oled_Clear();\n\t\thal_Oled_ShowString(46,0,pModeMenu->pModeType,12,1);\n\t\t//del zone-001\n\t\thal_Oled_ShowString(28,14,\"Del \",12,1); \n\t\thal_Oled_ShowString(52,14,tStuDtc.Name,12,1); \n\t\thal_Oled_ShowString(25,28,\"Are you sure?\",12,1); \n\t\t//yes   no\n\t\thal_Oled_ShowString(40,48,\"Yes\",12,1); \n\t\thal_Oled_ShowString(88,48,\"No\",12,0); \n\t\thal_Oled_Refresh();\n\t\tDelComplete = 0;\n\t\ttimer = 0;\n\t&#125;\n\tif(pModeMenu->keyVal != 0xff)\n\t&#123;\n\t\tkeys = pModeMenu->keyVal;\n\t\tpModeMenu->keyVal = 0xFF;\t//恢复菜单按键值\n\t\tif((keys == KEY3_CLICK_RELEASE) || (keys == KEY4_CLICK_RELEASE))\n\t\t&#123;\n\t\t\tif(stgMainMenuSelectedPos == 0)\t\t\n\t\t\t&#123;\n\t\t\t\tstgMainMenuSelectedPos = 1;\n\t\t\t\thal_Oled_ClearArea(40,48,88,16);\t\t//清屏\n\t\t\t\thal_Oled_ShowString(40,48,\"Yes\",12,0); \n\t\t\t\thal_Oled_ShowString(88,48,\"No\",12,1); \n\t\t\t\thal_Oled_Refresh();\n\t\t\t&#125;else if(stgMainMenuSelectedPos == 1)\n\t\t\t&#123;\n\t\t\t\tstgMainMenuSelectedPos = 0;\n\t\t\t\thal_Oled_ClearArea(40,48,88,16);\t\t//清屏\n\t\t\t\thal_Oled_ShowString(40,48,\"Yes\",12,1); \n\t\t\t\thal_Oled_ShowString(88,48,\"No\",12,0); \n\t\t\t\thal_Oled_Refresh();\n\t\t\t&#125;\n\t\t&#125;else if(keys == KEY6_CLICK_RELEASE)\n\t\t&#123;\n\t\t\tif(stgMainMenuSelectedPos)\n\t\t\t&#123;\n\t\t\t\t//确认删除\n\t\t\t\tDelComplete = 1;\n\t\t\t\ttimer = 0;\n\t\t\t\ttStuDtc.Mark = 0;\n\t\t\t\tSetDtcAbt(tStuDtc.ID-1,&amp;tStuDtc);\t\t//更新探测器属性，带写入EEPROM功能\n\t\t\t\t\n\t\t\t\thal_Oled_Clear();\n\t\t\t\thal_Oled_ShowString(16,20,\"Update..\",24,1);\n\t\t\t\thal_Oled_Refresh();\t\n\t\t\t&#125;else\n\t\t\t&#123;\n\t\t\t\tpModeMenu = pModeMenu->pParent;\n\t\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RECOVER; \n\t\t\t&#125;\n\t\t&#125;else if(keys == KEY5_CLICK_RELEASE)\n\t\t&#123;\n\t\t\tpModeMenu = &amp;DL_ZX_Review[STG_MENU_DL_ZX_REVIEW_MAIN];\n\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RECOVER;\n\t\t&#125;else if(keys == KEY5_LONG_PRESS)\n\t\t&#123;\n\t\t\tpModeMenu = &amp;generalModeMenu[GNL_MENU_DESKTOP];;\n\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RESET;\n\t\t&#125;\n\t&#125;\n\tif(DelComplete)\n\t&#123;\n\t\ttimer++;\n\t\tif(timer > 150)\t\t//1.5秒自动退出\n\t\t&#123;\n\t\t\ttimer = 0;\n\t\t\tDelComplete = 0;\n\t\t\tpModeMenu = &amp;settingModeMenu[STG_MENU_DTC_LIST];\n\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RESET;\n\t\t&#125;\n\t&#125;\n&#125;\n\n\nSTM32驱动OLED实现Wifi配网子菜单wifi配网菜单处理函数\n\n\n\n\n\n\n\n\n\n//wifi配网菜单处理函数\nstatic void stgMenu_WifiCBS(void)\n&#123;\n\tstatic uint8_t stgMainMenuSelectedPos = 0;\n\tstatic uint16_t timer = 0;\n\tuint8_t keys;\n\tif(pModeMenu->refreshScreenCmd == SCREEN_CMD_RESET)\n\t&#123;\n\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_NULL;\t\n\t\thal_Oled_Clear();\t \n\t\thal_Oled_ShowString(52,0,\"Wifi\",12,1);\t\t \n\t\thal_Oled_ShowString(0,20,\"Are you sure to\",8,1); \n\t\thal_Oled_ShowString(0,30,\"enter ap mode?\",8,1);\t\t\n\t\t//yes   no\n\t\thal_Oled_ShowString(40,48,\"Yes\",12,1); \n\t\thal_Oled_ShowString(88,48,\"No\",12,0); \t\t\n\t\thal_Oled_Refresh();\t\t\n\t\tkeys = 0xFF;\n\t\ttimer = 0;\n\t\tstgMainMenuSelectedPos = 0;\n\t&#125;\t\n\tif(pModeMenu->keyVal != 0xff)\n\t&#123;\n\t\tkeys = pModeMenu->keyVal;\n\t\tpModeMenu->keyVal = 0xFF;\t//恢复菜单按键值\t\t\n\t\tif((keys == KEY3_CLICK_RELEASE) || (keys == KEY4_CLICK_RELEASE))\n\t\t&#123;\n\t\t\tif(stgMainMenuSelectedPos == 0)\t\t\n\t\t\t&#123;\n\t\t\t\tstgMainMenuSelectedPos = 1;\n\t\t\t\thal_Oled_ClearArea(40,48,88,16);\t\t//清屏\n\t\t\t\thal_Oled_ShowString(40,48,\"Yes\",12,0); \n\t\t\t\thal_Oled_ShowString(88,48,\"No\",12,1); \n\t\t\t\thal_Oled_Refresh();\n\t\t\t&#125;else if(stgMainMenuSelectedPos == 1)\n\t\t\t&#123;\n\t\t\t\tstgMainMenuSelectedPos = 0;\n\t\t\t\thal_Oled_ClearArea(40,48,88,16);\t\t//清屏\n\t\t\t\thal_Oled_ShowString(40,48,\"Yes\",12,1); \n\t\t\t\thal_Oled_ShowString(88,48,\"No\",12,0); \n\t\t\t\thal_Oled_Refresh(); \n\t\t\t&#125;\n\t\t&#125;else if(keys == KEY5_CLICK_RELEASE)\n\t\t&#123;\n\t\t\tpModeMenu = pModeMenu->pParent;\n\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RECOVER;\n\t\t&#125;else if(keys == KEY5_LONG_PRESS)\n\t\t&#123;\n\t\t\tpModeMenu = &amp;generalModeMenu[GNL_MENU_DESKTOP];;\n\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RESET;\n\t\t&#125;\t\t \n\t&#125;\n&#125;\n\nSTM32驱动OLED实现设备信息子菜单功能设备信息菜单处理函数\n\n\n\n\n\n\n\n\n设备信息子菜单的作用\n看程序版本号\n 看硬件版本号\n方便后期对产品的维护，比如说产品出问题了，我们可以通过硬件和程序版本号来定位批次。 \n还有就是有些产品是可以在线升级的，升级以后通过程序版本号来看有没有升级成功\n\n//设备信息菜单处理函数\nstatic void stgMenu_MachineInfoCBS(void)\n&#123;\n\tuint8_t keys; \n\tif(pModeMenu->refreshScreenCmd == SCREEN_CMD_RESET)\n\t&#123;\n\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_NULL;\n\t\n\t\thal_Oled_Clear();\t //mac info\n\t\thal_Oled_ShowString(40,0,\"Mac info\",12,1);\t\n\t\thal_Oled_ShowString(0,16,\"&lt;mcu ver>: \",12,1);\n\t\thal_Oled_ShowString(66,16,pMcuVersions,12,1);\t\t\n\t\thal_Oled_ShowString(0,32,\"&lt;hard ver>: \",12,1);\n\t\thal_Oled_ShowString(72,32,pHardVersions,12,1);\n\t\thal_Oled_Refresh();\t\t\n\t\tkeys = 0xFF;\t\t \n\t&#125;\t\n\tif(pModeMenu->keyVal != 0xff)\n\t&#123;\n\t\tkeys = pModeMenu->keyVal;\n\t\tpModeMenu->keyVal = 0xFF;\t//恢复菜单按键值\n\t\tif(keys == KEY5_CLICK_RELEASE)\n\t\t&#123;\n\t\t\tpModeMenu = pModeMenu->pParent;\n\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RECOVER;\n\t\t&#125;else if(keys == KEY5_LONG_PRESS)\n\t\t&#123;\n\t\t\tpModeMenu = &amp;generalModeMenu[GNL_MENU_DESKTOP];\n\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RESET;\n\t\t&#125;\n\t&#125;\n&#125;\n\nSTM32驱动OLED实现恢复出厂设置子菜单功能恢复出厂设置菜单处理函数\n\n\n\n\n\n\n\n\n\n//恢复出厂设置菜单处理函数\nstatic void stgMenu_FactorySettingsCBS(void)\n&#123;\n\tuint8_t keys = 0xFF;\n\tstatic uint16_t timer = 0;\n\tstatic uint8_t Complete = 0;\t\n\tstatic uint8_t stgMainMenuSelectedPos=0;\n\tif(pModeMenu->refreshScreenCmd == SCREEN_CMD_RESET)\n\t&#123;\t//执行页面切换时屏幕刷新显示 \n\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_NULL;\n\t\tstgMainMenuSelectedPos = 0; \t\n\t\thal_Oled_Clear();\n\t\thal_Oled_ShowString(19,0,\"Default setting\",12,1);\t\t\n\t\thal_Oled_ShowString(25,28,\"Are you sure?\",12,1); \n\t\t//yes   no\n\t\thal_Oled_ShowString(40,48,\"Yes\",12,1); \n\t\thal_Oled_ShowString(88,48,\"No\",12,0); \t\t\n\t\thal_Oled_Refresh();\t\t \n\t\tComplete = 0;\n\t\ttimer = 0;\n\t&#125;\t\n\tif(pModeMenu->keyVal != 0xff)\n\t&#123;\n\t\tkeys = pModeMenu->keyVal;\n\t\tpModeMenu->keyVal = 0xFF;\t//恢复菜单按键值\n\t\tif(!Complete)\n\t\t&#123;\n\t\t\tif((keys == KEY3_CLICK_RELEASE) || (keys == KEY4_CLICK_RELEASE))\n\t\t\t&#123;\n\t\t\t\tif(stgMainMenuSelectedPos == 0)\t\t\n\t\t\t\t&#123;\n\t\t\t\t\tstgMainMenuSelectedPos = 1;\n\t\t\t\t\thal_Oled_ClearArea(40,48,88,16);\t\t//清屏\n\t\t\t\t\thal_Oled_ShowString(40,48,\"Yes\",12,0); \n\t\t\t\t\thal_Oled_ShowString(88,48,\"No\",12,1); \n\t\t\t\t\thal_Oled_Refresh();\n\t\t\t\t&#125;else if(stgMainMenuSelectedPos == 1)\n\t\t\t\t&#123;\n\t\t\t\t\tstgMainMenuSelectedPos = 0;\n\t\t\t\t\thal_Oled_ClearArea(40,48,88,16);\t\t//清屏\n\t\t\t\t\thal_Oled_ShowString(40,48,\"Yes\",12,1); \n\t\t\t\t\thal_Oled_ShowString(88,48,\"No\",12,0); \n\t\t\t\t\thal_Oled_Refresh();\n\t \n\t\t\t\t&#125;\n\t\t\t&#125;else if(keys == KEY6_CLICK_RELEASE)\n\t\t\t&#123;\n\t\t\t\tif(stgMainMenuSelectedPos)\n\t\t\t\t&#123;\n\t\t\t\t\t//确认 \n\t\t\t\t\tComplete = 1;\n\t\t\t\t\ttimer = 0;\n\t\t\t\t\tFactoryReset();\t\t//调用复位EEPROM数据函数\n\t\t\t\t\thal_Oled_Clear();\n\t\t\t\t\thal_Oled_ShowString(16,20,\"Update..\",24,1);\n\t\t\t\t\thal_Oled_Refresh();\t\n\t\t\t\t&#125;else\n\t\t\t\t&#123;\n\t\t\t\t\tpModeMenu = pModeMenu->pParent;\n\t\t\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RECOVER; \n\t\t\t\t&#125;\n\t\t\t&#125;else if(keys == KEY5_CLICK_RELEASE)\n\t\t\t&#123;\n\t\t\t\tpModeMenu = pModeMenu->pParent;\n\t\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RECOVER; \n\t\t\t&#125;else if(keys == KEY5_LONG_PRESS)\n\t\t\t&#123;\n\t\t\t\tpModeMenu = &amp;generalModeMenu[GNL_MENU_DESKTOP];;\n\t\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RESET;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\tif(Complete)\n\t&#123;\n\t\ttimer++;\n\t\tif(timer > 150)\t\t//1.5秒自动退出\n\t\t&#123;\n\t\t\ttimer = 0;\n\t\t\tComplete = 0;\n\t\t\tpModeMenu = pModeMenu->pParent;\n\t\t\tpModeMenu->refreshScreenCmd = SCREEN_CMD_RECOVER;\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n\n\n\n\n\n二级标题三级标题四级标题五级标题六级标题","slug":"wifi主机/wifi主机第十部分  UI设计师","date":"2020-08-15T10:49:36.000Z","categories_index":"单片机","tags_index":"STM32,主机","author_index":"虫子"},{"id":"6cb2617339080555db592d1de52b021d","title":"WIFI主机-精确打击","content":"WIFI主机按键检测\n\n\n\n\n\n\n\n\n到了这里了我们用的肯定是高级的按键写法，那些低端的代码我们可以抛弃了\n但是一些原理还是要讲讲的，大多数按键都是物理开关，当机械开关触点闭合、断开的时候不会马上就会接通或者断开，而是断断续续高平的闭合、断开，最后才稳定下来。\n\n上图是一个按键按下的波形图，假设按键按下是连接着GND，那按下就是低电平。按下瞬间会有T1个周期时间是电平不稳定的状态，松开的时候会有T2个周期时间是电平不稳定状态。这个不稳定的状态就叫抖动。\n那我们消抖其实就是通过软件延时，把T1和T2这个时间过滤掉，一般是各延时10ms就行了。当然也有硬件消抖，通过电容来进行交通直隔来消抖，但是加大了硬件成本不可取。\n\n首先这种垃圾代码就不要写了，没有意思，但是很多高校比较喜欢这种写法，且是那种屡试不爽的那种，我们是要面向产品的，所以我们用工程级别的写法\n多按键多功能检测代码实战\n\n\n\n\n\n\n\n\n\n编写按键对应的gpio初始化程序。\n编写读取每个按键IO口状态程序。\n编写多按键检测功能代码。\n解决程序可移植性\n\n根据模块化编程的思维，按键检测属于硬件层的一个驱动，属于一种信号输入到单片机，我们硬件层驱动程序处理好信号，确定是一个有效按键按下信号后，把这个按键的值(短按、短按释放、长按、长按释放)传递给应用层，就是我们的产品功能程序。\n传递的方式有很多种，比如说最简单粗暴的就是用全局变量，分别在不同的.c文件判断，这种可移植性极差。\n那这里其实就可以用我们的回调函数了,xdm回调函数屡试不爽，大家也看到了我非常喜欢回调函数\nKEY_GPIO_Config  按键GPIO配置\n\n\n\n\n\n\n\n\n由于按键1-6基本一样，一样的部分就不放图了\n\nstatic void KEY_GPIO_Config(void)\n&#123;\n\tGPIO_InitTypeDef  GPIO_InitStruct;\n\t//先开时钟,按键都在GPIOB口上，复用口时钟也开起来\n\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB|RCC_APB2Periph_AFIO, ENABLE);\n\t//再更改指定管脚的映射\n\tGPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable,ENABLE);\n\t\n\t//键1\n\tGPIO_InitStruct.GPIO_Pin = KEY1_GPIO_PIN;\n    //模式配置成上拉\n\tGPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;\n\t//然后初始化，把结构体里面的成员加载到寄存器里面\n\tGPIO_Init(KEY1_GPIO_PORT, &amp;GPIO_InitStruct);\t\n\t\n\t//键2\n\tGPIO_InitStruct.GPIO_Pin = KEY2_GPIO_PIN;\n    //模式配置成上拉\n\tGPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;\n\t//然后初始化，把结构体里面的成员加载到寄存器里面\n\tGPIO_Init(KEY2_GPIO_PORT, &amp;GPIO_InitStruct);\t\n\t\n\t//键3\n\tGPIO_InitStruct.GPIO_Pin = KEY3_GPIO_PIN;\n    //模式配置成上拉\n\tGPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;\n\t//然后初始化，把结构体里面的成员加载到寄存器里面\n\tGPIO_Init(KEY3_GPIO_PORT, &amp;GPIO_InitStruct);\t\n\t\n\t//键4\n\tGPIO_InitStruct.GPIO_Pin = KEY4_GPIO_PIN;\n    //模式配置成上拉\n\tGPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;\n\t//然后初始化，把结构体里面的成员加载到寄存器里面\n\tGPIO_Init(KEY4_GPIO_PORT, &amp;GPIO_InitStruct);\t\n\t\n\t//键5\n\tGPIO_InitStruct.GPIO_Pin = KEY5_GPIO_PIN;\n    //模式配置成上拉\n\tGPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;\n\t//然后初始化，把结构体里面的成员加载到寄存器里面\n\tGPIO_Init(KEY5_GPIO_PORT, &amp;GPIO_InitStruct);\t\n\t\n\t//键6\n\tGPIO_InitStruct.GPIO_Pin = KEY6_GPIO_PIN;\n    //模式配置成上拉\n\tGPIO_InitStruct.GPIO_Mode = GPIO_Mode_IPU;\n\t//然后初始化，把结构体里面的成员加载到寄存器里面\n\tGPIO_Init(KEY6_GPIO_PORT, &amp;GPIO_InitStruct);\t\n&#125;\n\n读取每个按键IO口状态\n\n\n\n\n\n\n\n\n\n//得到键1状态\nstatic uint8_t hal_getKey1Sta()\n&#123;\n\t//实际上按键按下是接地的也就是得到的是0，但是为了符合习惯我们取反表示按下为1\n\treturn (!GPIO_ReadInputDataBit(KEY1_GPIO_PORT,KEY1_GPIO_PIN));\n&#125;\n//得到键2状态\nstatic uint8_t hal_getKey2Sta()\n&#123;\n\t//实际上按键按下是接地的也就是得到的是0，但是为了符合习惯我们取反表示按下为1\n\treturn (!GPIO_ReadInputDataBit(KEY2_GPIO_PORT,KEY2_GPIO_PIN));\n&#125;\n//得到键3状态\nstatic uint8_t hal_getKey3Sta()\n&#123;\n\t//实际上按键按下是接地的也就是得到的是0，但是为了符合习惯我们取反表示按下为1\n\treturn (!GPIO_ReadInputDataBit(KEY3_GPIO_PORT,KEY3_GPIO_PIN));\n&#125;\n//得到键4状态\nstatic uint8_t hal_getKey4Sta()\n&#123;\n\t//实际上按键按下是接地的也就是得到的是0，但是为了符合习惯我们取反表示按下为1\n\treturn (!GPIO_ReadInputDataBit(KEY4_GPIO_PORT,KEY4_GPIO_PIN));\n&#125;\n//得到键5状态\nstatic uint8_t hal_getKey5Sta()\n&#123;\n\t//实际上按键按下是接地的也就是得到的是0，但是为了符合习惯我们取反表示按下为1\n\treturn (!GPIO_ReadInputDataBit(KEY5_GPIO_PORT,KEY5_GPIO_PIN));\n&#125;\n//得到键6状态\nstatic uint8_t hal_getKey6Sta()\n&#123;\n\t//实际上按键按下是接地的也就是得到的是0，但是为了符合习惯我们取反表示按下为1\n\treturn (!GPIO_ReadInputDataBit(KEY6_GPIO_PORT,KEY6_GPIO_PIN));\n&#125;\n\n按键任务函数\n\n\n\n\n\n\n\n\n\n//按键任务函数\nvoid hal_KeyProc(void)\n&#123;\n\tunsigned char i,KeyState[KEY_SUM];\n\tfor(i=0; i&lt;KEY_SUM; i++)\n\t&#123;\t\n\t\tkeys = 0; \n \n\t\tKeyState[i] = getKeysState[i]();\n\t\tswitch(KeyStep[i])\n\t\t&#123;\n\t\t\tcase KEY_STEP_WAIT:\t\t//等待按键\n\t\t\t\tif(KeyState[i])\n\t\t\t\t&#123;\n\t\t\t\t\tKeyStep[i] = KEY_STEP_CLICK;\t\n\t\t\t\t&#125;\n\t\t\tbreak;\n\t\t\tcase KEY_STEP_CLICK:\t\t\t\t//按键单击按下\n\t\t\t\tif(KeyState[i])\n\t\t\t\t&#123;\n\t\t\t\t\tif(!(--KeyScanTime[i]))\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tKeyScanTime[i] = KEY_SCANTIME;\n\t\t\t\t\t\tKeyStep[i] = KEY_STEP_LONG_PRESS;\n\t\t\t\t\t\t//keys = i+1;\t\t\t\t\t\t\t\t\t\t//记录按键ID号\n\t\t\t\t\t\t//state = KEY_CLICK;\t\t\t\t\t\t\t\t//按键单击按下\n\t\t\t\t\t\tkeys = (i*5)+1;\t\t\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;else\n\t\t\t\t&#123;\n\t\t\t\t\tKeyScanTime[i] = KEY_SCANTIME;\n\t\t\t\t\tKeyStep[i] = KEY_STEP_WAIT;\n\t\t\t\t&#125;\n\t\t\tbreak;\n\t\t\tcase KEY_STEP_LONG_PRESS:\t\t\t//按键长按\n\t\t\t\tif(KeyState[i])\n\t\t\t\t&#123;\t\n\t\t\t\t\tif(!(--KeyPressLongTimer[i]))\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tKeyPressLongTimer[i] = KEY_PRESS_LONG_TIME;\n\t\t\t\t\t\tKeyStep[i] = KEY_STEP_CONTINUOUS_PRESS;\n\t\t\t\t\t\tkeys = (i*5)+3;\t\t\t\t\t\t\t\t//长按确认\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;else\n\t\t\t\t&#123;\n\t\t\t\t\tKeyPressLongTimer[i] = KEY_PRESS_LONG_TIME;\n\t\t\t\t\tKeyStep[i] = KEY_STEP_WAIT;\n\t\t\t\t\tkeys = (i*5)+2;\t\t\t\t\t\t\t\t\t\t//单击释放\n\t\t\t\t&#125;\n\t\t\tbreak;\n\t\t\tcase KEY_STEP_CONTINUOUS_PRESS:\n\t\t\t\tif(KeyState[i])\n\t\t\t\t&#123;\n\t\t\t\t\tif(!(--KeyContPressTimer[i]))\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tKeyContPressTimer[i] = KEY_PRESS_CONTINUE_TIME;\n\t\t\t\t\t\tkeys = (i*5)+4;\t\t\t\t\t//持续长按\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;else\n\t\t\t\t&#123;\n\t\t\t\t\tKeyStep[i] = KEY_STEP_WAIT;\n\t\t\t\t\tKeyContPressTimer[i] = KEY_PRESS_CONTINUE_TIME;\n\t\t\t\t\tkeys = (i*5)+5;\t\t\t\t\t\t\t\t//长按释放\n\t\t\t\t&#125;\n\t\t\tbreak;\n\t\t&#125;\n\t\tif(keys)\n\t\t&#123;\n\t\t\tif(KeyScanCBS)\n\t\t\t&#123;\t \n\t\t\t\tKeyScanCBS((KEY_VALUE_TYPEDEF)keys);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\n按键扫描回调注册函数\n\n\n\n\n\n\n\n\n\n/********************************************************************************************************\n*  @函数名   hal_KeyScanCBSRegister\t\t\t\t\t                                                           \n*  @描述     按键扫描回调注册函数\t\t\t\t\t\t\t\t                                     \n*  @参数     pCBS-应用层的函数指针，让我们的按键扫描函数指针指向应用层，就可以执行应用层代码实现应用层和硬件层的分离\n*  @返回值   无   \n*  @注意        无\n********************************************************************************************************/\nvoid hal_KeyScanCBSRegister(KeyEvent_CallBack_t pCBS)\n&#123;\n\tif(KeyScanCBS == 0)\n\t&#123;\n\t\t\tKeyScanCBS = pCBS;\n\t&#125;\n&#125;\n\n按键初始化函数\n\n\n\n\n\n\n\n\n\nvoid hal_KeyInit(void)\n&#123;\n\tunsigned char i;\n\tKeyScanCBS = 0;\n\thal_keyConfig();\n \n\tfor(i=0; i&lt;KEYNUM; i++)\n\t&#123;\n\t\tKeyStep[i] = KEY_STEP_WAIT;\n\t\tKeyScanTime[i] = KEY_SCANTIME;\n\t\tKeyPressLongTimer[i] = KEY_PRESS_LONG_TIME;\n\t\tKeyContPressTimer[i] = KEY_PRESS_CONTINUE_TIME;\n\t&#125;\n&#125;\n\nApp应用层代码\n\n\n\n\n\n\n\n\n\nvoid AppInit(void)\n&#123;\n\thal_KeyScanCBSRegister(KeyEventHandle);\n&#125;\n//按键回调函数\nstatic void KeyEventHandle(KEY_VALUE_TYPEDEF keys)\n&#123;\n\t\n\t \n\tif((keys==KEY1_CLICK)\n\t|| (keys==KEY2_CLICK)\n\t|| (keys==KEY3_CLICK)\n\t|| (keys==KEY4_CLICK)\n\t|| (keys==KEY5_CLICK)\n\t|| (keys==KEY6_CLICK))\n\t&#123;\n\t\tLedMsgInput(LED1,LED_LIGHT,1);\n\t&#125;else if((keys==KEY1_CLICK_RELEASE)\n\t|| (keys==KEY2_CLICK_RELEASE)\n\t|| (keys==KEY3_CLICK_RELEASE)\n\t|| (keys==KEY4_CLICK_RELEASE)\n\t|| (keys==KEY5_CLICK_RELEASE)\n\t|| (keys==KEY6_CLICK_RELEASE))\n\t&#123;\n\t\tLedMsgInput(LED1,LED_BLINK4,1);\n\t&#125;else if((keys==KEY1_LONG_PRESS)\n\t|| (keys==KEY2_LONG_PRESS)\n\t|| (keys==KEY3_LONG_PRESS)\n\t|| (keys==KEY4_LONG_PRESS)\n\t|| (keys==KEY5_LONG_PRESS)\n\t|| (keys==KEY6_LONG_PRESS))\n\t&#123;\n\t\tLedMsgInput(LED1,LED_DARK,1);\n\t&#125;\n&#125;\n\n思路\n\n\n\n\n\n\n\n\n\nSPI驱动OLEDOLED模块简介\n\n\n\n\n\n\n\n\nOLED，即有机发光二极管（Organic Light-Emitting Diode），又称为有机电激光显示（OrganicElectroluminesence Display， OELD）。 OLED 由于同时具备自发光，不需背光源、对比度高、厚度薄、视角广、反应速度快、可用于挠曲性面板、使用温度范围广、构造及制程较简单等优异之特性，被认为是下一代的平面显示器新兴应用技术。\n模块特点\n\n没有背光，需要通过写入指令来开启显示\n尺寸小：0.96寸，分辨率高：128*64\n提供多种通信接口：6800、8080、3线&#x2F;4线SPI、IIC\n供电3.3V\n驱动芯片：SSD1306\n\n\n引脚定义：我们使用的OLED模组是3线SPI通讯方式\n\n\n\n\n\n\n\n\n\nSSD1306驱动显示原理\n\n\n\n\n\n\n\n\n在OLED上显示图像，图像的数据就存储在显存GRAM中，SSD1306的分辨率是128*64像素点，简单理解就是128*64个LED灯，有128行(x轴)，64(y轴)列组成的LED矩阵。\n\n如图，OLED12864 由&#x3D;&#x3D;128 列 *64行&#x3D;&#x3D;组成。&#x3D;&#x3D;D0D7 这8行是一个字节的 PAGE 单元&#x3D;&#x3D; ，也就是把 COM0COM 64行划分成 8 个页单元PAGE0PAGE7 。&#x3D;&#x3D;写入的数据不能按位操作&#x3D;&#x3D;，只能&#x3D;&#x3D;D0D7 这8个点一个字节写入&#x3D;&#x3D;，每个 PAGE  是128个SEG 列\n我们把16个 SEG 作为一个 SEG16单元格 。整个面板就是&#x3D;&#x3D;8个PAGE和8个SEG16&#x3D;&#x3D;划分出来的&#x3D;&#x3D;64个单元格&#x3D;&#x3D;。上下两个单元格就是16*16  点，能够显示一个汉字 、两个大号英文、四个小号英文\n\n我们框架式编程方式，不是直接发送图像 。先把图像暂时保存在单片机的外部RAM 空间，单片机空闲的时候， 再把 外部 RAM  里面的图像 ，通过 IIC  协议 发送到 SSD1306  芯片的 GDDRAM  里面。SSD1306芯片自动完成循环扫描，把GDDRAM  里面的 图像投影到玻璃面板 LED 阵列。通过修改 SSD1306  循环扫描的顺序，就可以&#x3D;&#x3D;左右镜面 、上下镜面 、 隔行扫描、 逐行扫描、逐列扫描、反白显示 等多种方式灵活使用。&#x3D;&#x3D; 我们开发板就是需要 OLED  显示位置旋转  180 °\nOLED图像显示位置的寻址寄存器\n\n\n\n\n\n\n\n\n\nOLED的硬件配置寄存器\n\n\n\n\n\n\n\n\n\n上面是之前的文章上面的\n\n\n\n\n\n\n\n\n\n每个LED对应显存GRAM中的一位，那用二维数组来表示这个显存就是&#x3D;&#x3D;GRAM[128][8]&#x3D;&#x3D;；\n为什么是GRAM[128][8]而不是GRAM[128][64]？\n因为行(即x轴)公共端(分阴极和阳极，跟数码管类似)，而列(即y轴)是数据端，LED灯只需要0或者1就可以代表亮和灭，所以为了节约内存，直接用一个Bit来表示灯的状态即可，所以用8个字节就能表示列的64个Bit。\n&#x3D;&#x3D;那怎么显示一个图片或者字符呢？&#x3D;&#x3D;\n原理就是同时控制不同的灯点亮形成一个图案或者字符。\n这个就需要用到取模软件，把整个字符或者图片导入进去，然后帮你生成对应的数组形式的数据，这样就能很方便地在OLED上显示你要的东西了。\n软件和取模教程OLED厂家都有提供。\nOLED的扫描方式：\n我们前面说把0x04写入到GRAM[0][0]位置的显存里就能点亮坐标x&#x3D;0，y&#x3D;3那个灯。\n那这个0x04数据是怎么来的呢？这个跟取模走向有关，我们取模走向是逆向，就是低位在前，高位在后，从左到右，从上到下的方式(用软件演示)\n\nSPI通讯原理及模式选择\n\n\n\n\n\n\n\n\n起源\nSPI是由摩托罗拉公司提出的通讯协议，用于两个设备之间的&#x3D;&#x3D;高速全双工&#x3D;&#x3D;数据传输。它被广泛地使用在ADC、LCD等设备与MCU间，要求通讯速率较高的场合。&#x3D;&#x3D;全双工&#x3D;&#x3D;的意思就是在&#x3D;&#x3D;同时可以进行数据写和数据读&#x3D;&#x3D;的操作，因为读和写是单独的两根线嘛。\n通讯引脚\n&#x3D;&#x3D;MOSI&#x3D;&#x3D;：Master Output Slave Input，顾名思义，即主设备输出&#x2F;从设备输入。数据从主机输出到从机，主机是主设备输出\n&#x3D;&#x3D;MISO&#x3D;&#x3D;：Master Iutput Slave Onput，主设备输入&#x2F;从设备输出，数据由从机输出到主机，主机接收数据。\n&#x3D;&#x3D;SCK&#x3D;&#x3D;：即时钟信号线，用于通讯同步。该信号由主机产生，其支持的最高通讯速率为fpclk&#x2F;2，即所挂载总线速率的一半。如SPI2挂载在APB1总线上，则其最高速率为36MHz &#x2F; 2 &#x3D; 18MHz。两个设备之间通讯时，通讯速率受限于较低速的设备。\n&#x3D;&#x3D;NSS&#x3D;&#x3D;：即片选信号线，用于选择通讯的从设备，也可用CS表示。每个从设备都有一条独立的NSS信号线，主机通过将某个设备的NSS线置低电平来选择与之通讯的从设备。所以SPI通讯以NSS线电平置&#x3D;&#x3D;低为起始信号&#x3D;&#x3D;，以NSS线电平被&#x3D;&#x3D;拉高为停止信号&#x3D;&#x3D;\nSPI物理层的特点\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n每个从设备都有独立的这一条SS信号线，本信号线独占主机的一个引脚，即有多少个从设备，就有多少条片选信号线。I2C协议中通过设备地址来寻址、选中总线上的某个设备并与其进行通讯；而SPI协议中没有设备地址，它使用SS信号线来寻址，当主机要选择从设备时，把该从设备的SS信号线设置为低电平，该从设备即被选中，即片选有效，接着主机开始与被选中的从设备进行SPI通讯。所以SPI通讯以SS线置低电平为开始信号，以SS线被拉高作为结束信号。\nstm32的spi有好几种\n\nSPI的协议层\n\n\n\n\n\n\n\n\nSPI协议定义了通讯的起始和停止信号、数据有效性、时钟同步等环节。\nSPI基本通讯过程\n\n\n\n\n\n\n\n\n\n\n标号处，NSS信号线由高变低，是SPI通讯的起始信号。NSS是每个从机各自独占的信号线，当从机检在自己的NSS线检测到起始信号后，就知道自己被主机选中了，开始准备与主机通讯。\n在图中的标号处，NSS信号由低变高，是SPI通讯的停止信号，表示本次通讯结束，从机的选中状态被取消\nSPI使用MOSI及MISO信号线来传输数据，使用SCK信号线进行数据同步。MOSI及MISO数据线在SCK的每个时钟周期传输一位数据，且数据输入输出是同时进行的\n\nCPOL&#x2F;CPHA 及通讯模式\n\n\n\n\n\n\n\n\n\n\n时钟极性CPOL是指SPI通讯设备处于空闲状态时，SCK信号线的电平信号(即SPI通讯开始前、 NSS线为高电平时SCK的状态)。CPOL&#x3D;0时， SCK在空闲状态时为低电平，CPOL&#x3D;1时，则相反\n时钟相位CPHA是指数据的采样的时刻，当CPHA=0时，MOSI或MISO数据线上的信号将会在SCK时钟线的“奇数边沿”被采样。当CPHA=1时，数据线在SCK的“偶数边沿”采样。\n\nCPOL&#x2F;CPHAA 及通讯模式\n\n\n\n\n\n\n\n\n由CPOL及CPHA的不同状态，SPI分成了四种模式，主机与从机需要工作在相同的模式下才可以正常通讯，实际中采用较多的是&#x3D;&#x3D;“模式0”与“模式3”&#x3D;&#x3D;\n\n\nSTM32的SPI特性及架构STM32的SPI外设简介\n\n\n\n\n\n\n\n\nSTM32的SPI外设可用作通讯的主机及从机，支持最高的SCK时钟频率为f pclk &#x2F;2 (STM32F10x型号的芯片默认f pclk1 为72MHz，f pclk2 为36MHz)，完全支持SPI协议的4种模式，数据帧长度可设置为8位或16位，可设置数据MSB先行或LSB先行。它还支持双线全双工(前面小节说明的都是这种模式)、双线单向以及单线模式。\nSTM32的SPI架构剖析\n\n\n\n\n\n\n\n\n\n一般情况下我们是不会选择硬件spi的，我们会用软件模拟spi信号\n时钟控制逻辑\n\n\n\n\n\n\n\n\nSCK线的时钟信号，由波特率发生器根据“控制寄存器CR1”中的BR[0:2]位控制，该位是对f pclk 时钟的分频因子，对f pclk 的分频结果就是SCK引脚的输出时钟频率\n\n数据控制逻辑\n\n\n\n\n\n\n\n\nSPI的MOSI及MISO都连接到数据移位寄存器上，数据移位寄存器的数据来源来源于接收缓冲区及发送缓冲区\n\n通过写SPI的“数据寄存器DR”把数据填充到发送缓冲区中。\n通过读“数据寄存器DR”，可以获取接收缓冲区中的内容。\n其中数据帧长度可以通过“控制寄存器CR1”的“DFF位”配置成8位及16位模式；配置“LSBFIRST位”可选择MSB先行还是LSB先行\n\n整体控制逻辑\n\n\n\n\n\n\n\n\n\n整体控制逻辑负责协调整个SPI外设，控制逻辑的工作模式根据“控制寄存器(CR1&#x2F;CR2)”的参数而改变，基本的控制参数包括前面提到的SPI模式、波特率、LSB先行、主从模式、单双向模式等等\n在外设工作时，控制逻辑会根据外设的工作状态修改“状态寄存器(SR)”，只要读取状态寄存器相关的寄存器位，就可以了解SPI的工作状态了。除此之外，控制逻辑还根据要求，负责控制产生SPI中断信号、DMA请求及控制NSS信号线。\n实际应用中，一般不使用STM32 SPI外设的标准NSS信号线，而是更简单地使用普通的GPIO，软件控制它的电平输出，从而产生通讯起始和停止信号。\n\n通讯过程\n\n\n\n\n\n\n\n\n\n\n控制NSS信号线，产生起始信号(图中没有画出)；\n把要发送的数据写入到“数据寄存器DR”中，该数据会被存储到发送缓冲区\n通讯开始，SCK时钟开始运行。MOSI把发送缓冲区中的数据一位一位地传输出去；MISO则把数据一位一位地存储进接收缓冲区中\n当发送完一帧数据的时候，“状态寄存器SR”中的“TXE标志位”会被置1，表示传输完一帧，发送缓冲区已空；类似地，当接收完一帧数据的时候，“RXNE标志位”会被置1，表示传输完一帧，接收缓冲区非空；\n等待到“TXE标志位”为1时，若还要继续发送数据，则再次往“数据寄存器DR”写入数据即可；等待到“RXNE标志位”为1时，通过读取“数据寄存器DR”可以获取接收缓冲区中的内容\n\n假如使能了TXE或RXNE中断，TXE或RXNE置1时会产生SPI中断信号，进入同一个中断服务函数，到SPI中断服务程序后，可通过检查寄存器位来了解是哪一个事件，再分别进行处理。也可以使用DMA方式来收发“数据寄存器DR”中的数据\nSPI初始化结构体详解\n\n\n\n\n\n\n\n\n跟其它外设一样，STM32标准库提供了SPI初始化结构体及初始化函数来配置SPI外设。初始化结构体及函数定义在库文件“stm32f10x_spi.h”及“stm32f10x_spi.c”中，编程时我们可以结合这两个文件内的注释使用或参考库帮助文档。\n\n配置完这些结构体成员后，要调用SPI_Init函数把这些参数写入到寄存器中，实现SPI的初始化，然后调用SPI_Cmd来使能SPI外设。\ntypedef struct\n&#123;\n  uint16_t SPI_Direction;              //设置spi的单双向模式 \n  uint16_t SPI_Mode;                   //设置spi的主/从机模式\n  uint16_t SPI_DataSize;               //设置spi的数据帧长度，可选8/16位\n  uint16_t SPI_CPOL;                   //设置时钟极性CPOL，可选高低电平\n  uint16_t SPI_CPHA;                   //设置时钟相位，可选奇/偶边沿采样\n  uint16_t SPI_NSS;                    //设置NSS引脚由spi是硬件控制还是软件控制\n  uint16_t SPI_BaudRatePrescaler;      //设置时钟分频因子，fpclk/分频数=fsck\n  uint16_t SPI_FirstBit;               // 设置MSB/LSB先行\n  uint16_t SPI_CRCPolynomial;          //设置CRC校验的表达式\n&#125;SPI_InitTypeDef;                      //spi初始化结构体\n\nOLED驱动移植\n\n\n\n\n\n\n\n\n这种屏驱动程序99.9%都不需要你写，大家后面如果有类似开发需要用到屏，直接找原厂要驱动源码就行了。自己写并不能学到很东西，同时浪费很多时间，简称走弯路。\n我们这个OLED模组原厂提供的是模拟SPI的驱动程序，只需要更改IO口就可以使用，然后我基于他们的程序把一些函数名改了下，前面增加了hal_增加程序可读性\n还增加了一个清屏指定区域的函数，核心的函数没去动他们的\n首先进行一波官方源码分析\n\n移植流程\n\n\n\n\n\n\n\n\n\n不需要自己重写OLED驱动函数，直接用我提供的（对原厂稍作优化）。\n熟悉STM32外设SPI的使用。\n学会看SPI通讯时序图，及4种模式。\n移植OLED驱动并成功显示任意字符\n\n以我们的风格改一下官方源码\n\n\n\n\n\n\n\n\n\n\n//oled配置\nstatic void hal_OledConfig(void)\n&#123;\n\t//创建两个结构体  spi和gpio的\n\tSPI_InitTypeDef  SPI_InitStructure;\n\tGPIO_InitTypeDef GPIO_InitStructure;\n\t\n\t//开三个时钟spi1，gpioa和复用口\n\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1\n\t                      |RCC_APB2Periph_GPIOA\n\t                      |RCC_APB2Periph_AFIO, ENABLE);\n\t//复用管脚重映射\n\tGPIO_PinRemapConfig(GPIO_Remap_SPI1, ENABLE);\n\t\n\t//配置spi1的结构体   sck时钟线，DO数据线就可以控制我们OLED了\n\tGPIO_InitStructure.GPIO_Pin =  OLED_SLK_PIN |OLED_DO_PIN;\n\tGPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n\t//复用推挽输出意味着是模拟spi\n\tGPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;\n\t//初始化把配置的成员加载进寄存器\n\tGPIO_Init(OLED_PORT, &amp;GPIO_InitStructure);\n\t\n\t//OLED复位引脚\n\tGPIO_InitStructure.GPIO_Pin = OLED_RES_PIN;\n\tGPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n\t//推挽输出，因为这边复位只需要把他拉低就行了，所以我们就用普通io功能，不需要AF\n\tGPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;\n\tGPIO_Init(OLED_PORT, &amp;GPIO_InitStructure);\n\t//先拉高\n\tGPIO_SetBits(OLED_PORT,OLED_RES_PIN);\n\t\n\t//OLED命令/数据控制引脚\n\tGPIO_InitStructure.GPIO_Pin = OLED_CMD_PIN;\n\tGPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\n\t//控制脚也用普通io方便控制\n\tGPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;\n\tGPIO_Init(OLED_PORT, &amp;GPIO_InitStructure);\n\tGPIO_SetBits(OLED_PORT,OLED_CMD_PIN);\n\t\n\t/* SPI1 configuration */ \n\t//只有DO数据线朝oled里面发送，不需要读\n\tSPI_InitStructure.SPI_Direction = SPI_Direction_1Line_Tx;            //SPI1设置为单线只发送\n\tSPI_InitStructure.SPI_Mode = SPI_Mode_Master;\t                     //设置SPI1为主模式  MCU主设备，oled从设备\n\tSPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;                    //SPI发送接收8位帧结构\n\tSPI_InitStructure.SPI_CPOL = SPI_CPOL_High;\t \t\t                 //串行时钟在不操作时，时钟为高电平\n\tSPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;\t\t                 //第二个时钟沿开始采样数据\n\tSPI_InitStructure.SPI_NSS = SPI_NSS_Soft;\t\t\t                 //NSS信号由软件（使用SSI位）管理，我们这是接地的，实时在线\n\tSPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_8;   //定义波特率预分频的值:波特率预分频值为8\n\tSPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;\t\t\t\t     //数据传输从MSB位开始\n\tSPI_InitStructure.SPI_CRCPolynomial = 7;\t\t\t\t\t\t     //CRC值计算的多项式\n\tSPI_Init(SPI1, &amp;SPI_InitStructure);\n\t//初始化把配置的成员加载进寄存器\n\tSPI_Cmd(SPI1, ENABLE); \t\t\t\t\t\t\t\t\t\t\t  //使能SPI1外设\n&#125;\n\noled端口定义\n\n\n\n\n\n\n\n\n\n//-----------------OLED端口定义---------------- \n\n#define OLED_SCL_Clr() GPIO_ResetBits(OLED_SLK_PORT,OLED_SLK_PIN)//SCL\n#define OLED_SCL_Set() GPIO_SetBits(OLED_SLK_PORT,OLED_SLK_PIN)\n\n#define OLED_SDA_Clr() GPIO_ResetBits(OLED_DO_PORT,OLED_DO_PIN)//SDA\n#define OLED_SDA_Set() GPIO_SetBits(OLED_DO_PORT,OLED_DO_PIN)\n\n#define OLED_RES_Clr() GPIO_ResetBits(OLED_RES_PORT,OLED_RES_PIN)//RES\n#define OLED_RES_Set() GPIO_SetBits(OLED_RES_PORT,OLED_RES_PIN)\n\n#define OLED_DC_Clr()  GPIO_ResetBits(OLED_CMD_PORT,OLED_CMD_PIN)//DC\n#define OLED_DC_Set()  GPIO_SetBits(OLED_CMD_PORT,OLED_CMD_PIN)\n/*片选接地了，所以源码这个屏蔽一下\t\t     \n#define OLED_CS_Clr()  GPIO_ResetBits(GPIOA,GPIO_Pin_4)//CS\n#define OLED_CS_Set()  GPIO_SetBits(GPIOA,GPIO_Pin_4)\n*/\n\n原厂字库const unsigned char asc2_0806[][6] =\n&#123;\n&#123;0x00, 0x00, 0x00, 0x00, 0x00, 0x00&#125;,// sp\n&#123;0x00, 0x00, 0x00, 0x2f, 0x00, 0x00&#125;,// !\n&#123;0x00, 0x00, 0x07, 0x00, 0x07, 0x00&#125;,// \"\n&#123;0x00, 0x14, 0x7f, 0x14, 0x7f, 0x14&#125;,// #\n&#123;0x00, 0x24, 0x2a, 0x7f, 0x2a, 0x12&#125;,// $\n&#123;0x00, 0x62, 0x64, 0x08, 0x13, 0x23&#125;,// %\n&#123;0x00, 0x36, 0x49, 0x55, 0x22, 0x50&#125;,// &amp;\n&#123;0x00, 0x00, 0x05, 0x03, 0x00, 0x00&#125;,// '\n&#123;0x00, 0x00, 0x1c, 0x22, 0x41, 0x00&#125;,// (\n&#123;0x00, 0x00, 0x41, 0x22, 0x1c, 0x00&#125;,// )\n&#123;0x00, 0x14, 0x08, 0x3E, 0x08, 0x14&#125;,// *\n&#123;0x00, 0x08, 0x08, 0x3E, 0x08, 0x08&#125;,// +\n&#123;0x00, 0x00, 0x00, 0xA0, 0x60, 0x00&#125;,// ,\n&#123;0x00, 0x08, 0x08, 0x08, 0x08, 0x08&#125;,// -\n&#123;0x00, 0x00, 0x60, 0x60, 0x00, 0x00&#125;,// .\n&#123;0x00, 0x20, 0x10, 0x08, 0x04, 0x02&#125;,// /\n&#123;0x00, 0x3E, 0x51, 0x49, 0x45, 0x3E&#125;,// 0\n&#123;0x00, 0x00, 0x42, 0x7F, 0x40, 0x00&#125;,// 1\n&#123;0x00, 0x42, 0x61, 0x51, 0x49, 0x46&#125;,// 2\n&#123;0x00, 0x21, 0x41, 0x45, 0x4B, 0x31&#125;,// 3\n&#123;0x00, 0x18, 0x14, 0x12, 0x7F, 0x10&#125;,// 4\n&#123;0x00, 0x27, 0x45, 0x45, 0x45, 0x39&#125;,// 5\n&#123;0x00, 0x3C, 0x4A, 0x49, 0x49, 0x30&#125;,// 6\n&#123;0x00, 0x01, 0x71, 0x09, 0x05, 0x03&#125;,// 7\n&#123;0x00, 0x36, 0x49, 0x49, 0x49, 0x36&#125;,// 8\n&#123;0x00, 0x06, 0x49, 0x49, 0x29, 0x1E&#125;,// 9\n&#123;0x00, 0x00, 0x36, 0x36, 0x00, 0x00&#125;,// :\n&#123;0x00, 0x00, 0x56, 0x36, 0x00, 0x00&#125;,// ;\n&#123;0x00, 0x08, 0x14, 0x22, 0x41, 0x00&#125;,// &lt;\n&#123;0x00, 0x14, 0x14, 0x14, 0x14, 0x14&#125;,// =\n&#123;0x00, 0x00, 0x41, 0x22, 0x14, 0x08&#125;,// >\n&#123;0x00, 0x02, 0x01, 0x51, 0x09, 0x06&#125;,// ?\n&#123;0x00, 0x32, 0x49, 0x59, 0x51, 0x3E&#125;,// @\n&#123;0x00, 0x7C, 0x12, 0x11, 0x12, 0x7C&#125;,// A\n&#123;0x00, 0x7F, 0x49, 0x49, 0x49, 0x36&#125;,// B\n&#123;0x00, 0x3E, 0x41, 0x41, 0x41, 0x22&#125;,// C\n&#123;0x00, 0x7F, 0x41, 0x41, 0x22, 0x1C&#125;,// D\n&#123;0x00, 0x7F, 0x49, 0x49, 0x49, 0x41&#125;,// E\n&#123;0x00, 0x7F, 0x09, 0x09, 0x09, 0x01&#125;,// F\n&#123;0x00, 0x3E, 0x41, 0x49, 0x49, 0x7A&#125;,// G\n&#123;0x00, 0x7F, 0x08, 0x08, 0x08, 0x7F&#125;,// H\n&#123;0x00, 0x00, 0x41, 0x7F, 0x41, 0x00&#125;,// I\n&#123;0x00, 0x20, 0x40, 0x41, 0x3F, 0x01&#125;,// J\n&#123;0x00, 0x7F, 0x08, 0x14, 0x22, 0x41&#125;,// K\n&#123;0x00, 0x7F, 0x40, 0x40, 0x40, 0x40&#125;,// L\n&#123;0x00, 0x7F, 0x02, 0x0C, 0x02, 0x7F&#125;,// M\n&#123;0x00, 0x7F, 0x04, 0x08, 0x10, 0x7F&#125;,// N\n&#123;0x00, 0x3E, 0x41, 0x41, 0x41, 0x3E&#125;,// O\n&#123;0x00, 0x7F, 0x09, 0x09, 0x09, 0x06&#125;,// P\n&#123;0x00, 0x3E, 0x41, 0x51, 0x21, 0x5E&#125;,// Q\n&#123;0x00, 0x7F, 0x09, 0x19, 0x29, 0x46&#125;,// R\n&#123;0x00, 0x46, 0x49, 0x49, 0x49, 0x31&#125;,// S\n&#123;0x00, 0x01, 0x01, 0x7F, 0x01, 0x01&#125;,// T\n&#123;0x00, 0x3F, 0x40, 0x40, 0x40, 0x3F&#125;,// U\n&#123;0x00, 0x1F, 0x20, 0x40, 0x20, 0x1F&#125;,// V\n&#123;0x00, 0x3F, 0x40, 0x38, 0x40, 0x3F&#125;,// W\n&#123;0x00, 0x63, 0x14, 0x08, 0x14, 0x63&#125;,// X\n&#123;0x00, 0x07, 0x08, 0x70, 0x08, 0x07&#125;,// Y\n&#123;0x00, 0x61, 0x51, 0x49, 0x45, 0x43&#125;,// Z\n&#123;0x00, 0x00, 0x7F, 0x41, 0x41, 0x00&#125;,// [\n&#123;0x00, 0x55, 0x2A, 0x55, 0x2A, 0x55&#125;,// 55\n&#123;0x00, 0x00, 0x41, 0x41, 0x7F, 0x00&#125;,// ]\n&#123;0x00, 0x04, 0x02, 0x01, 0x02, 0x04&#125;,// ^\n&#123;0x00, 0x40, 0x40, 0x40, 0x40, 0x40&#125;,// _\n&#123;0x00, 0x00, 0x01, 0x02, 0x04, 0x00&#125;,// '\n&#123;0x00, 0x20, 0x54, 0x54, 0x54, 0x78&#125;,// a\n&#123;0x00, 0x7F, 0x48, 0x44, 0x44, 0x38&#125;,// b\n&#123;0x00, 0x38, 0x44, 0x44, 0x44, 0x20&#125;,// c\n&#123;0x00, 0x38, 0x44, 0x44, 0x48, 0x7F&#125;,// d\n&#123;0x00, 0x38, 0x54, 0x54, 0x54, 0x18&#125;,// e\n&#123;0x00, 0x08, 0x7E, 0x09, 0x01, 0x02&#125;,// f\n&#123;0x00, 0x18, 0xA4, 0xA4, 0xA4, 0x7C&#125;,// g\n&#123;0x00, 0x7F, 0x08, 0x04, 0x04, 0x78&#125;,// h\n&#123;0x00, 0x00, 0x44, 0x7D, 0x40, 0x00&#125;,// i\n&#123;0x00, 0x40, 0x80, 0x84, 0x7D, 0x00&#125;,// j\n&#123;0x00, 0x7F, 0x10, 0x28, 0x44, 0x00&#125;,// k\n&#123;0x00, 0x00, 0x41, 0x7F, 0x40, 0x00&#125;,// l\n&#123;0x00, 0x7C, 0x04, 0x18, 0x04, 0x78&#125;,// m\n&#123;0x00, 0x7C, 0x08, 0x04, 0x04, 0x78&#125;,// n\n&#123;0x00, 0x38, 0x44, 0x44, 0x44, 0x38&#125;,// o\n&#123;0x00, 0xFC, 0x24, 0x24, 0x24, 0x18&#125;,// p\n&#123;0x00, 0x18, 0x24, 0x24, 0x18, 0xFC&#125;,// q\n&#123;0x00, 0x7C, 0x08, 0x04, 0x04, 0x08&#125;,// r\n&#123;0x00, 0x48, 0x54, 0x54, 0x54, 0x20&#125;,// s\n&#123;0x00, 0x04, 0x3F, 0x44, 0x40, 0x20&#125;,// t\n&#123;0x00, 0x3C, 0x40, 0x40, 0x20, 0x7C&#125;,// u\n&#123;0x00, 0x1C, 0x20, 0x40, 0x20, 0x1C&#125;,// v\n&#123;0x00, 0x3C, 0x40, 0x30, 0x40, 0x3C&#125;,// w\n&#123;0x00, 0x44, 0x28, 0x10, 0x28, 0x44&#125;,// x\n&#123;0x00, 0x1C, 0xA0, 0xA0, 0xA0, 0x7C&#125;,// y\n&#123;0x00, 0x44, 0x64, 0x54, 0x4C, 0x44&#125;,// z\n&#123;0x14, 0x14, 0x14, 0x14, 0x14, 0x14&#125;,// horiz lines\n&#125;;\n//12*12 ASCII?????\nconst unsigned char asc2_1206[95][12]=&#123;\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\" \",0*/\n&#123;0x00,0x00,0xFC,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00&#125;,/*\"!\",1*/\n&#123;0x00,0x0C,0x02,0x0C,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\"\"\",2*/\n&#123;0x90,0xD0,0xBC,0xD0,0xBC,0x90,0x00,0x03,0x00,0x03,0x00,0x00&#125;,/*\"#\",3*/\n&#123;0x18,0x24,0xFE,0x44,0x8C,0x00,0x03,0x02,0x07,0x02,0x01,0x00&#125;,/*\"$\",4*/\n&#123;0x18,0x24,0xD8,0xB0,0x4C,0x80,0x00,0x03,0x00,0x01,0x02,0x01&#125;,/*\"%\",5*/\n&#123;0xC0,0x38,0xE4,0x38,0xE0,0x00,0x01,0x02,0x02,0x01,0x02,0x02&#125;,/*\"&amp;\",6*/\n&#123;0x08,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\"'\",7*/\n&#123;0x00,0x00,0x00,0xF8,0x04,0x02,0x00,0x00,0x00,0x01,0x02,0x04&#125;,/*\"(\",8*/\n&#123;0x00,0x02,0x04,0xF8,0x00,0x00,0x00,0x04,0x02,0x01,0x00,0x00&#125;,/*\")\",9*/\n&#123;0x90,0x60,0xF8,0x60,0x90,0x00,0x00,0x00,0x01,0x00,0x00,0x00&#125;,/*\"*\",10*/\n&#123;0x20,0x20,0xFC,0x20,0x20,0x00,0x00,0x00,0x01,0x00,0x00,0x00&#125;,/*\"+\",11*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x06,0x00,0x00,0x00,0x00&#125;,/*\",\",12*/\n&#123;0x20,0x20,0x20,0x20,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\"-\",13*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00&#125;,/*\".\",14*/\n&#123;0x00,0x80,0x60,0x1C,0x02,0x00,0x04,0x03,0x00,0x00,0x00,0x00&#125;,/*\"/\",15*/\n&#123;0xF8,0x04,0x04,0x04,0xF8,0x00,0x01,0x02,0x02,0x02,0x01,0x00&#125;,/*\"0\",16*/\n&#123;0x00,0x08,0xFC,0x00,0x00,0x00,0x00,0x02,0x03,0x02,0x00,0x00&#125;,/*\"1\",17*/\n&#123;0x18,0x84,0x44,0x24,0x18,0x00,0x03,0x02,0x02,0x02,0x02,0x00&#125;,/*\"2\",18*/\n&#123;0x08,0x04,0x24,0x24,0xD8,0x00,0x01,0x02,0x02,0x02,0x01,0x00&#125;,/*\"3\",19*/\n&#123;0x40,0xB0,0x88,0xFC,0x80,0x00,0x00,0x00,0x00,0x03,0x02,0x00&#125;,/*\"4\",20*/\n&#123;0x3C,0x24,0x24,0x24,0xC4,0x00,0x01,0x02,0x02,0x02,0x01,0x00&#125;,/*\"5\",21*/\n&#123;0xF8,0x24,0x24,0x2C,0xC0,0x00,0x01,0x02,0x02,0x02,0x01,0x00&#125;,/*\"6\",22*/\n&#123;0x0C,0x04,0xE4,0x1C,0x04,0x00,0x00,0x00,0x03,0x00,0x00,0x00&#125;,/*\"7\",23*/\n&#123;0xD8,0x24,0x24,0x24,0xD8,0x00,0x01,0x02,0x02,0x02,0x01,0x00&#125;,/*\"8\",24*/\n&#123;0x38,0x44,0x44,0x44,0xF8,0x00,0x00,0x03,0x02,0x02,0x01,0x00&#125;,/*\"9\",25*/\n&#123;0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00&#125;,/*\":\",26*/\n&#123;0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00&#125;,/*\";\",27*/\n&#123;0x00,0x20,0x50,0x88,0x04,0x02,0x00,0x00,0x00,0x00,0x01,0x02&#125;,/*\"&lt;\",28*/\n&#123;0x90,0x90,0x90,0x90,0x90,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\"=\",29*/\n&#123;0x00,0x02,0x04,0x88,0x50,0x20,0x00,0x02,0x01,0x00,0x00,0x00&#125;,/*\">\",30*/\n&#123;0x18,0x04,0xC4,0x24,0x18,0x00,0x00,0x00,0x02,0x00,0x00,0x00&#125;,/*\"?\",31*/\n&#123;0xF8,0x04,0xE4,0x94,0xF8,0x00,0x01,0x02,0x02,0x02,0x02,0x00&#125;,/*\"@\",32*/\n&#123;0x00,0xE0,0x9C,0xF0,0x80,0x00,0x02,0x03,0x00,0x00,0x03,0x02&#125;,/*\"A\",33*/\n&#123;0x04,0xFC,0x24,0x24,0xD8,0x00,0x02,0x03,0x02,0x02,0x01,0x00&#125;,/*\"B\",34*/\n&#123;0xF8,0x04,0x04,0x04,0x0C,0x00,0x01,0x02,0x02,0x02,0x01,0x00&#125;,/*\"C\",35*/\n&#123;0x04,0xFC,0x04,0x04,0xF8,0x00,0x02,0x03,0x02,0x02,0x01,0x00&#125;,/*\"D\",36*/\n&#123;0x04,0xFC,0x24,0x74,0x0C,0x00,0x02,0x03,0x02,0x02,0x03,0x00&#125;,/*\"E\",37*/\n&#123;0x04,0xFC,0x24,0x74,0x0C,0x00,0x02,0x03,0x02,0x00,0x00,0x00&#125;,/*\"F\",38*/\n&#123;0xF0,0x08,0x04,0x44,0xCC,0x40,0x00,0x01,0x02,0x02,0x01,0x00&#125;,/*\"G\",39*/\n&#123;0x04,0xFC,0x20,0x20,0xFC,0x04,0x02,0x03,0x00,0x00,0x03,0x02&#125;,/*\"H\",40*/\n&#123;0x04,0x04,0xFC,0x04,0x04,0x00,0x02,0x02,0x03,0x02,0x02,0x00&#125;,/*\"I\",41*/\n&#123;0x00,0x04,0x04,0xFC,0x04,0x04,0x06,0x04,0x04,0x03,0x00,0x00&#125;,/*\"J\",42*/\n&#123;0x04,0xFC,0x24,0xD0,0x0C,0x04,0x02,0x03,0x02,0x00,0x03,0x02&#125;,/*\"K\",43*/\n&#123;0x04,0xFC,0x04,0x00,0x00,0x00,0x02,0x03,0x02,0x02,0x02,0x03&#125;,/*\"L\",44*/\n&#123;0xFC,0x3C,0xC0,0x3C,0xFC,0x00,0x03,0x00,0x03,0x00,0x03,0x00&#125;,/*\"M\",45*/\n&#123;0x04,0xFC,0x30,0xC4,0xFC,0x04,0x02,0x03,0x02,0x00,0x03,0x00&#125;,/*\"N\",46*/\n&#123;0xF8,0x04,0x04,0x04,0xF8,0x00,0x01,0x02,0x02,0x02,0x01,0x00&#125;,/*\"O\",47*/\n&#123;0x04,0xFC,0x24,0x24,0x18,0x00,0x02,0x03,0x02,0x00,0x00,0x00&#125;,/*\"P\",48*/\n&#123;0xF8,0x84,0x84,0x04,0xF8,0x00,0x01,0x02,0x02,0x07,0x05,0x00&#125;,/*\"Q\",49*/\n&#123;0x04,0xFC,0x24,0x64,0x98,0x00,0x02,0x03,0x02,0x00,0x03,0x02&#125;,/*\"R\",50*/\n&#123;0x18,0x24,0x24,0x44,0x8C,0x00,0x03,0x02,0x02,0x02,0x01,0x00&#125;,/*\"S\",51*/\n&#123;0x0C,0x04,0xFC,0x04,0x0C,0x00,0x00,0x02,0x03,0x02,0x00,0x00&#125;,/*\"T\",52*/\n&#123;0x04,0xFC,0x00,0x00,0xFC,0x04,0x00,0x01,0x02,0x02,0x01,0x00&#125;,/*\"U\",53*/\n&#123;0x04,0x7C,0x80,0xE0,0x1C,0x04,0x00,0x00,0x03,0x00,0x00,0x00&#125;,/*\"V\",54*/\n&#123;0x1C,0xE0,0x3C,0xE0,0x1C,0x00,0x00,0x03,0x00,0x03,0x00,0x00&#125;,/*\"W\",55*/\n&#123;0x04,0x9C,0x60,0x9C,0x04,0x00,0x02,0x03,0x00,0x03,0x02,0x00&#125;,/*\"X\",56*/\n&#123;0x04,0x1C,0xE0,0x1C,0x04,0x00,0x00,0x02,0x03,0x02,0x00,0x00&#125;,/*\"Y\",57*/\n&#123;0x0C,0x84,0x64,0x1C,0x04,0x00,0x02,0x03,0x02,0x02,0x03,0x00&#125;,/*\"Z\",58*/\n&#123;0x00,0x00,0xFE,0x02,0x02,0x00,0x00,0x00,0x07,0x04,0x04,0x00&#125;,/*\"[\",59*/\n&#123;0x00,0x0E,0x30,0xC0,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x00&#125;,/*\"\\\",60*/\n&#123;0x00,0x02,0x02,0xFE,0x00,0x00,0x00,0x04,0x04,0x07,0x00,0x00&#125;,/*\"]\",61*/\n&#123;0x00,0x04,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\"^\",62*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x08,0x08,0x08,0x08,0x08&#125;,/*\"_\",63*/\n&#123;0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\"`\",64*/\n&#123;0x00,0x40,0xA0,0xA0,0xC0,0x00,0x00,0x01,0x02,0x02,0x03,0x02&#125;,/*\"a\",65*/\n&#123;0x04,0xFC,0x20,0x20,0xC0,0x00,0x00,0x03,0x02,0x02,0x01,0x00&#125;,/*\"b\",66*/\n&#123;0x00,0xC0,0x20,0x20,0x60,0x00,0x00,0x01,0x02,0x02,0x02,0x00&#125;,/*\"c\",67*/\n&#123;0x00,0xC0,0x20,0x24,0xFC,0x00,0x00,0x01,0x02,0x02,0x03,0x02&#125;,/*\"d\",68*/\n&#123;0x00,0xC0,0xA0,0xA0,0xC0,0x00,0x00,0x01,0x02,0x02,0x02,0x00&#125;,/*\"e\",69*/\n&#123;0x00,0x20,0xF8,0x24,0x24,0x04,0x00,0x02,0x03,0x02,0x02,0x00&#125;,/*\"f\",70*/\n&#123;0x00,0x40,0xA0,0xA0,0x60,0x20,0x00,0x07,0x0A,0x0A,0x0A,0x04&#125;,/*\"g\",71*/\n&#123;0x04,0xFC,0x20,0x20,0xC0,0x00,0x02,0x03,0x02,0x00,0x03,0x02&#125;,/*\"h\",72*/\n&#123;0x00,0x20,0xE4,0x00,0x00,0x00,0x00,0x02,0x03,0x02,0x00,0x00&#125;,/*\"i\",73*/\n&#123;0x00,0x00,0x20,0xE4,0x00,0x00,0x08,0x08,0x08,0x07,0x00,0x00&#125;,/*\"j\",74*/\n&#123;0x04,0xFC,0x80,0xE0,0x20,0x20,0x02,0x03,0x02,0x00,0x03,0x02&#125;,/*\"k\",75*/\n&#123;0x04,0x04,0xFC,0x00,0x00,0x00,0x02,0x02,0x03,0x02,0x02,0x00&#125;,/*\"l\",76*/\n&#123;0xE0,0x20,0xE0,0x20,0xC0,0x00,0x03,0x00,0x03,0x00,0x03,0x00&#125;,/*\"m\",77*/\n&#123;0x20,0xE0,0x20,0x20,0xC0,0x00,0x02,0x03,0x02,0x00,0x03,0x02&#125;,/*\"n\",78*/\n&#123;0x00,0xC0,0x20,0x20,0xC0,0x00,0x00,0x01,0x02,0x02,0x01,0x00&#125;,/*\"o\",79*/\n&#123;0x20,0xE0,0x20,0x20,0xC0,0x00,0x08,0x0F,0x0A,0x02,0x01,0x00&#125;,/*\"p\",80*/\n&#123;0x00,0xC0,0x20,0x20,0xE0,0x00,0x00,0x01,0x02,0x0A,0x0F,0x08&#125;,/*\"q\",81*/\n&#123;0x20,0xE0,0x40,0x20,0x20,0x00,0x02,0x03,0x02,0x00,0x00,0x00&#125;,/*\"r\",82*/\n&#123;0x00,0x60,0xA0,0xA0,0x20,0x00,0x00,0x02,0x02,0x02,0x03,0x00&#125;,/*\"s\",83*/\n&#123;0x00,0x20,0xF8,0x20,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x00&#125;,/*\"t\",84*/\n&#123;0x20,0xE0,0x00,0x20,0xE0,0x00,0x00,0x01,0x02,0x02,0x03,0x02&#125;,/*\"u\",85*/\n&#123;0x20,0xE0,0x20,0x80,0x60,0x20,0x00,0x00,0x03,0x01,0x00,0x00&#125;,/*\"v\",86*/\n&#123;0x60,0x80,0xE0,0x80,0x60,0x00,0x00,0x03,0x00,0x03,0x00,0x00&#125;,/*\"w\",87*/\n&#123;0x20,0x60,0x80,0x60,0x20,0x00,0x02,0x03,0x00,0x03,0x02,0x00&#125;,/*\"x\",88*/\n&#123;0x20,0xE0,0x20,0x80,0x60,0x20,0x08,0x08,0x07,0x01,0x00,0x00&#125;,/*\"y\",89*/\n&#123;0x00,0x20,0xA0,0x60,0x20,0x00,0x00,0x02,0x03,0x02,0x02,0x00&#125;,/*\"z\",90*/\n&#123;0x00,0x00,0x20,0xDE,0x02,0x00,0x00,0x00,0x00,0x07,0x04,0x00&#125;,/*\"&#123;\",91*/\n&#123;0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x0F,0x00,0x00&#125;,/*\"|\",92*/\n&#123;0x00,0x02,0xDE,0x20,0x00,0x00,0x00,0x04,0x07,0x00,0x00,0x00&#125;,/*\"&#125;\",93*/\n&#123;0x02,0x01,0x02,0x04,0x04,0x02,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\"~\",94*/\n&#125;;  \n//16*16 ASCII?????\nconst unsigned char asc2_1608[][16]=&#123;\t  \n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\" \",0*/\n&#123;0x00,0x00,0x00,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x33,0x30,0x00,0x00,0x00&#125;,/*\"!\",1*/\n&#123;0x00,0x10,0x0C,0x06,0x10,0x0C,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\"\"\",2*/\n&#123;0x40,0xC0,0x78,0x40,0xC0,0x78,0x40,0x00,0x04,0x3F,0x04,0x04,0x3F,0x04,0x04,0x00&#125;,/*\"#\",3*/\n&#123;0x00,0x70,0x88,0xFC,0x08,0x30,0x00,0x00,0x00,0x18,0x20,0xFF,0x21,0x1E,0x00,0x00&#125;,/*\"$\",4*/\n&#123;0xF0,0x08,0xF0,0x00,0xE0,0x18,0x00,0x00,0x00,0x21,0x1C,0x03,0x1E,0x21,0x1E,0x00&#125;,/*\"%\",5*/\n&#123;0x00,0xF0,0x08,0x88,0x70,0x00,0x00,0x00,0x1E,0x21,0x23,0x24,0x19,0x27,0x21,0x10&#125;,/*\"&amp;\",6*/\n&#123;0x10,0x16,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\"'\",7*/\n&#123;0x00,0x00,0x00,0xE0,0x18,0x04,0x02,0x00,0x00,0x00,0x00,0x07,0x18,0x20,0x40,0x00&#125;,/*\"(\",8*/\n&#123;0x00,0x02,0x04,0x18,0xE0,0x00,0x00,0x00,0x00,0x40,0x20,0x18,0x07,0x00,0x00,0x00&#125;,/*\")\",9*/\n&#123;0x40,0x40,0x80,0xF0,0x80,0x40,0x40,0x00,0x02,0x02,0x01,0x0F,0x01,0x02,0x02,0x00&#125;,/*\"*\",10*/\n&#123;0x00,0x00,0x00,0xF0,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x1F,0x01,0x01,0x01,0x00&#125;,/*\"+\",11*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xB0,0x70,0x00,0x00,0x00,0x00,0x00&#125;,/*\",\",12*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01&#125;,/*\"-\",13*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x00&#125;,/*\".\",14*/\n&#123;0x00,0x00,0x00,0x00,0x80,0x60,0x18,0x04,0x00,0x60,0x18,0x06,0x01,0x00,0x00,0x00&#125;,/*\"/\",15*/\n&#123;0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x0F,0x10,0x20,0x20,0x10,0x0F,0x00&#125;,/*\"0\",16*/\n&#123;0x00,0x10,0x10,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00&#125;,/*\"1\",17*/\n&#123;0x00,0x70,0x08,0x08,0x08,0x88,0x70,0x00,0x00,0x30,0x28,0x24,0x22,0x21,0x30,0x00&#125;,/*\"2\",18*/\n&#123;0x00,0x30,0x08,0x88,0x88,0x48,0x30,0x00,0x00,0x18,0x20,0x20,0x20,0x11,0x0E,0x00&#125;,/*\"3\",19*/\n&#123;0x00,0x00,0xC0,0x20,0x10,0xF8,0x00,0x00,0x00,0x07,0x04,0x24,0x24,0x3F,0x24,0x00&#125;,/*\"4\",20*/\n&#123;0x00,0xF8,0x08,0x88,0x88,0x08,0x08,0x00,0x00,0x19,0x21,0x20,0x20,0x11,0x0E,0x00&#125;,/*\"5\",21*/\n&#123;0x00,0xE0,0x10,0x88,0x88,0x18,0x00,0x00,0x00,0x0F,0x11,0x20,0x20,0x11,0x0E,0x00&#125;,/*\"6\",22*/\n&#123;0x00,0x38,0x08,0x08,0xC8,0x38,0x08,0x00,0x00,0x00,0x00,0x3F,0x00,0x00,0x00,0x00&#125;,/*\"7\",23*/\n&#123;0x00,0x70,0x88,0x08,0x08,0x88,0x70,0x00,0x00,0x1C,0x22,0x21,0x21,0x22,0x1C,0x00&#125;,/*\"8\",24*/\n&#123;0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x00,0x31,0x22,0x22,0x11,0x0F,0x00&#125;,/*\"9\",25*/\n&#123;0x00,0x00,0x00,0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00&#125;,/*\":\",26*/\n&#123;0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x60,0x00,0x00,0x00,0x00&#125;,/*\";\",27*/\n&#123;0x00,0x00,0x80,0x40,0x20,0x10,0x08,0x00,0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x00&#125;,/*\"&lt;\",28*/\n&#123;0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x00,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x00&#125;,/*\"=\",29*/\n&#123;0x00,0x08,0x10,0x20,0x40,0x80,0x00,0x00,0x00,0x20,0x10,0x08,0x04,0x02,0x01,0x00&#125;,/*\">\",30*/\n&#123;0x00,0x70,0x48,0x08,0x08,0x08,0xF0,0x00,0x00,0x00,0x00,0x30,0x36,0x01,0x00,0x00&#125;,/*\"?\",31*/\n&#123;0xC0,0x30,0xC8,0x28,0xE8,0x10,0xE0,0x00,0x07,0x18,0x27,0x24,0x23,0x14,0x0B,0x00&#125;,/*\"@\",32*/\n&#123;0x00,0x00,0xC0,0x38,0xE0,0x00,0x00,0x00,0x20,0x3C,0x23,0x02,0x02,0x27,0x38,0x20&#125;,/*\"A\",33*/\n&#123;0x08,0xF8,0x88,0x88,0x88,0x70,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x11,0x0E,0x00&#125;,/*\"B\",34*/\n&#123;0xC0,0x30,0x08,0x08,0x08,0x08,0x38,0x00,0x07,0x18,0x20,0x20,0x20,0x10,0x08,0x00&#125;,/*\"C\",35*/\n&#123;0x08,0xF8,0x08,0x08,0x08,0x10,0xE0,0x00,0x20,0x3F,0x20,0x20,0x20,0x10,0x0F,0x00&#125;,/*\"D\",36*/\n&#123;0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x20,0x23,0x20,0x18,0x00&#125;,/*\"E\",37*/\n&#123;0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x00,0x03,0x00,0x00,0x00&#125;,/*\"F\",38*/\n&#123;0xC0,0x30,0x08,0x08,0x08,0x38,0x00,0x00,0x07,0x18,0x20,0x20,0x22,0x1E,0x02,0x00&#125;,/*\"G\",39*/\n&#123;0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x20,0x3F,0x21,0x01,0x01,0x21,0x3F,0x20&#125;,/*\"H\",40*/\n&#123;0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00&#125;,/*\"I\",41*/\n&#123;0x00,0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,0x00&#125;,/*\"J\",42*/\n&#123;0x08,0xF8,0x88,0xC0,0x28,0x18,0x08,0x00,0x20,0x3F,0x20,0x01,0x26,0x38,0x20,0x00&#125;,/*\"K\",43*/\n&#123;0x08,0xF8,0x08,0x00,0x00,0x00,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x20,0x30,0x00&#125;,/*\"L\",44*/\n&#123;0x08,0xF8,0xF8,0x00,0xF8,0xF8,0x08,0x00,0x20,0x3F,0x00,0x3F,0x00,0x3F,0x20,0x00&#125;,/*\"M\",45*/\n&#123;0x08,0xF8,0x30,0xC0,0x00,0x08,0xF8,0x08,0x20,0x3F,0x20,0x00,0x07,0x18,0x3F,0x00&#125;,/*\"N\",46*/\n&#123;0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x10,0x20,0x20,0x20,0x10,0x0F,0x00&#125;,/*\"O\",47*/\n&#123;0x08,0xF8,0x08,0x08,0x08,0x08,0xF0,0x00,0x20,0x3F,0x21,0x01,0x01,0x01,0x00,0x00&#125;,/*\"P\",48*/\n&#123;0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x18,0x24,0x24,0x38,0x50,0x4F,0x00&#125;,/*\"Q\",49*/\n&#123;0x08,0xF8,0x88,0x88,0x88,0x88,0x70,0x00,0x20,0x3F,0x20,0x00,0x03,0x0C,0x30,0x20&#125;,/*\"R\",50*/\n&#123;0x00,0x70,0x88,0x08,0x08,0x08,0x38,0x00,0x00,0x38,0x20,0x21,0x21,0x22,0x1C,0x00&#125;,/*\"S\",51*/\n&#123;0x18,0x08,0x08,0xF8,0x08,0x08,0x18,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00&#125;,/*\"T\",52*/\n&#123;0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00&#125;,/*\"U\",53*/\n&#123;0x08,0x78,0x88,0x00,0x00,0xC8,0x38,0x08,0x00,0x00,0x07,0x38,0x0E,0x01,0x00,0x00&#125;,/*\"V\",54*/\n&#123;0xF8,0x08,0x00,0xF8,0x00,0x08,0xF8,0x00,0x03,0x3C,0x07,0x00,0x07,0x3C,0x03,0x00&#125;,/*\"W\",55*/\n&#123;0x08,0x18,0x68,0x80,0x80,0x68,0x18,0x08,0x20,0x30,0x2C,0x03,0x03,0x2C,0x30,0x20&#125;,/*\"X\",56*/\n&#123;0x08,0x38,0xC8,0x00,0xC8,0x38,0x08,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00&#125;,/*\"Y\",57*/\n&#123;0x10,0x08,0x08,0x08,0xC8,0x38,0x08,0x00,0x20,0x38,0x26,0x21,0x20,0x20,0x18,0x00&#125;,/*\"Z\",58*/\n&#123;0x00,0x00,0x00,0xFE,0x02,0x02,0x02,0x00,0x00,0x00,0x00,0x7F,0x40,0x40,0x40,0x00&#125;,/*\"[\",59*/\n&#123;0x00,0x0C,0x30,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x06,0x38,0xC0,0x00&#125;,/*\"\\\",60*/\n&#123;0x00,0x02,0x02,0x02,0xFE,0x00,0x00,0x00,0x00,0x40,0x40,0x40,0x7F,0x00,0x00,0x00&#125;,/*\"]\",61*/\n&#123;0x00,0x00,0x04,0x02,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\"^\",62*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80&#125;,/*\"_\",63*/\n&#123;0x00,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\"`\",64*/\n&#123;0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x19,0x24,0x22,0x22,0x22,0x3F,0x20&#125;,/*\"a\",65*/\n&#123;0x08,0xF8,0x00,0x80,0x80,0x00,0x00,0x00,0x00,0x3F,0x11,0x20,0x20,0x11,0x0E,0x00&#125;,/*\"b\",66*/\n&#123;0x00,0x00,0x00,0x80,0x80,0x80,0x00,0x00,0x00,0x0E,0x11,0x20,0x20,0x20,0x11,0x00&#125;,/*\"c\",67*/\n&#123;0x00,0x00,0x00,0x80,0x80,0x88,0xF8,0x00,0x00,0x0E,0x11,0x20,0x20,0x10,0x3F,0x20&#125;,/*\"d\",68*/\n&#123;0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x22,0x22,0x22,0x22,0x13,0x00&#125;,/*\"e\",69*/\n&#123;0x00,0x80,0x80,0xF0,0x88,0x88,0x88,0x18,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00&#125;,/*\"f\",70*/\n&#123;0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x6B,0x94,0x94,0x94,0x93,0x60,0x00&#125;,/*\"g\",71*/\n&#123;0x08,0xF8,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20&#125;,/*\"h\",72*/\n&#123;0x00,0x80,0x98,0x98,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00&#125;,/*\"i\",73*/\n&#123;0x00,0x00,0x00,0x80,0x98,0x98,0x00,0x00,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00&#125;,/*\"j\",74*/\n&#123;0x08,0xF8,0x00,0x00,0x80,0x80,0x80,0x00,0x20,0x3F,0x24,0x02,0x2D,0x30,0x20,0x00&#125;,/*\"k\",75*/\n&#123;0x00,0x08,0x08,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00&#125;,/*\"l\",76*/\n&#123;0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x20,0x3F,0x20,0x00,0x3F,0x20,0x00,0x3F&#125;,/*\"m\",77*/\n&#123;0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20&#125;,/*\"n\",78*/\n&#123;0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00&#125;,/*\"o\",79*/\n&#123;0x80,0x80,0x00,0x80,0x80,0x00,0x00,0x00,0x80,0xFF,0xA1,0x20,0x20,0x11,0x0E,0x00&#125;,/*\"p\",80*/\n&#123;0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x0E,0x11,0x20,0x20,0xA0,0xFF,0x80&#125;,/*\"q\",81*/\n&#123;0x80,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x20,0x20,0x3F,0x21,0x20,0x00,0x01,0x00&#125;,/*\"r\",82*/\n&#123;0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x33,0x24,0x24,0x24,0x24,0x19,0x00&#125;,/*\"s\",83*/\n&#123;0x00,0x80,0x80,0xE0,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x1F,0x20,0x20,0x00,0x00&#125;,/*\"t\",84*/\n&#123;0x80,0x80,0x00,0x00,0x00,0x80,0x80,0x00,0x00,0x1F,0x20,0x20,0x20,0x10,0x3F,0x20&#125;,/*\"u\",85*/\n&#123;0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x00,0x01,0x0E,0x30,0x08,0x06,0x01,0x00&#125;,/*\"v\",86*/\n&#123;0x80,0x80,0x00,0x80,0x00,0x80,0x80,0x80,0x0F,0x30,0x0C,0x03,0x0C,0x30,0x0F,0x00&#125;,/*\"w\",87*/\n&#123;0x00,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x31,0x2E,0x0E,0x31,0x20,0x00&#125;,/*\"x\",88*/\n&#123;0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x80,0x81,0x8E,0x70,0x18,0x06,0x01,0x00&#125;,/*\"y\",89*/\n&#123;0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x21,0x30,0x2C,0x22,0x21,0x30,0x00&#125;,/*\"z\",90*/\n&#123;0x00,0x00,0x00,0x00,0x80,0x7C,0x02,0x02,0x00,0x00,0x00,0x00,0x00,0x3F,0x40,0x40&#125;,/*\"&#123;\",91*/\n&#123;0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00&#125;,/*\"|\",92*/\n&#123;0x00,0x02,0x02,0x7C,0x80,0x00,0x00,0x00,0x00,0x40,0x40,0x3F,0x00,0x00,0x00,0x00&#125;,/*\"&#125;\",93*/\n&#123;0x00,0x06,0x01,0x01,0x02,0x02,0x04,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\"~\",94*/\n&#125;;  \n//24*24 ASICII?????\nconst unsigned char asc2_2412[][36]=&#123;\t  \n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\" \",0*/\n&#123;0x00,0x00,0x00,0x00,0x00,0xF0,0xF0,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x7F,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1C,0x1C,0x1C,0x00,0x00,0x00,0x00&#125;,/*\"!\",1*/\n&#123;0x00,0x00,0x80,0x60,0x30,0x1C,0x8C,0x60,0x30,0x1C,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\"\"\",2*/\n&#123;0x00,0x00,0x00,0xE0,0x00,0x00,0x00,0x00,0x00,0xE0,0x00,0x00,0x00,0x86,0xE6,0x9F,0x86,0x86,0x86,0x86,0xE6,0x9F,0x86,0x00,0x00,0x01,0x1F,0x01,0x01,0x01,0x01,0x01,0x1F,0x01,0x01,0x00&#125;,/*\"#\",3*/\n&#123;0x00,0x00,0x80,0xC0,0x60,0x20,0xF8,0x20,0xE0,0xC0,0x00,0x00,0x00,0x00,0x03,0x07,0x0C,0x18,0xFF,0x70,0xE1,0x81,0x00,0x00,0x00,0x00,0x07,0x0F,0x10,0x10,0x7F,0x10,0x0F,0x07,0x00,0x00&#125;,/*\"$\",4*/\n&#123;0x80,0x60,0x20,0x60,0x80,0x00,0x00,0x00,0xE0,0x20,0x00,0x00,0x0F,0x30,0x20,0x30,0x9F,0x70,0xDC,0x37,0x10,0x30,0xC0,0x00,0x00,0x00,0x10,0x0E,0x03,0x00,0x07,0x18,0x10,0x18,0x07,0x00&#125;,/*\"%\",5*/\n&#123;0x00,0x00,0xC0,0x20,0x20,0xE0,0xC0,0x00,0x00,0x00,0x00,0x00,0x80,0xE0,0x1F,0x38,0xE8,0x87,0x03,0xC4,0x3C,0x04,0x00,0x00,0x07,0x0F,0x18,0x10,0x10,0x0B,0x07,0x0D,0x10,0x10,0x08,0x00&#125;,/*\"&amp;\",6*/\n&#123;0x00,0x80,0x8C,0x4C,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\"'\",7*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xE0,0x30,0x08,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0xFF,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x0F,0x18,0x20,0x40,0x00&#125;,/*\"(\",8*/\n&#123;0x00,0x04,0x08,0x30,0xE0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x20,0x18,0x0F,0x03,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\")\",9*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x42,0x66,0x66,0x3C,0x18,0xFF,0x18,0x3C,0x66,0x66,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00&#125;,/*\"*\",10*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x10,0x10,0x10,0x10,0xFF,0x10,0x10,0x10,0x10,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00&#125;,/*\"+\",11*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x8C,0x4C,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\",\",12*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\"-\",13*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1C,0x1C,0x1C,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\".\",14*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x38,0x0C,0x00,0x00,0x00,0x00,0x00,0x80,0x70,0x1C,0x03,0x00,0x00,0x00,0x00,0x00,0x60,0x38,0x0E,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\"/\",15*/\n&#123;0x00,0x00,0x80,0xC0,0x60,0x20,0x20,0x60,0xC0,0x80,0x00,0x00,0x00,0xFE,0xFF,0x01,0x00,0x00,0x00,0x00,0x01,0xFF,0xFE,0x00,0x00,0x01,0x07,0x0E,0x18,0x10,0x10,0x18,0x0E,0x07,0x01,0x00&#125;,/*\"0\",16*/\n&#123;0x00,0x00,0x80,0x80,0x80,0xC0,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x10,0x10,0x1F,0x1F,0x10,0x10,0x10,0x00,0x00&#125;,/*\"1\",17*/\n&#123;0x00,0x80,0x40,0x20,0x20,0x20,0x20,0x60,0xC0,0x80,0x00,0x00,0x00,0x03,0x03,0x00,0x80,0x40,0x20,0x38,0x1F,0x07,0x00,0x00,0x00,0x1C,0x1A,0x19,0x18,0x18,0x18,0x18,0x18,0x1F,0x00,0x00&#125;,/*\"2\",18*/\n&#123;0x00,0x80,0xC0,0x20,0x20,0x20,0x60,0xC0,0x80,0x00,0x00,0x00,0x00,0x03,0x03,0x00,0x10,0x10,0x18,0x2F,0xE7,0x80,0x00,0x00,0x00,0x07,0x0F,0x10,0x10,0x10,0x10,0x18,0x0F,0x07,0x00,0x00&#125;,/*\"3\",19*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0xE0,0xF0,0x00,0x00,0x00,0x00,0xC0,0xB0,0x88,0x86,0x81,0x80,0xFF,0xFF,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x10,0x1F,0x1F,0x10,0x10,0x00&#125;,/*\"4\",20*/\n&#123;0x00,0x00,0xE0,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x00,0x00,0x00,0x00,0x3F,0x10,0x08,0x08,0x08,0x18,0xF0,0xE0,0x00,0x00,0x00,0x07,0x0B,0x10,0x10,0x10,0x10,0x1C,0x0F,0x03,0x00,0x00&#125;,/*\"5\",21*/\n&#123;0x00,0x00,0x80,0xC0,0x40,0x20,0x20,0x20,0xE0,0xC0,0x00,0x00,0x00,0xFC,0xFF,0x21,0x10,0x08,0x08,0x08,0x18,0xF0,0xE0,0x00,0x00,0x01,0x07,0x0C,0x18,0x10,0x10,0x10,0x08,0x0F,0x03,0x00&#125;,/*\"6\",22*/\n&#123;0x00,0x00,0xC0,0xE0,0x60,0x60,0x60,0x60,0x60,0xE0,0x60,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0xE0,0x18,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0x1F,0x00,0x00,0x00,0x00,0x00&#125;,/*\"7\",23*/\n&#123;0x00,0x80,0xC0,0x60,0x20,0x20,0x20,0x20,0x60,0xC0,0x80,0x00,0x00,0x87,0xEF,0x2C,0x18,0x18,0x30,0x30,0x68,0xCF,0x83,0x00,0x00,0x07,0x0F,0x08,0x10,0x10,0x10,0x10,0x18,0x0F,0x07,0x00&#125;,/*\"8\",24*/\n&#123;0x00,0x00,0xC0,0xC0,0x20,0x20,0x20,0x20,0xC0,0x80,0x00,0x00,0x00,0x1F,0x3F,0x60,0x40,0x40,0x40,0x20,0x10,0xFF,0xFE,0x00,0x00,0x00,0x0C,0x1C,0x10,0x10,0x10,0x08,0x0F,0x03,0x00,0x00&#125;,/*\"9\",25*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0E,0x0E,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1C,0x1C,0x1C,0x00,0x00,0x00,0x00&#125;,/*\":\",26*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0C,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x38,0x00,0x00,0x00,0x00,0x00&#125;,/*\";\",27*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x40,0x20,0x10,0x00,0x00,0x00,0x10,0x28,0x44,0x82,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x04,0x08,0x10,0x00&#125;,/*\"&lt;\",28*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\"=\",29*/\n&#123;0x00,0x00,0x10,0x20,0x40,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x82,0x44,0x28,0x10,0x00,0x00,0x00,0x10,0x08,0x04,0x02,0x01,0x00,0x00,0x00,0x00,0x00&#125;,/*\">\",30*/\n&#123;0x00,0xC0,0x20,0x20,0x10,0x10,0x10,0x10,0x30,0xE0,0xC0,0x00,0x00,0x03,0x03,0x00,0x00,0xF0,0x10,0x08,0x0C,0x07,0x03,0x00,0x00,0x00,0x00,0x00,0x1C,0x1C,0x1C,0x00,0x00,0x00,0x00,0x00&#125;,/*\"?\",31*/\n&#123;0x00,0x00,0x00,0xC0,0x40,0x60,0x20,0x20,0x20,0x40,0xC0,0x00,0x00,0xFC,0xFF,0x01,0xF0,0x0E,0x03,0xC1,0xFE,0x03,0x80,0x7F,0x00,0x01,0x07,0x0E,0x08,0x11,0x11,0x10,0x11,0x09,0x04,0x02&#125;,/*\"@\",32*/\n&#123;0x00,0x00,0x00,0x00,0x80,0xE0,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x7C,0x43,0x40,0x47,0x7F,0xF8,0x80,0x00,0x00,0x10,0x18,0x1F,0x10,0x00,0x00,0x00,0x00,0x13,0x1F,0x1C,0x10&#125;,/*\"A\",33*/\n&#123;0x20,0xE0,0xE0,0x20,0x20,0x20,0x20,0x60,0xC0,0x80,0x00,0x00,0x00,0xFF,0xFF,0x10,0x10,0x10,0x10,0x18,0x2F,0xE7,0x80,0x00,0x10,0x1F,0x1F,0x10,0x10,0x10,0x10,0x10,0x18,0x0F,0x07,0x00&#125;,/*\"B\",34*/\n&#123;0x00,0x00,0x80,0xC0,0x40,0x20,0x20,0x20,0x20,0x60,0xE0,0x00,0x00,0xFC,0xFF,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x01,0x07,0x0E,0x18,0x10,0x10,0x10,0x08,0x04,0x03,0x00&#125;,/*\"C\",35*/\n&#123;0x20,0xE0,0xE0,0x20,0x20,0x20,0x20,0x40,0xC0,0x80,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0xFE,0x00,0x10,0x1F,0x1F,0x10,0x10,0x10,0x18,0x08,0x0E,0x07,0x01,0x00&#125;,/*\"D\",36*/\n&#123;0x20,0xE0,0xE0,0x20,0x20,0x20,0x20,0x20,0x20,0x60,0x80,0x00,0x00,0xFF,0xFF,0x10,0x10,0x10,0x10,0x7C,0x00,0x00,0x00,0x00,0x10,0x1F,0x1F,0x10,0x10,0x10,0x10,0x10,0x10,0x18,0x06,0x00&#125;,/*\"E\",37*/\n&#123;0x20,0xE0,0xE0,0x20,0x20,0x20,0x20,0x20,0x60,0x60,0x80,0x00,0x00,0xFF,0xFF,0x10,0x10,0x10,0x10,0x7C,0x00,0x00,0x01,0x00,0x10,0x1F,0x1F,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\"F\",38*/\n&#123;0x00,0x00,0x80,0xC0,0x60,0x20,0x20,0x20,0x40,0xE0,0x00,0x00,0x00,0xFC,0xFF,0x01,0x00,0x00,0x40,0x40,0xC0,0xC1,0x40,0x40,0x00,0x01,0x07,0x0E,0x18,0x10,0x10,0x10,0x0F,0x0F,0x00,0x00&#125;,/*\"G\",39*/\n&#123;0x20,0xE0,0xE0,0x20,0x00,0x00,0x00,0x00,0x20,0xE0,0xE0,0x20,0x00,0xFF,0xFF,0x10,0x10,0x10,0x10,0x10,0x10,0xFF,0xFF,0x00,0x10,0x1F,0x1F,0x10,0x00,0x00,0x00,0x00,0x10,0x1F,0x1F,0x10&#125;,/*\"H\",40*/\n&#123;0x00,0x00,0x20,0x20,0x20,0xE0,0xE0,0x20,0x20,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x10,0x10,0x1F,0x1F,0x10,0x10,0x10,0x00,0x00&#125;,/*\"I\",41*/\n&#123;0x00,0x00,0x00,0x00,0x20,0x20,0x20,0xE0,0xE0,0x20,0x20,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x60,0xE0,0x80,0x80,0x80,0xC0,0x7F,0x3F,0x00,0x00,0x00&#125;,/*\"J\",42*/\n&#123;0x20,0xE0,0xE0,0x20,0x00,0x00,0x20,0xA0,0x60,0x20,0x20,0x00,0x00,0xFF,0xFF,0x30,0x18,0x7C,0xE3,0xC0,0x00,0x00,0x00,0x00,0x10,0x1F,0x1F,0x10,0x00,0x00,0x01,0x13,0x1F,0x1C,0x18,0x10&#125;,/*\"K\",43*/\n&#123;0x20,0xE0,0xE0,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x1F,0x1F,0x10,0x10,0x10,0x10,0x10,0x10,0x18,0x06,0x00&#125;,/*\"L\",44*/\n&#123;0x20,0xE0,0xE0,0xE0,0x00,0x00,0x00,0x00,0xE0,0xE0,0xE0,0x20,0x00,0xFF,0x01,0x3F,0xFE,0xC0,0xE0,0x1E,0x01,0xFF,0xFF,0x00,0x10,0x1F,0x10,0x00,0x03,0x1F,0x03,0x00,0x10,0x1F,0x1F,0x10&#125;,/*\"M\",45*/\n&#123;0x20,0xE0,0xE0,0xC0,0x00,0x00,0x00,0x00,0x00,0x20,0xE0,0x20,0x00,0xFF,0x00,0x03,0x07,0x1C,0x78,0xE0,0x80,0x00,0xFF,0x00,0x10,0x1F,0x10,0x00,0x00,0x00,0x00,0x00,0x03,0x0F,0x1F,0x00&#125;,/*\"N\",46*/\n&#123;0x00,0x00,0x80,0xC0,0x60,0x20,0x20,0x60,0xC0,0x80,0x00,0x00,0x00,0xFE,0xFF,0x01,0x00,0x00,0x00,0x00,0x00,0xFF,0xFE,0x00,0x00,0x01,0x07,0x0E,0x18,0x10,0x10,0x18,0x0C,0x07,0x01,0x00&#125;,/*\"O\",47*/\n&#123;0x20,0xE0,0xE0,0x20,0x20,0x20,0x20,0x20,0x60,0xC0,0x80,0x00,0x00,0xFF,0xFF,0x20,0x20,0x20,0x20,0x20,0x30,0x1F,0x0F,0x00,0x10,0x1F,0x1F,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\"P\",48*/\n&#123;0x00,0x00,0x80,0xC0,0x60,0x20,0x20,0x60,0xC0,0x80,0x00,0x00,0x00,0xFE,0xFF,0x01,0x00,0x00,0x00,0x00,0x00,0xFF,0xFE,0x00,0x00,0x01,0x07,0x0E,0x11,0x11,0x13,0x3C,0x7C,0x67,0x21,0x00&#125;,/*\"Q\",49*/\n&#123;0x20,0xE0,0xE0,0x20,0x20,0x20,0x20,0x20,0x60,0xC0,0x80,0x00,0x00,0xFF,0xFF,0x10,0x10,0x30,0xF0,0xD0,0x08,0x0F,0x07,0x00,0x10,0x1F,0x1F,0x10,0x00,0x00,0x00,0x03,0x0F,0x1C,0x10,0x10&#125;,/*\"R\",50*/\n&#123;0x00,0x80,0xC0,0x60,0x20,0x20,0x20,0x20,0x40,0x40,0xE0,0x00,0x00,0x07,0x0F,0x0C,0x18,0x18,0x30,0x30,0x60,0xE0,0x81,0x00,0x00,0x1F,0x0C,0x08,0x10,0x10,0x10,0x10,0x18,0x0F,0x07,0x00&#125;,/*\"S\",51*/\n&#123;0x80,0x60,0x20,0x20,0x20,0xE0,0xE0,0x20,0x20,0x20,0x60,0x80,0x01,0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x10,0x1F,0x1F,0x10,0x00,0x00,0x00,0x00&#125;,/*\"T\",52*/\n&#123;0x20,0xE0,0xE0,0x20,0x00,0x00,0x00,0x00,0x00,0x20,0xE0,0x20,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x07,0x0F,0x18,0x10,0x10,0x10,0x10,0x10,0x08,0x07,0x00&#125;,/*\"U\",53*/\n&#123;0x20,0x60,0xE0,0xE0,0x20,0x00,0x00,0x00,0x20,0xE0,0x60,0x20,0x00,0x00,0x07,0x7F,0xF8,0x80,0x00,0x80,0x7C,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x1F,0x1C,0x07,0x00,0x00,0x00,0x00&#125;,/*\"V\",54*/\n&#123;0x20,0xE0,0xE0,0x20,0x00,0xE0,0xE0,0x20,0x00,0x20,0xE0,0x20,0x00,0x07,0xFF,0xF8,0xE0,0x1F,0xFF,0xFC,0xE0,0x1F,0x00,0x00,0x00,0x00,0x03,0x1F,0x03,0x00,0x01,0x1F,0x03,0x00,0x00,0x00&#125;,/*\"W\",55*/\n&#123;0x00,0x20,0x60,0xE0,0xA0,0x00,0x00,0x20,0xE0,0x60,0x20,0x00,0x00,0x00,0x00,0x03,0x8F,0x7C,0xF8,0xC6,0x01,0x00,0x00,0x00,0x00,0x10,0x18,0x1E,0x13,0x00,0x01,0x17,0x1F,0x18,0x10,0x00&#125;,/*\"X\",56*/\n&#123;0x20,0x60,0xE0,0xE0,0x20,0x00,0x00,0x00,0x20,0xE0,0x60,0x20,0x00,0x00,0x01,0x07,0x3E,0xF8,0xE0,0x18,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x10,0x1F,0x1F,0x10,0x10,0x00,0x00,0x00&#125;,/*\"Y\",57*/\n&#123;0x00,0x80,0x60,0x20,0x20,0x20,0x20,0xA0,0xE0,0xE0,0x20,0x00,0x00,0x00,0x00,0x00,0xC0,0xF0,0x3E,0x0F,0x03,0x00,0x00,0x00,0x00,0x10,0x1C,0x1F,0x17,0x10,0x10,0x10,0x10,0x18,0x06,0x00&#125;,/*\"Z\",58*/\n&#123;0x00,0x00,0x00,0x00,0x00,0xFC,0x04,0x04,0x04,0x04,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x40,0x40,0x40,0x40,0x40,0x00&#125;,/*\"[\",59*/\n&#123;0x00,0x00,0x10,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x1C,0x60,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x0C,0x70,0x80,0x00&#125;,/*\"\\\",60*/\n&#123;0x00,0x00,0x04,0x04,0x04,0x04,0x04,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x40,0x40,0x40,0x40,0x7F,0x00,0x00,0x00,0x00&#125;,/*\"]\",61*/\n&#123;0x00,0x00,0x00,0x10,0x08,0x0C,0x04,0x0C,0x08,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\"^\",62*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80&#125;,/*\"_\",63*/\n&#123;0x00,0x00,0x00,0x04,0x04,0x08,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\"`\",64*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x98,0xD8,0x44,0x64,0x24,0x24,0xFC,0xF8,0x00,0x00,0x00,0x0F,0x1F,0x18,0x10,0x10,0x10,0x08,0x1F,0x1F,0x10,0x18&#125;,/*\"a\",65*/\n&#123;0x00,0x20,0xE0,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x18,0x08,0x04,0x04,0x0C,0xF8,0xF0,0x00,0x00,0x00,0x1F,0x0F,0x18,0x10,0x10,0x10,0x18,0x0F,0x03,0x00&#125;,/*\"b\",66*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0xF8,0x18,0x04,0x04,0x04,0x3C,0x38,0x00,0x00,0x00,0x00,0x03,0x0F,0x0C,0x10,0x10,0x10,0x10,0x08,0x06,0x00,0x00&#125;,/*\"c\",67*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0xE0,0xF0,0x00,0x00,0x00,0xE0,0xF8,0x1C,0x04,0x04,0x04,0x08,0xFF,0xFF,0x00,0x00,0x00,0x03,0x0F,0x18,0x10,0x10,0x10,0x08,0x1F,0x0F,0x08,0x00&#125;,/*\"d\",68*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0xF8,0x48,0x44,0x44,0x44,0x4C,0x78,0x70,0x00,0x00,0x00,0x03,0x0F,0x0C,0x18,0x10,0x10,0x10,0x08,0x04,0x00&#125;,/*\"e\",69*/\n&#123;0x00,0x00,0x00,0x00,0x80,0xC0,0x60,0x20,0x20,0xE0,0xC0,0x00,0x00,0x04,0x04,0x04,0xFF,0xFF,0x04,0x04,0x04,0x04,0x00,0x00,0x00,0x00,0x10,0x10,0x1F,0x1F,0x10,0x10,0x10,0x00,0x00,0x00&#125;,/*\"f\",70*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0xF8,0x8C,0x04,0x04,0x8C,0xF8,0x74,0x04,0x0C,0x00,0x70,0x76,0xCF,0x8D,0x8D,0x8D,0x89,0xC8,0x78,0x70,0x00&#125;,/*\"g\",71*/\n&#123;0x00,0x20,0xE0,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x08,0x04,0x04,0x04,0xFC,0xF8,0x00,0x00,0x00,0x10,0x1F,0x1F,0x10,0x00,0x00,0x10,0x1F,0x1F,0x10,0x00&#125;,/*\"h\",72*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x60,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x04,0x04,0xFC,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x10,0x10,0x1F,0x1F,0x10,0x10,0x10,0x00,0x00&#125;,/*\"i\",73*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x04,0x04,0xFC,0xFC,0x00,0x00,0x00,0x00,0x00,0xC0,0xC0,0x80,0x80,0xC0,0x7F,0x3F,0x00,0x00,0x00&#125;,/*\"j\",74*/\n&#123;0x00,0x20,0xE0,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x80,0xC0,0xF4,0x1C,0x04,0x04,0x00,0x00,0x00,0x10,0x1F,0x1F,0x11,0x00,0x03,0x1F,0x1C,0x10,0x10,0x00&#125;,/*\"k\",75*/\n&#123;0x00,0x00,0x20,0x20,0x20,0xE0,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x10,0x10,0x1F,0x1F,0x10,0x10,0x10,0x00,0x00&#125;,/*\"l\",76*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0xFC,0xFC,0x08,0x04,0xFC,0xFC,0x08,0x04,0xFC,0xFC,0x00,0x10,0x1F,0x1F,0x10,0x00,0x1F,0x1F,0x10,0x00,0x1F,0x1F,0x10&#125;,/*\"m\",77*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0xFC,0xFC,0x08,0x08,0x04,0x04,0xFC,0xF8,0x00,0x00,0x00,0x10,0x1F,0x1F,0x10,0x00,0x00,0x10,0x1F,0x1F,0x10,0x00&#125;,/*\"n\",78*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0xF0,0x18,0x0C,0x04,0x04,0x0C,0x18,0xF0,0xE0,0x00,0x00,0x03,0x0F,0x0C,0x10,0x10,0x10,0x10,0x0C,0x0F,0x03,0x00&#125;,/*\"o\",79*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0xFC,0xFC,0x08,0x04,0x04,0x04,0x0C,0xF8,0xF0,0x00,0x00,0x80,0xFF,0xFF,0x88,0x90,0x10,0x10,0x1C,0x0F,0x03,0x00&#125;,/*\"p\",80*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0xF8,0x1C,0x04,0x04,0x04,0x08,0xF8,0xFC,0x00,0x00,0x00,0x03,0x0F,0x18,0x10,0x10,0x90,0x88,0xFF,0xFF,0x80,0x00&#125;,/*\"q\",81*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x04,0x04,0xFC,0xFC,0x10,0x08,0x04,0x04,0x0C,0x0C,0x00,0x10,0x10,0x10,0x1F,0x1F,0x10,0x10,0x10,0x00,0x00,0x00,0x00&#125;,/*\"r\",82*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x78,0xCC,0xC4,0x84,0x84,0x84,0x0C,0x1C,0x00,0x00,0x00,0x1E,0x18,0x10,0x10,0x10,0x11,0x19,0x0F,0x06,0x00&#125;,/*\"s\",83*/\n&#123;0x00,0x00,0x00,0x00,0x00,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x04,0x04,0xFF,0xFF,0x04,0x04,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0x1F,0x10,0x10,0x10,0x0C,0x00,0x00&#125;,/*\"t\",84*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0xFC,0xFE,0x00,0x00,0x00,0x04,0xFC,0xFE,0x00,0x00,0x00,0x00,0x0F,0x1F,0x18,0x10,0x10,0x08,0x1F,0x0F,0x08,0x00&#125;,/*\"u\",85*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x0C,0x3C,0xFC,0xC4,0x00,0x00,0xC4,0x3C,0x0C,0x04,0x00,0x00,0x00,0x00,0x01,0x0F,0x1E,0x0E,0x01,0x00,0x00,0x00&#125;,/*\"v\",86*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x3C,0xFC,0xC4,0x00,0xE4,0x7C,0xFC,0x84,0x80,0x7C,0x04,0x00,0x00,0x07,0x1F,0x07,0x00,0x00,0x07,0x1F,0x07,0x00,0x00&#125;,/*\"w\",87*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x04,0x1C,0x7C,0xE4,0xC0,0x34,0x1C,0x04,0x04,0x00,0x00,0x10,0x10,0x1C,0x16,0x01,0x13,0x1F,0x1C,0x18,0x10,0x00&#125;,/*\"x\",88*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x0C,0x3C,0xFC,0xC4,0x00,0xC4,0x3C,0x04,0x04,0x00,0x00,0x00,0xC0,0x80,0xC1,0x37,0x0E,0x01,0x00,0x00,0x00,0x00&#125;,/*\"y\",89*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1C,0x04,0x04,0xC4,0xF4,0x7C,0x1C,0x04,0x00,0x00,0x00,0x00,0x10,0x1C,0x1F,0x17,0x11,0x10,0x10,0x18,0x0E,0x00&#125;,/*\"z\",90*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0x0C,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x28,0xEF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0x60,0x40,0x00,0x00&#125;,/*\"&#123;\",91*/\n&#123;0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00&#125;,/*\"|\",92*/\n&#123;0x00,0x00,0x04,0x0C,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xEF,0x28,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x60,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\"&#125;\",93*/\n&#123;0x00,0x18,0x06,0x02,0x02,0x04,0x08,0x10,0x20,0x20,0x30,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00&#125;,/*\"~\",94*/\n&#125;;\n\n写字节   硬件SPI\n\n\n\n\n\n\n\n\n\nstatic void hal_Oled_WR_Byte(unsigned char dat,unsigned char cmd)\n&#123;\t\n\tunsigned char i;\t\t\n\tunsigned char retry=0;\t\t\n\tif(cmd)\n\t&#123;\n\t\tOLED_DC_Set();\n\t&#125;else \n\t&#123;\n\t\tOLED_DC_Clr();\t\t  \n\t&#125;\n\tSPI1->DR=dat;\t \t  //发送一个byte  \n\tretry=0;\n\twhile((SPI1->SR &amp; SPI_I2S_FLAG_BSY) != RESET)\n\t&#123;\n\t\tretry++;\n\t\tif(retry>200)\n\t\t\treturn;\n\t&#125;  \t\t\t     \t\t  \n\tOLED_DC_Set();   \t  \n&#125;\n\n写字节   软件模拟SPI\n\n\n\n\n\n\n\n\n我们这个是3线spi就限制了不可以软件模拟，软件模拟需要4线，还有一个片选cs，但是软件模拟得知道咋写的\n//写字节  软件模拟SPI\nvoid OLED_WR_Byte(u8 dat,u8 cmd)\n&#123;\t\n\tu8 i;\t\t\t  \n\tif(cmd)\n\t  OLED_DC_Set();\n\telse \n\t  OLED_DC_Clr();\t\t  \n\t//我们3线没有这条线\n    OLED_CS_Clr();\n\tfor(i=0;i&lt;8;i++)\n\t&#123;\t\t\t  \n\t\tOLED_SCL_Clr();\n\t\tif(dat&amp;0x80)\n\t\t   OLED_SDA_Set();\n\t\telse \n\t\t   OLED_SDA_Clr();\n\t\tOLED_SCL_Set();\n\t\tdat&lt;&lt;=1;   \n\t&#125;\t\t\n    //没有这条\n\tOLED_CS_Set();\n\tOLED_DC_Set();   \t  \n&#125;\n\n\n虫子你之后找个机会把lvgl给移植过来，那个UI比这个帅多了串行FLASH文件系统FatFs使用SPI FLASH直接存储数据\n\n\n\n\n\n\n\n\n当需要记录字符“STM32 SPI FLASH”时。可以把这些文字转化成ASCII码，存储在数组中，然后调用SPI_FLASH_BufferWrite函数，把数组内容写入到SPI Flash芯片的指定地址上，在需要的时候从该地址把数据读取出来，再对读出来的数据以ASCII码的格式进行解读\n\n\n难以记录有效数据的位置\n难以确定存储介质的剩余空间\n不明确应以何种格式来解读数据\n\n上面那样存储就有3个致命，所以我们刚开始应该把文件信息啥的先存储在开头\n\nWindows上的文件系统\n\n\n\n\n\n\n\n\n文件系统，就是对数据进行管理的方式。使用文件系统可有效地管理存储介质\n文件系统在计算机中的表现形式\n\n磁盘的物理结构\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n使用文件系统时，它为了存储和管理数据，在存储介质建立了一些组织结构，这些结构包括操作系统引导区、目录和文件\n常见的windows下的文件系统格式包括FAT32、NTFS、exFAT。在使用文件系统前，要先对存储介质进行格式化。格式化时会在存储介质上新建一个文件分配表和目录。这样，文件系统就可以记录数据存放的物理地址，剩余空间\n磁盘分区表\n\n\n\n\n\n\n\n\n\nWindows操作系统为了便于用户对磁盘的管理。加入了磁盘分区的概念，即将一块磁盘逻辑划分为几块，它会把磁盘的分区信息记录到硬盘分区表中\n在硬盘分区表中，描述了各个逻辑分区的属性，如分区开始和结束位置所在的物理地址(柱面号、扇区号)，空间大小等信息\n文件系统 的结构与特性\n\n\n\n\n\n\n\n\n使用文件系统时，数据都以文件的形式存储。写入新文件时，先在目录中创建一个文件索引，它指示了文件存放的物理地址，再把数据存储到该地址中。当需要读取数据时，可以从目录中找到该文件的索引，进而在相应的地址中读取出数据。具体还涉及到逻辑地址、簇大小、不连续存储等一系列辅助结构或处理过程\n文件系统的存在使存取数据时，不再是简单地向某物理地址直接读写，而是要遵循它的读写格式。如经过逻辑转换，一个完整的文件可能被分开成多段存储到不连续的物理地址，使用目录或链表的方式来获知下一段的位置。\n文件系统的空间示意图\n\n\n\n\n\n\n\n\n\n存储了A.TXT，B.TXT，C.TXT文件\n\n记录了文件的开始簇位置、大小等信息\n\nC语言中的文件操作\n\n\n\n\n\n\n\n\n\n文件的打开操作 fopen 打开一个文件文件的关闭操作 fclose 关闭一个文件文件的读写操作 fgetc 从文件中读取一个字符                            fputc 写一个字符到文件中去                            fgets 从文件中读取一个字符串                            fputs 写一个字符串到文件中去                            fprintf 往文件中写格式化数据                            fscanf 格式化读取文件中数据                            fread 以二进制形式读取文件中的数据                            fwrite 以二进制形式写数据到文件中去                            getw 以二进制形式读取一个整数                            putw 以二进制形式存贮一个整数文件状态检查函数 feof 文件结束                            ferror 文件读&#x2F;写出错                            clearerr 清除文件错误标志                            ftell 了解文件指针的当前位置文件定位函数    rewind 反绕                            fseek 随机定位\nFATFS 文件系统简介\n\n\n\n\n\n\n\n\nFatFs是面向小型嵌入式系统的一种通用的FAT文件系统。它完全是由AISI C语言编写并且完全独立于底层的I&#x2F;O介质。因此它可以很容易地不加修改地移植到其他的处理器当中，如8051、PIC、AVR、SH、Z80、H8、ARM等。FatFs支持FAT12、FAT16、FAT32等格式\n利用前面写好的SPI Flash芯片驱动，把FatFs文件系统代码移植到工程之中，就可以利用文件系统的各种函数，对SPI Flash芯片以“文件”格式进行读写操作了\n二级标题三级标题四级标题五级标题六级标题","slug":"wifi主机/wifi主机第四部分  精细化发育","date":"2020-08-15T10:49:36.000Z","categories_index":"单片机","tags_index":"STM32,主机","author_index":"虫子"}]