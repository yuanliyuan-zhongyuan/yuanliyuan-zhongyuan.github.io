{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"段寄存器","date":"2022-12-14T07:19:32.614Z","updated":"2022-09-27T05:18:27.333Z","comments":true,"path":"api/articles/段寄存器.json","keywords":null,"cover":[],"content":"<h1 id=\"段寄存器\"><a href=\"#段寄存器\" class=\"headerlink\" title=\"段寄存器\"></a>段寄存器</h1><h2 id=\"什么是段寄存器\"><a href=\"#什么是段寄存器\" class=\"headerlink\" title=\"什么是段寄存器\"></a>什么是段寄存器</h2><p>在先前的<a href=\"https://www.52pojie.cn/thread-1379580-1-1.html#37113239_stos%E6%8C%87%E4%BB%A4\">逆向基础笔记五 标志寄存器</a>中，有提到过段寄存器的概念</p>\n<p>当使用汇编来操作一个<strong>内存地址</strong>时，就会涉及到段寄存器，只不过先前并没有太过在意</p>\n<p>如：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"> 复制代码 隐藏代码\nmov dword ptr ds:[0x123456],eax<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>注意汇编语句中的 ds，它就是一个段寄存器</p>\n<p>实际上真正读取的内存地址为：ds.base+0x123456</p>\n<hr>\n<h2 id=\"段寄存器有哪些\"><a href=\"#段寄存器有哪些\" class=\"headerlink\" title=\"段寄存器有哪些\"></a>段寄存器有哪些</h2><p>段寄存器共8个： CS DS ES SS FS GS LDTR TR</p>\n<h3 id=\"CS\"><a href=\"#CS\" class=\"headerlink\" title=\"CS\"></a>CS</h3><p>代码段寄存器，用于存放代码段的段基址</p>\n<h3 id=\"DS\"><a href=\"#DS\" class=\"headerlink\" title=\"DS\"></a>DS</h3><p>数据段寄存器，用于存放数据段的段基址</p>\n<h3 id=\"ES\"><a href=\"#ES\" class=\"headerlink\" title=\"ES\"></a>ES</h3><p>附加段寄存器，用于存放附加段的段基址</p>\n<h3 id=\"SS\"><a href=\"#SS\" class=\"headerlink\" title=\"SS\"></a>SS</h3><p>堆栈段寄存器，用于存放堆栈段的段基址，指示堆栈段区域的位置</p>\n<h3 id=\"FS\"><a href=\"#FS\" class=\"headerlink\" title=\"FS\"></a>FS</h3><p>附加段寄存器，F为上一个附加段寄存器字母E后的字母，没有对应的名称</p>\n<p>指向一种被称为<a href=\"https://en.wikipedia.org/wiki/Win32_Thread_Information_Block\">线程信息块</a>（TIB）的结构，这种结构是由内核在创建线程时创建的，用于支持操作系统相关功能、服务和API</p>\n<h3 id=\"GS\"><a href=\"#GS\" class=\"headerlink\" title=\"GS\"></a>GS</h3><p>附加段寄存器，G为上一个附加段寄存器字母F后的字母，没有对应的名称</p>\n<p>在32位Windows上<code>GS</code>保留供将来使用</p>\n<p>在x64模式下，<code>FS</code>和<code>GS</code>段寄存器已交换</p>\n<p>Win64使用<code>GS</code>的原因是该<code>FS</code>寄存器用于32位兼容性层（称为Wow64）</p>\n<p>32位应用程序永远不会导致<code>GS</code>更改，而64位应用程序永远不会导致<code>FS</code>更改</p>\n<p>注意，在Win64和Wow64中GS是非零的，这可以用来检测一个32位应用程序是否在64位Windows中运行，在一个“真正“的32位Windows中GS总是零</p>\n<h3 id=\"IDTR\"><a href=\"#IDTR\" class=\"headerlink\" title=\"IDTR\"></a>IDTR</h3><p>中断描述符表寄存器，用于存放中断描述符表IDT的32位线性基地址和16位表长度值</p>\n<h3 id=\"TR\"><a href=\"#TR\" class=\"headerlink\" title=\"TR\"></a>TR</h3><p>任务寄存器，用于存放当前任务TSS段的16位段选择符、32位基地址、16位段长度和描述符属性值</p>\n<hr>\n<h2 id=\"段寄存器的结构\"><a href=\"#段寄存器的结构\" class=\"headerlink\" title=\"段寄存器的结构\"></a>段寄存器的结构</h2><table>\n<thead>\n<tr>\n<th align=\"left\">组成</th>\n<th align=\"left\">Base</th>\n<th align=\"left\">Limit</th>\n<th align=\"left\">Attribute</th>\n<th align=\"left\">Selector</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>数据宽度</strong></td>\n<td align=\"left\">32位</td>\n<td align=\"left\">32位</td>\n<td align=\"left\">16位</td>\n<td align=\"left\">16位</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>是否可见</strong></td>\n<td align=\"left\">不可见</td>\n<td align=\"left\">不可见</td>\n<td align=\"left\">不可见</td>\n<td align=\"left\">可见</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>描述</strong></td>\n<td align=\"left\">基地址（当前段的起始地址）</td>\n<td align=\"left\">大小限制（当前段的整个长度）</td>\n<td align=\"left\">属性（当前段是否可读可写可执行）</td>\n<td align=\"left\">段选择子</td>\n</tr>\n</tbody></table>\n<hr>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"> 复制代码 隐藏代码struct Segment&#123;\n    WORD Selector;\n    WORD Attribute;\n    DWORD Base;\n    DWORD Limit;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<hr>\n<h2 id=\"段寄存器的属性\"><a href=\"#段寄存器的属性\" class=\"headerlink\" title=\"段寄存器的属性\"></a>段寄存器的属性</h2><p>拿OD随便载入一个程序，观察寄存器窗口：</p>\n<p><img src=\"https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210411163725387.png\" alt=\"image-20210411163725387\"></p>\n<p>得到了当前的计算机的段寄存器信息（不同计算机段寄存器信息不一定相同）</p>\n<hr>\n<table>\n<thead>\n<tr>\n<th align=\"left\"><strong>段寄存器</strong></th>\n<th align=\"left\"><strong>Selector</strong></th>\n<th align=\"left\"><strong>Attribute</strong></th>\n<th align=\"left\"><strong>Base</strong></th>\n<th align=\"left\"><strong>Limit</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">ES</td>\n<td align=\"left\">0023</td>\n<td align=\"left\">可读、可写</td>\n<td align=\"left\">0</td>\n<td align=\"left\">0xFFFFFFFF</td>\n</tr>\n<tr>\n<td align=\"left\">CS</td>\n<td align=\"left\">001B</td>\n<td align=\"left\">可读、可执行</td>\n<td align=\"left\">0</td>\n<td align=\"left\">0xFFFFFFFF</td>\n</tr>\n<tr>\n<td align=\"left\">SS</td>\n<td align=\"left\">0023</td>\n<td align=\"left\">可读、可写</td>\n<td align=\"left\">0</td>\n<td align=\"left\">0xFFFFFFFF</td>\n</tr>\n<tr>\n<td align=\"left\">DS</td>\n<td align=\"left\">0023</td>\n<td align=\"left\">可读、可写</td>\n<td align=\"left\">0</td>\n<td align=\"left\">0xFFFFFFFF</td>\n</tr>\n<tr>\n<td align=\"left\">FS</td>\n<td align=\"left\">003B</td>\n<td align=\"left\">可读、可写</td>\n<td align=\"left\">0x7FFDE000</td>\n<td align=\"left\">0xFFF</td>\n</tr>\n<tr>\n<td align=\"left\">GS</td>\n<td align=\"left\">-</td>\n<td align=\"left\">-</td>\n<td align=\"left\">-</td>\n<td align=\"left\">-</td>\n</tr>\n</tbody></table>\n<h2 id=\"段寄存器的读写\"><a href=\"#段寄存器的读写\" class=\"headerlink\" title=\"段寄存器的读写\"></a>段寄存器的读写</h2><p><strong>对于段寄存器可以使用MOV指令进行读写（LDTR和TR除外）</strong></p>\n<h3 id=\"读段寄存器\"><a href=\"#读段寄存器\" class=\"headerlink\" title=\"读段寄存器\"></a>读段寄存器</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\"> 复制代码 隐藏代码#include &lt;stdio.h&gt;\n#include &lt;windows.h&gt;\nint main()&#123;\n    WORD selector&#x3D;0;\n    _asm&#123;\n        mov selector, es\n    &#125;\n    printf(&quot;%x\\n&quot;,selector);\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>对段寄存器的读操作<strong>只能读取段寄存器的16位Selector部分（可见部分）</strong></p>\n<hr>\n<h4 id=\"运行结果\"><a href=\"#运行结果\" class=\"headerlink\" title=\"运行结果\"></a>运行结果</h4><p><img src=\"https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210411174259638.png\" alt=\"image-20210411174259638\"></p>\n<p>能够正确地读出es段寄存器的selector</p>\n<hr>\n<h3 id=\"写段寄存器\"><a href=\"#写段寄存器\" class=\"headerlink\" title=\"写段寄存器\"></a>写段寄存器</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\"> 复制代码 隐藏代码#include &lt;stdio.h&gt;\n#include &lt;windows.h&gt;\nWORD data&#x3D;0x0610;\nWORD readData&#x3D;0;\n__declspec(naked) void fuction()&#123;\n     __asm&#123;\n                &#x2F;&#x2F;保留调用前堆栈\n                push ebp\n                &#x2F;&#x2F;提升堆栈\n                mov ebp,esp\n                sub esp,0x40\n                &#x2F;&#x2F;保护现场\n                push ebx\n                push esi\n                push edi\n                &#x2F;&#x2F;初始化提升的堆栈，填充缓冲区\n                mov eax,0xCCCCCCCC\n                mov ecx,0x10\n                lea edi,dword ptr ds:[ebp-0x40]\n                rep stosd\n                &#x2F;&#x2F;函数核心功能\n\n                push ds         &#x2F;&#x2F;保存ds段寄存器\n                mov ax,cs       &#x2F;&#x2F;将cs段寄存器的段选择子赋值给ax\n                mov ds,ax       &#x2F;&#x2F;使用cs段寄存器覆盖ds段寄存器\n                mov ax,word ptr ds:[data]       &#x2F;&#x2F;使用修改后的段寄存器ds读取，这里相当于mov ax,word ptr cs:[data]\n                pop ds          &#x2F;&#x2F;还原ds段寄存器\n                mov readData,ax &#x2F;&#x2F;将读出来的数据赋值给变量\n\n                &#x2F;&#x2F;恢复现场\n                pop edi\n                pop esi\n                pop ebx\n\n                &#x2F;&#x2F;降低堆栈\n                mov esp,ebp\n                pop ebp                \n\n                &#x2F;&#x2F;返回\n                ret \n        &#125;        \n&#125;\n\nint main()&#123;\n\n        fuction();\n        printf(&quot;%X\\n&quot;,readData);\n\n        return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<hr>\n<h4 id=\"运行结果-1\"><a href=\"#运行结果-1\" class=\"headerlink\" title=\"运行结果\"></a>运行结果</h4><p><img src=\"https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210412124347258.png\" alt=\"image-20210412124347258\"></p>\n<p>可以看到代码是能够正常执行，并且输出对应的data</p>\n<hr>\n<h4 id=\"说明\"><a href=\"#说明\" class=\"headerlink\" title=\"说明\"></a>说明</h4><p>上述代码使用了裸函数，避免了编译器的干扰；关于裸函数可以回顾：<a href=\"https://www.52pojie.cn/thread-1380788-1-1.html\">逆向基础笔记九 C语言内联汇编和调用协定</a></p>\n<p>截取出关键代码：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"> 复制代码 隐藏代码push ds         &#x2F;&#x2F;保存ds段寄存器\nmov ax,cs       &#x2F;&#x2F;将cs段寄存器的段选择子赋值给ax\nmov ds,ax       &#x2F;&#x2F;使用cs段寄存器覆盖ds段寄存器\nmov ax,word ptr ds:[data]       &#x2F;&#x2F;使用修改后的段寄存器ds读取，这里相当于mov ax,word ptr cs:[data]\npop ds          &#x2F;&#x2F;还原ds段寄存器\nmov readData,ax &#x2F;&#x2F;将读出来的数据赋值给变量<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<hr>\n<p>代码注释如上，就是个简单的覆盖段寄存器的操作</p>\n<hr>\n<p><strong>为什么明明替换了段寄存器，仍然能够正常运行呢？</strong></p>\n<p>首先要注意到，替换和被替换的段寄存器分别是：cs和ds；它们的<strong>base是相同的</strong>都为0，因此<strong>所访问的内存自然也是相同的</strong></p>\n<p>再来看权限问题：无论是cs还是ds，它们<strong>都具有可读的权限</strong>；这里也只对数据进行了读操作，于是可以正常运行</p>\n<p>如果这里将读取data的代码修改为写data的代码，则会报错：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"> 复制代码 隐藏代码mov ax,word ptr ds:[data]   &#x2F;&#x2F;使用cs段寄存器覆盖过的ds段寄存器，读取data\n&#x2F;&#x2F;将上面的代码修改为：\nmov word ptr ds:[data],ax   &#x2F;&#x2F;使用cs段寄存器覆盖过的ds段寄存器，修改data<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>为什么会报错？因为此时的ds段寄存器已经被覆盖为了cs段寄存器，而cs段寄存器的权限为可读、可执行，<strong>没有可写的权限</strong>，所以会报错</p>\n<p>报错截图：</p>\n<p><img src=\"https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210412132518630.png\" alt=\"image-20210412132518630\"></p>\n<p>可以看到，此时的data的地址明明是有效的，先前也验证了可以正确读取，但是在这里就会报错：Acccess Violation（非法访问）</p>\n<p>就这里就是因为段寄存器<strong>权限不足</strong>导致的，也是为什么先前都是使用ds段寄存器来赋值，而不是用cs段寄存器</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"> 复制代码 隐藏代码mov word ptr ds:[address],data  &#x2F;&#x2F;使用ds段寄存器修改数据，可以正常修改\nmov word ptr cs:[address],data &#x2F;&#x2F;使用cs段寄存器修改数据，会报错<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<hr>\n<p>和前面对段寄存器的读操作不同，写寄存器是<strong>对整个96位的段寄存器进行修改</strong></p>\n<p>但是这里明明只给出了16位的段选择子Selector，剩下的80位呢？</p>\n<p>这个就<strong>段描述符</strong>有关了，这里暂且不谈，留作之后自会知晓，先记住<strong>写寄存器是对整个段寄存器进行修改</strong>即可</p>\n<hr>\n<h2 id=\"验证Limit\"><a href=\"#验证Limit\" class=\"headerlink\" title=\"验证Limit\"></a>验证Limit</h2><p>在前面的读写中，或多或少都验证了段寄存器的几个属性：Base、Selector、Attribute</p>\n<p>现在最后验证一下Limit</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"> 复制代码 隐藏代码#include &lt;stdio.h&gt;\n#include &lt;windows.h&gt;\nint main()&#123;\n\n    unsigned char base;\n    _asm&#123;   \n\n        mov al,fs:[0x1000]      &#x2F;&#x2F;超过limit:0xfff，无法正常运行\n        mov base,al\n    &#125;\n    printf(&quot;%x\\n&quot;,base);\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><img src=\"https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210411190011540.png\" alt=\"image-20210411190011540\"></p>\n<hr>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\"> 复制代码 隐藏代码#include &lt;stdio.h&gt;\n#include &lt;windows.h&gt;\nint main()&#123;\n\n    unsigned char base;\n    _asm&#123;   \n\n        mov al,fs:[0xfff]       &#x2F;&#x2F;在临界点可以正常运行\n        mov base,al\n    &#125;\n    printf(&quot;%x\\n&quot;,base);\n    return 0;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><img src=\"https://610-pic-bed.oss-cn-shenzhen.aliyuncs.com/image-20210411185454452.png\" alt=\"image-20210411185454452\"></p>\n<hr>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><ul>\n<li>段寄存器共96位，其中16位为可见部分，后80位为不可见部分</li>\n<li>不同计算机段寄存器信息不一定相同</li>\n<li>FS和GS两个段寄存器分别在32位程序和64位程序发挥作用</li>\n</ul>\n","text":"段寄存器什么是段寄存器在先前的逆向基础笔记五 标志寄存器中，有提到过段寄存器的概念 当使用汇编来操作一个内存地址时，就会涉及到段寄存器，只不过先前并没有太过在意 如： 复制代码 隐藏代码 mov dword ptr ds:[0x123456],eax 注意汇编语句中的 ds，它就...","link":"","photos":[],"count_time":{"symbolsCount":"4.9k","symbolsTime":"4 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8\"><span class=\"toc-text\">段寄存器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8\"><span class=\"toc-text\">什么是段寄存器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B\"><span class=\"toc-text\">段寄存器有哪些</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#CS\"><span class=\"toc-text\">CS</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#DS\"><span class=\"toc-text\">DS</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ES\"><span class=\"toc-text\">ES</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#SS\"><span class=\"toc-text\">SS</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#FS\"><span class=\"toc-text\">FS</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#GS\"><span class=\"toc-text\">GS</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#IDTR\"><span class=\"toc-text\">IDTR</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#TR\"><span class=\"toc-text\">TR</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">段寄存器的结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">段寄存器的属性</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E8%AF%BB%E5%86%99\"><span class=\"toc-text\">段寄存器的读写</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%BB%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8\"><span class=\"toc-text\">读段寄存器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C\"><span class=\"toc-text\">运行结果</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%86%99%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8\"><span class=\"toc-text\">写段寄存器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-1\"><span class=\"toc-text\">运行结果</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AF%B4%E6%98%8E\"><span class=\"toc-text\">说明</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%AA%8C%E8%AF%81Limit\"><span class=\"toc-text\">验证Limit</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol>","author":{"name":"虫子","slug":"blog-author","avatar":"https://zzypicgo.oss-cn-shanghai.aliyuncs.com/pic-go-master/img/hello2.png","link":"/","description":"一旦错过，愿你安好","socials":{"github":"https://github.com/yuanliyuan-zhongyuan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wei-yuan-88-76-79","csdn":"https://blog.csdn.net/qq_42832862","juejin":"https://juejin.cn/user/2507322433224183","customs":{"bilibili":{"icon":"fa-brands fa-bilibili","link":"https://space.bilibili.com/387304134"}}}},"mapped":true,"prev_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"段描述符和段选择子","date":"2022-12-14T07:19:32.617Z","updated":"2022-09-27T05:19:04.622Z","comments":true,"path":"api/articles/段描述符和段选择子.json","keywords":null,"cover":[],"text":"段描述符引出问题首先要解决的就是上个笔记遗留下来的问题： 复制代码 隐藏代码mov bx,ds &#x2F;&#x2F;将段寄存器ds的Selector部分保存到bx（ecx的低16位） mov ax,cs &#x2F;&#x2F;将段寄存器cs的Selector部分保存到ax（...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[],"tags":[],"author":{"name":"虫子","slug":"blog-author","avatar":"https://zzypicgo.oss-cn-shanghai.aliyuncs.com/pic-go-master/img/hello2.png","link":"/","description":"一旦错过，愿你安好","socials":{"github":"https://github.com/yuanliyuan-zhongyuan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wei-yuan-88-76-79","csdn":"https://blog.csdn.net/qq_42832862","juejin":"https://juejin.cn/user/2507322433224183","customs":{"bilibili":{"icon":"fa-brands fa-bilibili","link":"https://space.bilibili.com/387304134"}}}}},"next_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"中断门和IDT(中断描述符表)","date":"2022-12-14T07:19:32.604Z","updated":"2022-09-27T05:44:17.442Z","comments":true,"path":"api/articles/中断门和IDT(中断描述符表).json","keywords":null,"cover":null,"text":"","link":"","photos":[],"count_time":{"symbolsCount":0,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"虫子","slug":"blog-author","avatar":"https://zzypicgo.oss-cn-shanghai.aliyuncs.com/pic-go-master/img/hello2.png","link":"/","description":"一旦错过，愿你安好","socials":{"github":"https://github.com/yuanliyuan-zhongyuan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/wei-yuan-88-76-79","csdn":"https://blog.csdn.net/qq_42832862","juejin":"https://juejin.cn/user/2507322433224183","customs":{"bilibili":{"icon":"fa-brands fa-bilibili","link":"https://space.bilibili.com/387304134"}}}}}}